borderInterpolate cv::borderInterpolate
copyMakeBorder cv::copyMakeBorder
copyMakeBorder cv::copyMakeBorder
add cv::add
add cv::add
subtract cv::subtract
subtract cv::subtract
multiply cv::multiply
multiply cv::multiply
divide cv::divide
divide cv::divide
divide cv::divide
divide cv::divide
scaleAdd cv::scaleAdd
scaleAdd cv::scaleAdd
addWeighted cv::addWeighted
addWeighted cv::addWeighted
convertScaleAbs cv::convertScaleAbs
convertScaleAbs cv::convertScaleAbs
convertFp16 cv::convertFp16
convertFp16 cv::convertFp16
LUT cv::LUT
LUT cv::LUT
sumElems cv::sum
sumElems cv::sum
countNonZero cv::countNonZero
countNonZero cv::countNonZero
findNonZero cv::findNonZero
findNonZero cv::findNonZero
mean cv::mean
mean cv::mean
meanStdDev cv::meanStdDev
meanStdDev cv::meanStdDev
norm cv::norm
norm cv::norm
norm cv::norm
norm cv::norm
PSNR cv::PSNR
PSNR cv::PSNR
batchDistance cv::batchDistance
batchDistance cv::batchDistance
normalize cv::normalize
normalize cv::normalize
minMaxLoc cv::minMaxLoc
minMaxLoc cv::minMaxLoc
reduce cv::reduce
reduce cv::reduce
merge cv::merge
merge cv::merge
split cv::split
split cv::split
mixChannels cv::mixChannels
mixChannels cv::mixChannels
extractChannel cv::extractChannel
extractChannel cv::extractChannel
insertChannel cv::insertChannel
insertChannel cv::insertChannel
flip cv::flip
flip cv::flip
rotate cv::rotate
rotate cv::rotate
repeat cv::repeat
repeat cv::repeat
hconcat cv::hconcat
hconcat cv::hconcat
vconcat cv::vconcat
vconcat cv::vconcat
bitwise_and cv::bitwise_and
bitwise_and cv::bitwise_and
bitwise_or cv::bitwise_or
bitwise_or cv::bitwise_or
bitwise_xor cv::bitwise_xor
bitwise_xor cv::bitwise_xor
bitwise_not cv::bitwise_not
bitwise_not cv::bitwise_not
absdiff cv::absdiff
absdiff cv::absdiff
copyTo cv::copyTo
copyTo cv::copyTo
inRange cv::inRange
inRange cv::inRange
compare cv::compare
compare cv::compare
min cv::min
min cv::min
max cv::max
max cv::max
sqrt cv::sqrt
sqrt cv::sqrt
pow cv::pow
pow cv::pow
exp cv::exp
exp cv::exp
log cv::log
log cv::log
polarToCart cv::polarToCart
polarToCart cv::polarToCart
cartToPolar cv::cartToPolar
cartToPolar cv::cartToPolar
phase cv::phase
phase cv::phase
magnitude cv::magnitude
magnitude cv::magnitude
checkRange cv::checkRange
checkRange cv::checkRange
patchNaNs cv::patchNaNs
patchNaNs cv::patchNaNs
gemm cv::gemm
gemm cv::gemm
mulTransposed cv::mulTransposed
mulTransposed cv::mulTransposed
transpose cv::transpose
transpose cv::transpose
transform cv::transform
transform cv::transform
perspectiveTransform cv::perspectiveTransform
perspectiveTransform cv::perspectiveTransform
completeSymm cv::completeSymm
completeSymm cv::completeSymm
setIdentity cv::setIdentity
setIdentity cv::setIdentity
determinant cv::determinant
determinant cv::determinant
trace cv::trace
trace cv::trace
invert cv::invert
invert cv::invert
solve cv::solve
solve cv::solve
sort cv::sort
sort cv::sort
sortIdx cv::sortIdx
sortIdx cv::sortIdx
solveCubic cv::solveCubic
solveCubic cv::solveCubic
solvePoly cv::solvePoly
solvePoly cv::solvePoly
eigen cv::eigen
eigen cv::eigen
eigenNonSymmetric cv::eigenNonSymmetric
eigenNonSymmetric cv::eigenNonSymmetric
calcCovarMatrix cv::calcCovarMatrix
calcCovarMatrix cv::calcCovarMatrix
PCACompute cv::PCACompute
PCACompute cv::PCACompute
PCACompute2 cv::PCACompute
PCACompute2 cv::PCACompute
PCACompute cv::PCACompute
PCACompute cv::PCACompute
PCACompute2 cv::PCACompute
PCACompute2 cv::PCACompute
PCAProject cv::PCAProject
PCAProject cv::PCAProject
PCABackProject cv::PCABackProject
PCABackProject cv::PCABackProject
SVDecomp cv::SVDecomp
SVDecomp cv::SVDecomp
SVBackSubst cv::SVBackSubst
SVBackSubst cv::SVBackSubst
Mahalanobis cv::Mahalanobis
Mahalanobis cv::Mahalanobis
dft cv::dft
dft cv::dft
idft cv::idft
idft cv::idft
dct cv::dct
dct cv::dct
idct cv::idct
idct cv::idct
mulSpectrums cv::mulSpectrums
mulSpectrums cv::mulSpectrums
getOptimalDFTSize cv::getOptimalDFTSize
setRNGSeed cv::setRNGSeed
randu cv::randu
randu cv::randu
randn cv::randn
randn cv::randn
randShuffle cv::randShuffle
randShuffle cv::randShuffle
kmeans cv::kmeans
kmeans cv::kmeans
n cv.Algorithm
cv.Algorithm
cv Algorithm
clear cv::Algorithm::clear
write cv::Algorithm::write
read cv::Algorithm::read
empty cv::Algorithm::empty
save cv::Algorithm::save
getDefaultName cv::Algorithm::getDefaultName
haveOpenCL cv::ocl::haveOpenCL
useOpenCL cv::ocl::useOpenCL
haveAmdBlas cv::ocl::haveAmdBlas
haveAmdFft cv::ocl::haveAmdFft
setUseOpenCL cv::ocl::setUseOpenCL
finish cv::ocl::finish
n cv.ocl.Device
cv.ocl.Device
cv.ocl Device
Device cv::ocl::Device::Device
[]
name cv::ocl::Device::name
extensions cv::ocl::Device::extensions
isExtensionSupported cv::ocl::Device::isExtensionSupported
version cv::ocl::Device::version
vendorName cv::ocl::Device::vendorName
OpenCL_C_Version cv::ocl::Device::OpenCL_C_Version
OpenCLVersion cv::ocl::Device::OpenCLVersion
deviceVersionMajor cv::ocl::Device::deviceVersionMajor
deviceVersionMinor cv::ocl::Device::deviceVersionMinor
driverVersion cv::ocl::Device::driverVersion
type cv::ocl::Device::type
addressBits cv::ocl::Device::addressBits
available cv::ocl::Device::available
compilerAvailable cv::ocl::Device::compilerAvailable
linkerAvailable cv::ocl::Device::linkerAvailable
doubleFPConfig cv::ocl::Device::doubleFPConfig
singleFPConfig cv::ocl::Device::singleFPConfig
halfFPConfig cv::ocl::Device::halfFPConfig
endianLittle cv::ocl::Device::endianLittle
errorCorrectionSupport cv::ocl::Device::errorCorrectionSupport
executionCapabilities cv::ocl::Device::executionCapabilities
globalMemCacheSize cv::ocl::Device::globalMemCacheSize
globalMemCacheType cv::ocl::Device::globalMemCacheType
globalMemCacheLineSize cv::ocl::Device::globalMemCacheLineSize
globalMemSize cv::ocl::Device::globalMemSize
localMemSize cv::ocl::Device::localMemSize
localMemType cv::ocl::Device::localMemType
hostUnifiedMemory cv::ocl::Device::hostUnifiedMemory
imageSupport cv::ocl::Device::imageSupport
imageFromBufferSupport cv::ocl::Device::imageFromBufferSupport
intelSubgroupsSupport cv::ocl::Device::intelSubgroupsSupport
image2DMaxWidth cv::ocl::Device::image2DMaxWidth
image2DMaxHeight cv::ocl::Device::image2DMaxHeight
image3DMaxWidth cv::ocl::Device::image3DMaxWidth
image3DMaxHeight cv::ocl::Device::image3DMaxHeight
image3DMaxDepth cv::ocl::Device::image3DMaxDepth
imageMaxBufferSize cv::ocl::Device::imageMaxBufferSize
imageMaxArraySize cv::ocl::Device::imageMaxArraySize
vendorID cv::ocl::Device::vendorID
isAMD cv::ocl::Device::isAMD
isIntel cv::ocl::Device::isIntel
isNVidia cv::ocl::Device::isNVidia
maxClockFrequency cv::ocl::Device::maxClockFrequency
maxComputeUnits cv::ocl::Device::maxComputeUnits
maxConstantArgs cv::ocl::Device::maxConstantArgs
maxConstantBufferSize cv::ocl::Device::maxConstantBufferSize
maxMemAllocSize cv::ocl::Device::maxMemAllocSize
maxParameterSize cv::ocl::Device::maxParameterSize
maxReadImageArgs cv::ocl::Device::maxReadImageArgs
maxWriteImageArgs cv::ocl::Device::maxWriteImageArgs
maxSamplers cv::ocl::Device::maxSamplers
maxWorkGroupSize cv::ocl::Device::maxWorkGroupSize
maxWorkItemDims cv::ocl::Device::maxWorkItemDims
memBaseAddrAlign cv::ocl::Device::memBaseAddrAlign
nativeVectorWidthChar cv::ocl::Device::nativeVectorWidthChar
nativeVectorWidthShort cv::ocl::Device::nativeVectorWidthShort
nativeVectorWidthInt cv::ocl::Device::nativeVectorWidthInt
nativeVectorWidthLong cv::ocl::Device::nativeVectorWidthLong
nativeVectorWidthFloat cv::ocl::Device::nativeVectorWidthFloat
nativeVectorWidthDouble cv::ocl::Device::nativeVectorWidthDouble
nativeVectorWidthHalf cv::ocl::Device::nativeVectorWidthHalf
preferredVectorWidthChar cv::ocl::Device::preferredVectorWidthChar
preferredVectorWidthShort cv::ocl::Device::preferredVectorWidthShort
preferredVectorWidthInt cv::ocl::Device::preferredVectorWidthInt
preferredVectorWidthLong cv::ocl::Device::preferredVectorWidthLong
preferredVectorWidthFloat cv::ocl::Device::preferredVectorWidthFloat
preferredVectorWidthDouble cv::ocl::Device::preferredVectorWidthDouble
preferredVectorWidthHalf cv::ocl::Device::preferredVectorWidthHalf
printfBufferSize cv::ocl::Device::printfBufferSize
profilingTimerResolution cv::ocl::Device::profilingTimerResolution
getDefault cv::ocl::Device::getDefault
Device_getDefault cv::ocl::Device::getDefault
n cv.flann.Index
cv.flann.Index
cv.flann Index
Index cv::flann::Index::Index
[]
Index cv::flann::Index::Index
[]
Index cv::flann::Index::Index
[]
build cv::flann::Index::build
build cv::flann::Index::build
knnSearch cv::flann::Index::knnSearch
knnSearch cv::flann::Index::knnSearch
radiusSearch cv::flann::Index::radiusSearch
radiusSearch cv::flann::Index::radiusSearch
save cv::flann::Index::save
load cv::flann::Index::load
load cv::flann::Index::load
release cv::flann::Index::release
getDistance cv::flann::Index::getDistance
getAlgorithm cv::flann::Index::getAlgorithm
n cv.ml.ParamGrid
cv.ml.ParamGrid
cv.ml ParamGrid
create cv::ml::ParamGrid::create
ParamGrid_create cv::ml::ParamGrid::create
n cv.ml.TrainData
cv.ml.TrainData
cv.ml TrainData
getLayout cv::ml::TrainData::getLayout
getNTrainSamples cv::ml::TrainData::getNTrainSamples
getNTestSamples cv::ml::TrainData::getNTestSamples
getNSamples cv::ml::TrainData::getNSamples
getNVars cv::ml::TrainData::getNVars
getNAllVars cv::ml::TrainData::getNAllVars
getSample cv::ml::TrainData::getSample
getSample cv::ml::TrainData::getSample
getSamples cv::ml::TrainData::getSamples
getMissing cv::ml::TrainData::getMissing
getTrainSamples cv::ml::TrainData::getTrainSamples
getTrainResponses cv::ml::TrainData::getTrainResponses
getTrainNormCatResponses cv::ml::TrainData::getTrainNormCatResponses
getTestResponses cv::ml::TrainData::getTestResponses
getTestNormCatResponses cv::ml::TrainData::getTestNormCatResponses
getResponses cv::ml::TrainData::getResponses
getNormCatResponses cv::ml::TrainData::getNormCatResponses
getSampleWeights cv::ml::TrainData::getSampleWeights
getTrainSampleWeights cv::ml::TrainData::getTrainSampleWeights
getTestSampleWeights cv::ml::TrainData::getTestSampleWeights
getVarIdx cv::ml::TrainData::getVarIdx
getVarType cv::ml::TrainData::getVarType
getVarSymbolFlags cv::ml::TrainData::getVarSymbolFlags
getResponseType cv::ml::TrainData::getResponseType
getTrainSampleIdx cv::ml::TrainData::getTrainSampleIdx
getTestSampleIdx cv::ml::TrainData::getTestSampleIdx
getValues cv::ml::TrainData::getValues
getValues cv::ml::TrainData::getValues
getDefaultSubstValues cv::ml::TrainData::getDefaultSubstValues
getCatCount cv::ml::TrainData::getCatCount
getClassLabels cv::ml::TrainData::getClassLabels
getCatOfs cv::ml::TrainData::getCatOfs
getCatMap cv::ml::TrainData::getCatMap
setTrainTestSplit cv::ml::TrainData::setTrainTestSplit
setTrainTestSplitRatio cv::ml::TrainData::setTrainTestSplitRatio
shuffleTrainTest cv::ml::TrainData::shuffleTrainTest
getTestSamples cv::ml::TrainData::getTestSamples
getNames cv::ml::TrainData::getNames
getSubVector cv::ml::TrainData::getSubVector
TrainData_getSubVector cv::ml::TrainData::getSubVector
getSubVector cv::ml::TrainData::getSubVector
TrainData_getSubVector cv::ml::TrainData::getSubVector
getSubMatrix cv::ml::TrainData::getSubMatrix
TrainData_getSubMatrix cv::ml::TrainData::getSubMatrix
getSubMatrix cv::ml::TrainData::getSubMatrix
TrainData_getSubMatrix cv::ml::TrainData::getSubMatrix
create cv::ml::TrainData::create
TrainData_create cv::ml::TrainData::create
create cv::ml::TrainData::create
TrainData_create cv::ml::TrainData::create
n cv.ml.StatModel
['cv::Algorithm']
cv::Algorithm
cv.ml.StatModel
cv.ml StatModel
getVarCount cv::ml::StatModel::getVarCount
empty cv::ml::StatModel::empty
isTrained cv::ml::StatModel::isTrained
isClassifier cv::ml::StatModel::isClassifier
train cv::ml::StatModel::train
train cv::ml::StatModel::train
train cv::ml::StatModel::train
calcError cv::ml::StatModel::calcError
calcError cv::ml::StatModel::calcError
predict cv::ml::StatModel::predict
predict cv::ml::StatModel::predict
n cv.ml.NormalBayesClassifier
['cv::ml::StatModel']
cv::ml::StatModel
cv.ml.NormalBayesClassifier
cv.ml NormalBayesClassifier
predictProb cv::ml::NormalBayesClassifier::predictProb
predictProb cv::ml::NormalBayesClassifier::predictProb
create cv::ml::NormalBayesClassifier::create
NormalBayesClassifier_create cv::ml::NormalBayesClassifier::create
load cv::ml::NormalBayesClassifier::load
NormalBayesClassifier_load cv::ml::NormalBayesClassifier::load
n cv.ml.KNearest
['cv::ml::StatModel']
cv::ml::StatModel
cv.ml.KNearest
cv.ml KNearest
getDefaultK cv::ml::KNearest::getDefaultK
setDefaultK cv::ml::KNearest::setDefaultK
getIsClassifier cv::ml::KNearest::getIsClassifier
setIsClassifier cv::ml::KNearest::setIsClassifier
getEmax cv::ml::KNearest::getEmax
setEmax cv::ml::KNearest::setEmax
getAlgorithmType cv::ml::KNearest::getAlgorithmType
setAlgorithmType cv::ml::KNearest::setAlgorithmType
findNearest cv::ml::KNearest::findNearest
findNearest cv::ml::KNearest::findNearest
create cv::ml::KNearest::create
KNearest_create cv::ml::KNearest::create
load cv::ml::KNearest::load
KNearest_load cv::ml::KNearest::load
n cv.ml.SVM
['cv::ml::StatModel']
cv::ml::StatModel
cv.ml.SVM
cv.ml SVM
getType cv::ml::SVM::getType
setType cv::ml::SVM::setType
getGamma cv::ml::SVM::getGamma
setGamma cv::ml::SVM::setGamma
getCoef0 cv::ml::SVM::getCoef0
setCoef0 cv::ml::SVM::setCoef0
getDegree cv::ml::SVM::getDegree
setDegree cv::ml::SVM::setDegree
getC cv::ml::SVM::getC
setC cv::ml::SVM::setC
getNu cv::ml::SVM::getNu
setNu cv::ml::SVM::setNu
getP cv::ml::SVM::getP
setP cv::ml::SVM::setP
getClassWeights cv::ml::SVM::getClassWeights
setClassWeights cv::ml::SVM::setClassWeights
setClassWeights cv::ml::SVM::setClassWeights
getTermCriteria cv::ml::SVM::getTermCriteria
setTermCriteria cv::ml::SVM::setTermCriteria
getKernelType cv::ml::SVM::getKernelType
setKernel cv::ml::SVM::setKernel
trainAuto cv::ml::SVM::trainAuto
trainAuto cv::ml::SVM::trainAuto
getSupportVectors cv::ml::SVM::getSupportVectors
getUncompressedSupportVectors cv::ml::SVM::getUncompressedSupportVectors
getDecisionFunction cv::ml::SVM::getDecisionFunction
getDecisionFunction cv::ml::SVM::getDecisionFunction
getDefaultGridPtr cv::ml::SVM::getDefaultGridPtr
SVM_getDefaultGridPtr cv::ml::SVM::getDefaultGridPtr
create cv::ml::SVM::create
SVM_create cv::ml::SVM::create
load cv::ml::SVM::load
SVM_load cv::ml::SVM::load
n cv.ml.EM
['cv::ml::StatModel']
cv::ml::StatModel
cv.ml.EM
cv.ml EM
getClustersNumber cv::ml::EM::getClustersNumber
setClustersNumber cv::ml::EM::setClustersNumber
getCovarianceMatrixType cv::ml::EM::getCovarianceMatrixType
setCovarianceMatrixType cv::ml::EM::setCovarianceMatrixType
getTermCriteria cv::ml::EM::getTermCriteria
setTermCriteria cv::ml::EM::setTermCriteria
getWeights cv::ml::EM::getWeights
getMeans cv::ml::EM::getMeans
getCovs cv::ml::EM::getCovs
getCovs cv::ml::EM::getCovs
predict cv::ml::EM::predict
predict cv::ml::EM::predict
predict2 cv::ml::EM::predict2
predict2 cv::ml::EM::predict2
trainEM cv::ml::EM::trainEM
trainEM cv::ml::EM::trainEM
trainE cv::ml::EM::trainE
trainE cv::ml::EM::trainE
trainM cv::ml::EM::trainM
trainM cv::ml::EM::trainM
create cv::ml::EM::create
EM_create cv::ml::EM::create
load cv::ml::EM::load
EM_load cv::ml::EM::load
n cv.ml.DTrees
['cv::ml::StatModel']
cv::ml::StatModel
cv.ml.DTrees
cv.ml DTrees
getMaxCategories cv::ml::DTrees::getMaxCategories
setMaxCategories cv::ml::DTrees::setMaxCategories
getMaxDepth cv::ml::DTrees::getMaxDepth
setMaxDepth cv::ml::DTrees::setMaxDepth
getMinSampleCount cv::ml::DTrees::getMinSampleCount
setMinSampleCount cv::ml::DTrees::setMinSampleCount
getCVFolds cv::ml::DTrees::getCVFolds
setCVFolds cv::ml::DTrees::setCVFolds
getUseSurrogates cv::ml::DTrees::getUseSurrogates
setUseSurrogates cv::ml::DTrees::setUseSurrogates
getUse1SERule cv::ml::DTrees::getUse1SERule
setUse1SERule cv::ml::DTrees::setUse1SERule
getTruncatePrunedTree cv::ml::DTrees::getTruncatePrunedTree
setTruncatePrunedTree cv::ml::DTrees::setTruncatePrunedTree
getRegressionAccuracy cv::ml::DTrees::getRegressionAccuracy
setRegressionAccuracy cv::ml::DTrees::setRegressionAccuracy
getPriors cv::ml::DTrees::getPriors
setPriors cv::ml::DTrees::setPriors
setPriors cv::ml::DTrees::setPriors
create cv::ml::DTrees::create
DTrees_create cv::ml::DTrees::create
load cv::ml::DTrees::load
DTrees_load cv::ml::DTrees::load
n cv.ml.RTrees
['cv::ml::DTrees']
cv::ml::DTrees
cv.ml.RTrees
cv.ml RTrees
getCalculateVarImportance cv::ml::RTrees::getCalculateVarImportance
setCalculateVarImportance cv::ml::RTrees::setCalculateVarImportance
getActiveVarCount cv::ml::RTrees::getActiveVarCount
setActiveVarCount cv::ml::RTrees::setActiveVarCount
getTermCriteria cv::ml::RTrees::getTermCriteria
setTermCriteria cv::ml::RTrees::setTermCriteria
getVarImportance cv::ml::RTrees::getVarImportance
getVotes cv::ml::RTrees::getVotes
getVotes cv::ml::RTrees::getVotes
create cv::ml::RTrees::create
RTrees_create cv::ml::RTrees::create
load cv::ml::RTrees::load
RTrees_load cv::ml::RTrees::load
n cv.ml.Boost
['cv::ml::DTrees']
cv::ml::DTrees
cv.ml.Boost
cv.ml Boost
getBoostType cv::ml::Boost::getBoostType
setBoostType cv::ml::Boost::setBoostType
getWeakCount cv::ml::Boost::getWeakCount
setWeakCount cv::ml::Boost::setWeakCount
getWeightTrimRate cv::ml::Boost::getWeightTrimRate
setWeightTrimRate cv::ml::Boost::setWeightTrimRate
create cv::ml::Boost::create
Boost_create cv::ml::Boost::create
load cv::ml::Boost::load
Boost_load cv::ml::Boost::load
n cv.ml.ANN_MLP
['cv::ml::StatModel']
cv::ml::StatModel
cv.ml.ANN_MLP
cv.ml ANN_MLP
setTrainMethod cv::ml::ANN_MLP::setTrainMethod
getTrainMethod cv::ml::ANN_MLP::getTrainMethod
setActivationFunction cv::ml::ANN_MLP::setActivationFunction
setLayerSizes cv::ml::ANN_MLP::setLayerSizes
setLayerSizes cv::ml::ANN_MLP::setLayerSizes
getLayerSizes cv::ml::ANN_MLP::getLayerSizes
getTermCriteria cv::ml::ANN_MLP::getTermCriteria
setTermCriteria cv::ml::ANN_MLP::setTermCriteria
getBackpropWeightScale cv::ml::ANN_MLP::getBackpropWeightScale
setBackpropWeightScale cv::ml::ANN_MLP::setBackpropWeightScale
getBackpropMomentumScale cv::ml::ANN_MLP::getBackpropMomentumScale
setBackpropMomentumScale cv::ml::ANN_MLP::setBackpropMomentumScale
getRpropDW0 cv::ml::ANN_MLP::getRpropDW0
setRpropDW0 cv::ml::ANN_MLP::setRpropDW0
getRpropDWPlus cv::ml::ANN_MLP::getRpropDWPlus
setRpropDWPlus cv::ml::ANN_MLP::setRpropDWPlus
getRpropDWMinus cv::ml::ANN_MLP::getRpropDWMinus
setRpropDWMinus cv::ml::ANN_MLP::setRpropDWMinus
getRpropDWMin cv::ml::ANN_MLP::getRpropDWMin
setRpropDWMin cv::ml::ANN_MLP::setRpropDWMin
getRpropDWMax cv::ml::ANN_MLP::getRpropDWMax
setRpropDWMax cv::ml::ANN_MLP::setRpropDWMax
getAnnealInitialT cv::ml::ANN_MLP::getAnnealInitialT
setAnnealInitialT cv::ml::ANN_MLP::setAnnealInitialT
getAnnealFinalT cv::ml::ANN_MLP::getAnnealFinalT
setAnnealFinalT cv::ml::ANN_MLP::setAnnealFinalT
getAnnealCoolingRatio cv::ml::ANN_MLP::getAnnealCoolingRatio
setAnnealCoolingRatio cv::ml::ANN_MLP::setAnnealCoolingRatio
getAnnealItePerStep cv::ml::ANN_MLP::getAnnealItePerStep
setAnnealItePerStep cv::ml::ANN_MLP::setAnnealItePerStep
getWeights cv::ml::ANN_MLP::getWeights
create cv::ml::ANN_MLP::create
ANN_MLP_create cv::ml::ANN_MLP::create
load cv::ml::ANN_MLP::load
ANN_MLP_load cv::ml::ANN_MLP::load
n cv.ml.LogisticRegression
['cv::ml::StatModel']
cv::ml::StatModel
cv.ml.LogisticRegression
cv.ml LogisticRegression
getLearningRate cv::ml::LogisticRegression::getLearningRate
setLearningRate cv::ml::LogisticRegression::setLearningRate
getIterations cv::ml::LogisticRegression::getIterations
setIterations cv::ml::LogisticRegression::setIterations
getRegularization cv::ml::LogisticRegression::getRegularization
setRegularization cv::ml::LogisticRegression::setRegularization
getTrainMethod cv::ml::LogisticRegression::getTrainMethod
setTrainMethod cv::ml::LogisticRegression::setTrainMethod
getMiniBatchSize cv::ml::LogisticRegression::getMiniBatchSize
setMiniBatchSize cv::ml::LogisticRegression::setMiniBatchSize
getTermCriteria cv::ml::LogisticRegression::getTermCriteria
setTermCriteria cv::ml::LogisticRegression::setTermCriteria
predict cv::ml::LogisticRegression::predict
predict cv::ml::LogisticRegression::predict
get_learnt_thetas cv::ml::LogisticRegression::get_learnt_thetas
create cv::ml::LogisticRegression::create
LogisticRegression_create cv::ml::LogisticRegression::create
load cv::ml::LogisticRegression::load
LogisticRegression_load cv::ml::LogisticRegression::load
n cv.ml.SVMSGD
['cv::ml::StatModel']
cv::ml::StatModel
cv.ml.SVMSGD
cv.ml SVMSGD
getWeights cv::ml::SVMSGD::getWeights
getShift cv::ml::SVMSGD::getShift
create cv::ml::SVMSGD::create
SVMSGD_create cv::ml::SVMSGD::create
load cv::ml::SVMSGD::load
SVMSGD_load cv::ml::SVMSGD::load
setOptimalParameters cv::ml::SVMSGD::setOptimalParameters
getSvmsgdType cv::ml::SVMSGD::getSvmsgdType
setSvmsgdType cv::ml::SVMSGD::setSvmsgdType
getMarginType cv::ml::SVMSGD::getMarginType
setMarginType cv::ml::SVMSGD::setMarginType
getMarginRegularization cv::ml::SVMSGD::getMarginRegularization
setMarginRegularization cv::ml::SVMSGD::setMarginRegularization
getInitialStepSize cv::ml::SVMSGD::getInitialStepSize
setInitialStepSize cv::ml::SVMSGD::setInitialStepSize
getStepDecreasingPower cv::ml::SVMSGD::getStepDecreasingPower
setStepDecreasingPower cv::ml::SVMSGD::setStepDecreasingPower
getTermCriteria cv::ml::SVMSGD::getTermCriteria
setTermCriteria cv::ml::SVMSGD::setTermCriteria
n cv.GeneralizedHough
['cv::Algorithm']
cv::Algorithm
cv.GeneralizedHough
cv GeneralizedHough
setTemplate cv::GeneralizedHough::setTemplate
setTemplate cv::GeneralizedHough::setTemplate
setTemplate cv::GeneralizedHough::setTemplate
setTemplate cv::GeneralizedHough::setTemplate
detect cv::GeneralizedHough::detect
detect cv::GeneralizedHough::detect
detect cv::GeneralizedHough::detect
detect cv::GeneralizedHough::detect
setCannyLowThresh cv::GeneralizedHough::setCannyLowThresh
getCannyLowThresh cv::GeneralizedHough::getCannyLowThresh
setCannyHighThresh cv::GeneralizedHough::setCannyHighThresh
getCannyHighThresh cv::GeneralizedHough::getCannyHighThresh
setMinDist cv::GeneralizedHough::setMinDist
getMinDist cv::GeneralizedHough::getMinDist
setDp cv::GeneralizedHough::setDp
getDp cv::GeneralizedHough::getDp
setMaxBufferSize cv::GeneralizedHough::setMaxBufferSize
getMaxBufferSize cv::GeneralizedHough::getMaxBufferSize
n cv.GeneralizedHoughBallard
['cv::GeneralizedHough']
cv::GeneralizedHough
cv.GeneralizedHoughBallard
cv GeneralizedHoughBallard
setLevels cv::GeneralizedHoughBallard::setLevels
getLevels cv::GeneralizedHoughBallard::getLevels
setVotesThreshold cv::GeneralizedHoughBallard::setVotesThreshold
getVotesThreshold cv::GeneralizedHoughBallard::getVotesThreshold
n cv.GeneralizedHoughGuil
['cv::GeneralizedHough']
cv::GeneralizedHough
cv.GeneralizedHoughGuil
cv GeneralizedHoughGuil
setXi cv::GeneralizedHoughGuil::setXi
getXi cv::GeneralizedHoughGuil::getXi
setLevels cv::GeneralizedHoughGuil::setLevels
getLevels cv::GeneralizedHoughGuil::getLevels
setAngleEpsilon cv::GeneralizedHoughGuil::setAngleEpsilon
getAngleEpsilon cv::GeneralizedHoughGuil::getAngleEpsilon
setMinAngle cv::GeneralizedHoughGuil::setMinAngle
getMinAngle cv::GeneralizedHoughGuil::getMinAngle
setMaxAngle cv::GeneralizedHoughGuil::setMaxAngle
getMaxAngle cv::GeneralizedHoughGuil::getMaxAngle
setAngleStep cv::GeneralizedHoughGuil::setAngleStep
getAngleStep cv::GeneralizedHoughGuil::getAngleStep
setAngleThresh cv::GeneralizedHoughGuil::setAngleThresh
getAngleThresh cv::GeneralizedHoughGuil::getAngleThresh
setMinScale cv::GeneralizedHoughGuil::setMinScale
getMinScale cv::GeneralizedHoughGuil::getMinScale
setMaxScale cv::GeneralizedHoughGuil::setMaxScale
getMaxScale cv::GeneralizedHoughGuil::getMaxScale
setScaleStep cv::GeneralizedHoughGuil::setScaleStep
getScaleStep cv::GeneralizedHoughGuil::getScaleStep
setScaleThresh cv::GeneralizedHoughGuil::setScaleThresh
getScaleThresh cv::GeneralizedHoughGuil::getScaleThresh
setPosThresh cv::GeneralizedHoughGuil::setPosThresh
getPosThresh cv::GeneralizedHoughGuil::getPosThresh
n cv.CLAHE
['cv::Algorithm']
cv::Algorithm
cv.CLAHE
cv CLAHE
apply cv::CLAHE::apply
apply cv::CLAHE::apply
setClipLimit cv::CLAHE::setClipLimit
getClipLimit cv::CLAHE::getClipLimit
setTilesGridSize cv::CLAHE::setTilesGridSize
getTilesGridSize cv::CLAHE::getTilesGridSize
collectGarbage cv::CLAHE::collectGarbage
n cv.Subdiv2D
cv.Subdiv2D
cv Subdiv2D
Subdiv2D cv::Subdiv2D::Subdiv2D
[]
Subdiv2D cv::Subdiv2D::Subdiv2D
[]
initDelaunay cv::Subdiv2D::initDelaunay
insert cv::Subdiv2D::insert
insert cv::Subdiv2D::insert
locate cv::Subdiv2D::locate
findNearest cv::Subdiv2D::findNearest
getEdgeList cv::Subdiv2D::getEdgeList
getLeadingEdgeList cv::Subdiv2D::getLeadingEdgeList
getTriangleList cv::Subdiv2D::getTriangleList
getVoronoiFacetList cv::Subdiv2D::getVoronoiFacetList
getVertex cv::Subdiv2D::getVertex
getEdge cv::Subdiv2D::getEdge
nextEdge cv::Subdiv2D::nextEdge
rotateEdge cv::Subdiv2D::rotateEdge
symEdge cv::Subdiv2D::symEdge
edgeOrg cv::Subdiv2D::edgeOrg
edgeDst cv::Subdiv2D::edgeDst
n cv.LineSegmentDetector
['cv::Algorithm']
cv::Algorithm
cv.LineSegmentDetector
cv LineSegmentDetector
detect cv::LineSegmentDetector::detect
detect cv::LineSegmentDetector::detect
drawSegments cv::LineSegmentDetector::drawSegments
drawSegments cv::LineSegmentDetector::drawSegments
compareSegments cv::LineSegmentDetector::compareSegments
compareSegments cv::LineSegmentDetector::compareSegments
createLineSegmentDetector cv::createLineSegmentDetector
getGaussianKernel cv::getGaussianKernel
getDerivKernels cv::getDerivKernels
getDerivKernels cv::getDerivKernels
getGaborKernel cv::getGaborKernel
getStructuringElement cv::getStructuringElement
medianBlur cv::medianBlur
medianBlur cv::medianBlur
GaussianBlur cv::GaussianBlur
GaussianBlur cv::GaussianBlur
bilateralFilter cv::bilateralFilter
bilateralFilter cv::bilateralFilter
boxFilter cv::boxFilter
boxFilter cv::boxFilter
sqrBoxFilter cv::sqrBoxFilter
sqrBoxFilter cv::sqrBoxFilter
blur cv::blur
blur cv::blur
filter2D cv::filter2D
filter2D cv::filter2D
sepFilter2D cv::sepFilter2D
sepFilter2D cv::sepFilter2D
Sobel cv::Sobel
Sobel cv::Sobel
spatialGradient cv::spatialGradient
spatialGradient cv::spatialGradient
Scharr cv::Scharr
Scharr cv::Scharr
Laplacian cv::Laplacian
Laplacian cv::Laplacian
Canny cv::Canny
Canny cv::Canny
Canny cv::Canny
Canny cv::Canny
cornerMinEigenVal cv::cornerMinEigenVal
cornerMinEigenVal cv::cornerMinEigenVal
cornerHarris cv::cornerHarris
cornerHarris cv::cornerHarris
cornerEigenValsAndVecs cv::cornerEigenValsAndVecs
cornerEigenValsAndVecs cv::cornerEigenValsAndVecs
preCornerDetect cv::preCornerDetect
preCornerDetect cv::preCornerDetect
cornerSubPix cv::cornerSubPix
cornerSubPix cv::cornerSubPix
goodFeaturesToTrack cv::goodFeaturesToTrack
goodFeaturesToTrack cv::goodFeaturesToTrack
goodFeaturesToTrack cv::goodFeaturesToTrack
goodFeaturesToTrack cv::goodFeaturesToTrack
HoughLines cv::HoughLines
HoughLines cv::HoughLines
HoughLinesP cv::HoughLinesP
HoughLinesP cv::HoughLinesP
HoughLinesPointSet cv::HoughLinesPointSet
HoughLinesPointSet cv::HoughLinesPointSet
HoughCircles cv::HoughCircles
HoughCircles cv::HoughCircles
erode cv::erode
erode cv::erode
dilate cv::dilate
dilate cv::dilate
morphologyEx cv::morphologyEx
morphologyEx cv::morphologyEx
resize cv::resize
resize cv::resize
warpAffine cv::warpAffine
warpAffine cv::warpAffine
warpPerspective cv::warpPerspective
warpPerspective cv::warpPerspective
remap cv::remap
remap cv::remap
convertMaps cv::convertMaps
convertMaps cv::convertMaps
getRotationMatrix2D cv::getRotationMatrix2D
invertAffineTransform cv::invertAffineTransform
invertAffineTransform cv::invertAffineTransform
getPerspectiveTransform cv::getPerspectiveTransform
getPerspectiveTransform cv::getPerspectiveTransform
getAffineTransform cv::getAffineTransform
getAffineTransform cv::getAffineTransform
getRectSubPix cv::getRectSubPix
getRectSubPix cv::getRectSubPix
logPolar cv::logPolar
logPolar cv::logPolar
linearPolar cv::linearPolar
linearPolar cv::linearPolar
warpPolar cv::warpPolar
warpPolar cv::warpPolar
integral cv::integral
integral cv::integral
integral2 cv::integral
integral2 cv::integral
integral3 cv::integral
integral3 cv::integral
accumulate cv::accumulate
accumulate cv::accumulate
accumulateSquare cv::accumulateSquare
accumulateSquare cv::accumulateSquare
accumulateProduct cv::accumulateProduct
accumulateProduct cv::accumulateProduct
accumulateWeighted cv::accumulateWeighted
accumulateWeighted cv::accumulateWeighted
phaseCorrelate cv::phaseCorrelate
phaseCorrelate cv::phaseCorrelate
createHanningWindow cv::createHanningWindow
createHanningWindow cv::createHanningWindow
threshold cv::threshold
threshold cv::threshold
adaptiveThreshold cv::adaptiveThreshold
adaptiveThreshold cv::adaptiveThreshold
pyrDown cv::pyrDown
pyrDown cv::pyrDown
pyrUp cv::pyrUp
pyrUp cv::pyrUp
calcHist cv::calcHist
calcHist cv::calcHist
calcBackProject cv::calcBackProject
calcBackProject cv::calcBackProject
compareHist cv::compareHist
compareHist cv::compareHist
equalizeHist cv::equalizeHist
equalizeHist cv::equalizeHist
createCLAHE cv::createCLAHE
EMD cv::wrapperEMD
EMD cv::wrapperEMD
watershed cv::watershed
watershed cv::watershed
pyrMeanShiftFiltering cv::pyrMeanShiftFiltering
pyrMeanShiftFiltering cv::pyrMeanShiftFiltering
grabCut cv::grabCut
grabCut cv::grabCut
distanceTransformWithLabels cv::distanceTransform
distanceTransformWithLabels cv::distanceTransform
distanceTransform cv::distanceTransform
distanceTransform cv::distanceTransform
floodFill cv::floodFill
floodFill cv::floodFill
cvtColor cv::cvtColor
cvtColor cv::cvtColor
cvtColorTwoPlane cv::cvtColorTwoPlane
cvtColorTwoPlane cv::cvtColorTwoPlane
demosaicing cv::demosaicing
demosaicing cv::demosaicing
moments cv::moments
moments cv::moments
HuMoments cv::HuMoments
HuMoments cv::HuMoments
matchTemplate cv::matchTemplate
matchTemplate cv::matchTemplate
connectedComponentsWithAlgorithm cv::connectedComponents
connectedComponentsWithAlgorithm cv::connectedComponents
connectedComponents cv::connectedComponents
connectedComponents cv::connectedComponents
connectedComponentsWithStatsWithAlgorithm cv::connectedComponentsWithStats
connectedComponentsWithStatsWithAlgorithm cv::connectedComponentsWithStats
connectedComponentsWithStats cv::connectedComponentsWithStats
connectedComponentsWithStats cv::connectedComponentsWithStats
findContours cv::findContours
findContours cv::findContours
approxPolyDP cv::approxPolyDP
approxPolyDP cv::approxPolyDP
arcLength cv::arcLength
arcLength cv::arcLength
boundingRect cv::boundingRect
boundingRect cv::boundingRect
contourArea cv::contourArea
contourArea cv::contourArea
minAreaRect cv::minAreaRect
minAreaRect cv::minAreaRect
boxPoints cv::boxPoints
boxPoints cv::boxPoints
minEnclosingCircle cv::minEnclosingCircle
minEnclosingCircle cv::minEnclosingCircle
minEnclosingTriangle cv::minEnclosingTriangle
minEnclosingTriangle cv::minEnclosingTriangle
matchShapes cv::matchShapes
matchShapes cv::matchShapes
convexHull cv::convexHull
convexHull cv::convexHull
convexityDefects cv::convexityDefects
convexityDefects cv::convexityDefects
isContourConvex cv::isContourConvex
isContourConvex cv::isContourConvex
intersectConvexConvex cv::intersectConvexConvex
intersectConvexConvex cv::intersectConvexConvex
fitEllipse cv::fitEllipse
fitEllipse cv::fitEllipse
fitEllipseAMS cv::fitEllipseAMS
fitEllipseAMS cv::fitEllipseAMS
fitEllipseDirect cv::fitEllipseDirect
fitEllipseDirect cv::fitEllipseDirect
fitLine cv::fitLine
fitLine cv::fitLine
pointPolygonTest cv::pointPolygonTest
pointPolygonTest cv::pointPolygonTest
rotatedRectangleIntersection cv::rotatedRectangleIntersection
rotatedRectangleIntersection cv::rotatedRectangleIntersection
createGeneralizedHoughBallard cv::createGeneralizedHoughBallard
createGeneralizedHoughGuil cv::createGeneralizedHoughGuil
applyColorMap cv::applyColorMap
applyColorMap cv::applyColorMap
applyColorMap cv::applyColorMap
applyColorMap cv::applyColorMap
line cv::line
line cv::line
arrowedLine cv::arrowedLine
arrowedLine cv::arrowedLine
rectangle cv::rectangle
rectangle cv::rectangle
rectangle cv::rectangle
rectangle cv::rectangle
circle cv::circle
circle cv::circle
ellipse cv::ellipse
ellipse cv::ellipse
ellipse cv::ellipse
ellipse cv::ellipse
drawMarker cv::drawMarker
drawMarker cv::drawMarker
fillConvexPoly cv::fillConvexPoly
fillConvexPoly cv::fillConvexPoly
fillPoly cv::fillPoly
fillPoly cv::fillPoly
polylines cv::polylines
polylines cv::polylines
drawContours cv::drawContours
drawContours cv::drawContours
clipLine cv::clipLine
ellipse2Poly cv::ellipse2Poly
putText cv::putText
putText cv::putText
getTextSize cv::getTextSize
getFontScaleFromHeight cv::getFontScaleFromHeight
Rodrigues cv::Rodrigues
Rodrigues cv::Rodrigues
findHomography cv::findHomography
findHomography cv::findHomography
RQDecomp3x3 cv::RQDecomp3x3
RQDecomp3x3 cv::RQDecomp3x3
decomposeProjectionMatrix cv::decomposeProjectionMatrix
decomposeProjectionMatrix cv::decomposeProjectionMatrix
matMulDeriv cv::matMulDeriv
matMulDeriv cv::matMulDeriv
composeRT cv::composeRT
composeRT cv::composeRT
projectPoints cv::projectPoints
projectPoints cv::projectPoints
solvePnP cv::solvePnP
solvePnP cv::solvePnP
solvePnPRansac cv::solvePnPRansac
solvePnPRansac cv::solvePnPRansac
solveP3P cv::solveP3P
solveP3P cv::solveP3P
solvePnPRefineLM cv::solvePnPRefineLM
solvePnPRefineLM cv::solvePnPRefineLM
solvePnPRefineVVS cv::solvePnPRefineVVS
solvePnPRefineVVS cv::solvePnPRefineVVS
solvePnPGeneric cv::solvePnPGeneric
solvePnPGeneric cv::solvePnPGeneric
initCameraMatrix2D cv::initCameraMatrix2D
initCameraMatrix2D cv::initCameraMatrix2D
findChessboardCorners cv::findChessboardCorners
findChessboardCorners cv::findChessboardCorners
checkChessboard cv::checkChessboard
checkChessboard cv::checkChessboard
findChessboardCornersSB cv::findChessboardCornersSB
findChessboardCornersSB cv::findChessboardCornersSB
find4QuadCornerSubpix cv::find4QuadCornerSubpix
find4QuadCornerSubpix cv::find4QuadCornerSubpix
drawChessboardCorners cv::drawChessboardCorners
drawChessboardCorners cv::drawChessboardCorners
drawFrameAxes cv::drawFrameAxes
drawFrameAxes cv::drawFrameAxes
n cv.CirclesGridFinderParameters
cv.CirclesGridFinderParameters
cv CirclesGridFinderParameters
CirclesGridFinderParameters cv::CirclesGridFinderParameters::CirclesGridFinderParameters
[]
findCirclesGrid cv::findCirclesGrid
findCirclesGrid cv::findCirclesGrid
findCirclesGrid cv::findCirclesGrid
findCirclesGrid cv::findCirclesGrid
calibrateCameraExtended cv::calibrateCamera
calibrateCameraExtended cv::calibrateCamera
calibrateCamera cv::calibrateCamera
calibrateCamera cv::calibrateCamera
calibrateCameraROExtended cv::calibrateCameraRO
calibrateCameraROExtended cv::calibrateCameraRO
calibrateCameraRO cv::calibrateCameraRO
calibrateCameraRO cv::calibrateCameraRO
calibrationMatrixValues cv::calibrationMatrixValues
calibrationMatrixValues cv::calibrationMatrixValues
stereoCalibrateExtended cv::stereoCalibrate
stereoCalibrateExtended cv::stereoCalibrate
stereoCalibrate cv::stereoCalibrate
stereoCalibrate cv::stereoCalibrate
stereoRectify cv::stereoRectify
stereoRectify cv::stereoRectify
stereoRectifyUncalibrated cv::stereoRectifyUncalibrated
stereoRectifyUncalibrated cv::stereoRectifyUncalibrated
rectify3Collinear cv::rectify3Collinear
rectify3Collinear cv::rectify3Collinear
getOptimalNewCameraMatrix cv::getOptimalNewCameraMatrix
getOptimalNewCameraMatrix cv::getOptimalNewCameraMatrix
calibrateHandEye cv::calibrateHandEye
calibrateHandEye cv::calibrateHandEye
convertPointsToHomogeneous cv::convertPointsToHomogeneous
convertPointsToHomogeneous cv::convertPointsToHomogeneous
convertPointsFromHomogeneous cv::convertPointsFromHomogeneous
convertPointsFromHomogeneous cv::convertPointsFromHomogeneous
findFundamentalMat cv::findFundamentalMat
findFundamentalMat cv::findFundamentalMat
findEssentialMat cv::findEssentialMat
findEssentialMat cv::findEssentialMat
findEssentialMat cv::findEssentialMat
findEssentialMat cv::findEssentialMat
decomposeEssentialMat cv::decomposeEssentialMat
decomposeEssentialMat cv::decomposeEssentialMat
recoverPose cv::recoverPose
recoverPose cv::recoverPose
recoverPose cv::recoverPose
recoverPose cv::recoverPose
recoverPose cv::recoverPose
recoverPose cv::recoverPose
computeCorrespondEpilines cv::computeCorrespondEpilines
computeCorrespondEpilines cv::computeCorrespondEpilines
triangulatePoints cv::triangulatePoints
triangulatePoints cv::triangulatePoints
correctMatches cv::correctMatches
correctMatches cv::correctMatches
filterSpeckles cv::filterSpeckles
filterSpeckles cv::filterSpeckles
getValidDisparityROI cv::getValidDisparityROI
validateDisparity cv::validateDisparity
validateDisparity cv::validateDisparity
reprojectImageTo3D cv::reprojectImageTo3D
reprojectImageTo3D cv::reprojectImageTo3D
sampsonDistance cv::sampsonDistance
sampsonDistance cv::sampsonDistance
estimateAffine3D cv::estimateAffine3D
estimateAffine3D cv::estimateAffine3D
estimateAffine2D cv::estimateAffine2D
estimateAffine2D cv::estimateAffine2D
estimateAffinePartial2D cv::estimateAffinePartial2D
estimateAffinePartial2D cv::estimateAffinePartial2D
decomposeHomographyMat cv::decomposeHomographyMat
decomposeHomographyMat cv::decomposeHomographyMat
filterHomographyDecompByVisibleRefpoints cv::filterHomographyDecompByVisibleRefpoints
filterHomographyDecompByVisibleRefpoints cv::filterHomographyDecompByVisibleRefpoints
n cv.StereoMatcher
['cv::Algorithm']
cv::Algorithm
cv.StereoMatcher
cv StereoMatcher
compute cv::StereoMatcher::compute
compute cv::StereoMatcher::compute
getMinDisparity cv::StereoMatcher::getMinDisparity
setMinDisparity cv::StereoMatcher::setMinDisparity
getNumDisparities cv::StereoMatcher::getNumDisparities
setNumDisparities cv::StereoMatcher::setNumDisparities
getBlockSize cv::StereoMatcher::getBlockSize
setBlockSize cv::StereoMatcher::setBlockSize
getSpeckleWindowSize cv::StereoMatcher::getSpeckleWindowSize
setSpeckleWindowSize cv::StereoMatcher::setSpeckleWindowSize
getSpeckleRange cv::StereoMatcher::getSpeckleRange
setSpeckleRange cv::StereoMatcher::setSpeckleRange
getDisp12MaxDiff cv::StereoMatcher::getDisp12MaxDiff
setDisp12MaxDiff cv::StereoMatcher::setDisp12MaxDiff
n cv.StereoBM
['cv::StereoMatcher']
cv::StereoMatcher
cv.StereoBM
cv StereoBM
getPreFilterType cv::StereoBM::getPreFilterType
setPreFilterType cv::StereoBM::setPreFilterType
getPreFilterSize cv::StereoBM::getPreFilterSize
setPreFilterSize cv::StereoBM::setPreFilterSize
getPreFilterCap cv::StereoBM::getPreFilterCap
setPreFilterCap cv::StereoBM::setPreFilterCap
getTextureThreshold cv::StereoBM::getTextureThreshold
setTextureThreshold cv::StereoBM::setTextureThreshold
getUniquenessRatio cv::StereoBM::getUniquenessRatio
setUniquenessRatio cv::StereoBM::setUniquenessRatio
getSmallerBlockSize cv::StereoBM::getSmallerBlockSize
setSmallerBlockSize cv::StereoBM::setSmallerBlockSize
getROI1 cv::StereoBM::getROI1
setROI1 cv::StereoBM::setROI1
getROI2 cv::StereoBM::getROI2
setROI2 cv::StereoBM::setROI2
create cv::StereoBM::create
StereoBM_create cv::StereoBM::create
n cv.StereoSGBM
['cv::StereoMatcher']
cv::StereoMatcher
cv.StereoSGBM
cv StereoSGBM
getPreFilterCap cv::StereoSGBM::getPreFilterCap
setPreFilterCap cv::StereoSGBM::setPreFilterCap
getUniquenessRatio cv::StereoSGBM::getUniquenessRatio
setUniquenessRatio cv::StereoSGBM::setUniquenessRatio
getP1 cv::StereoSGBM::getP1
setP1 cv::StereoSGBM::setP1
getP2 cv::StereoSGBM::getP2
setP2 cv::StereoSGBM::setP2
getMode cv::StereoSGBM::getMode
setMode cv::StereoSGBM::setMode
create cv::StereoSGBM::create
StereoSGBM_create cv::StereoSGBM::create
undistort cv::undistort
undistort cv::undistort
initUndistortRectifyMap cv::initUndistortRectifyMap
initUndistortRectifyMap cv::initUndistortRectifyMap
getDefaultNewCameraMatrix cv::getDefaultNewCameraMatrix
getDefaultNewCameraMatrix cv::getDefaultNewCameraMatrix
undistortPoints cv::undistortPoints
undistortPoints cv::undistortPoints
undistortPointsIter cv::undistortPoints
undistortPointsIter cv::undistortPoints
projectPoints cv::fisheye::projectPoints
projectPoints cv::fisheye::projectPoints
distortPoints cv::fisheye::distortPoints
distortPoints cv::fisheye::distortPoints
undistortPoints cv::fisheye::undistortPoints
undistortPoints cv::fisheye::undistortPoints
initUndistortRectifyMap cv::fisheye::initUndistortRectifyMap
initUndistortRectifyMap cv::fisheye::initUndistortRectifyMap
undistortImage cv::fisheye::undistortImage
undistortImage cv::fisheye::undistortImage
estimateNewCameraMatrixForUndistortRectify cv::fisheye::estimateNewCameraMatrixForUndistortRectify
estimateNewCameraMatrixForUndistortRectify cv::fisheye::estimateNewCameraMatrixForUndistortRectify
calibrate cv::fisheye::calibrate
calibrate cv::fisheye::calibrate
stereoRectify cv::fisheye::stereoRectify
stereoRectify cv::fisheye::stereoRectify
stereoCalibrate cv::fisheye::stereoCalibrate
stereoCalibrate cv::fisheye::stereoCalibrate
n cv.Feature2D
['cv::Algorithm', 'cv::class', 'cv::Feature2D', 'cv::Algorithm']
More than one base ['cv::Algorithm', 'cv::class', 'cv::Feature2D', 'cv::Algorithm']
['cv::Algorithm']
cv::Algorithm
cv.Feature2D
cv Feature2D
detect cv::Feature2D::detect
detect cv::Feature2D::detect
detect cv::Feature2D::detect
detect cv::Feature2D::detect
compute cv::Feature2D::compute
compute cv::Feature2D::compute
compute cv::Feature2D::compute
compute cv::Feature2D::compute
detectAndCompute cv::Feature2D::detectAndCompute
detectAndCompute cv::Feature2D::detectAndCompute
descriptorSize cv::Feature2D::descriptorSize
descriptorType cv::Feature2D::descriptorType
defaultNorm cv::Feature2D::defaultNorm
write cv::Feature2D::write
read cv::Feature2D::read
read cv::Feature2D::read
empty cv::Feature2D::empty
getDefaultName cv::Feature2D::getDefaultName
write cv::Feature2D::write
n cv.BRISK
['cv::Feature2D']
cv::Feature2D
cv.BRISK
cv BRISK
create cv::BRISK::create
BRISK_create cv::BRISK::create
create cv::BRISK::create
BRISK_create cv::BRISK::create
create cv::BRISK::create
BRISK_create cv::BRISK::create
getDefaultName cv::BRISK::getDefaultName
setThreshold cv::BRISK::setThreshold
getThreshold cv::BRISK::getThreshold
setOctaves cv::BRISK::setOctaves
getOctaves cv::BRISK::getOctaves
n cv.ORB
['cv::Feature2D']
cv::Feature2D
cv.ORB
cv ORB
create cv::ORB::create
ORB_create cv::ORB::create
setMaxFeatures cv::ORB::setMaxFeatures
getMaxFeatures cv::ORB::getMaxFeatures
setScaleFactor cv::ORB::setScaleFactor
getScaleFactor cv::ORB::getScaleFactor
setNLevels cv::ORB::setNLevels
getNLevels cv::ORB::getNLevels
setEdgeThreshold cv::ORB::setEdgeThreshold
getEdgeThreshold cv::ORB::getEdgeThreshold
setFirstLevel cv::ORB::setFirstLevel
getFirstLevel cv::ORB::getFirstLevel
setWTA_K cv::ORB::setWTA_K
getWTA_K cv::ORB::getWTA_K
setScoreType cv::ORB::setScoreType
getScoreType cv::ORB::getScoreType
setPatchSize cv::ORB::setPatchSize
getPatchSize cv::ORB::getPatchSize
setFastThreshold cv::ORB::setFastThreshold
getFastThreshold cv::ORB::getFastThreshold
getDefaultName cv::ORB::getDefaultName
n cv.MSER
['cv::Feature2D']
cv::Feature2D
cv.MSER
cv MSER
create cv::MSER::create
MSER_create cv::MSER::create
detectRegions cv::MSER::detectRegions
detectRegions cv::MSER::detectRegions
setDelta cv::MSER::setDelta
getDelta cv::MSER::getDelta
setMinArea cv::MSER::setMinArea
getMinArea cv::MSER::getMinArea
setMaxArea cv::MSER::setMaxArea
getMaxArea cv::MSER::getMaxArea
setPass2Only cv::MSER::setPass2Only
getPass2Only cv::MSER::getPass2Only
getDefaultName cv::MSER::getDefaultName
n cv.FastFeatureDetector
['cv::Feature2D']
cv::Feature2D
cv.FastFeatureDetector
cv FastFeatureDetector
create cv::FastFeatureDetector::create
FastFeatureDetector_create cv::FastFeatureDetector::create
setThreshold cv::FastFeatureDetector::setThreshold
getThreshold cv::FastFeatureDetector::getThreshold
setNonmaxSuppression cv::FastFeatureDetector::setNonmaxSuppression
getNonmaxSuppression cv::FastFeatureDetector::getNonmaxSuppression
setType cv::FastFeatureDetector::setType
getType cv::FastFeatureDetector::getType
getDefaultName cv::FastFeatureDetector::getDefaultName
n cv.AgastFeatureDetector
['cv::Feature2D']
cv::Feature2D
cv.AgastFeatureDetector
cv AgastFeatureDetector
create cv::AgastFeatureDetector::create
AgastFeatureDetector_create cv::AgastFeatureDetector::create
setThreshold cv::AgastFeatureDetector::setThreshold
getThreshold cv::AgastFeatureDetector::getThreshold
setNonmaxSuppression cv::AgastFeatureDetector::setNonmaxSuppression
getNonmaxSuppression cv::AgastFeatureDetector::getNonmaxSuppression
setType cv::AgastFeatureDetector::setType
getType cv::AgastFeatureDetector::getType
getDefaultName cv::AgastFeatureDetector::getDefaultName
n cv.GFTTDetector
['cv::Feature2D']
cv::Feature2D
cv.GFTTDetector
cv GFTTDetector
create cv::GFTTDetector::create
GFTTDetector_create cv::GFTTDetector::create
create cv::GFTTDetector::create
GFTTDetector_create cv::GFTTDetector::create
setMaxFeatures cv::GFTTDetector::setMaxFeatures
getMaxFeatures cv::GFTTDetector::getMaxFeatures
setQualityLevel cv::GFTTDetector::setQualityLevel
getQualityLevel cv::GFTTDetector::getQualityLevel
setMinDistance cv::GFTTDetector::setMinDistance
getMinDistance cv::GFTTDetector::getMinDistance
setBlockSize cv::GFTTDetector::setBlockSize
getBlockSize cv::GFTTDetector::getBlockSize
setHarrisDetector cv::GFTTDetector::setHarrisDetector
getHarrisDetector cv::GFTTDetector::getHarrisDetector
setK cv::GFTTDetector::setK
getK cv::GFTTDetector::getK
getDefaultName cv::GFTTDetector::getDefaultName
n cv.SimpleBlobDetector
['cv::Feature2D']
cv::Feature2D
cv.SimpleBlobDetector
cv SimpleBlobDetector
n cv.SimpleBlobDetector.Params
cv.SimpleBlobDetector.Params
cv SimpleBlobDetector_Params
HH1
cv SimpleBlobDetector.Params
SimpleBlobDetector.Params
SimpleBlobDetector_Params cv::SimpleBlobDetector::Params::Params
[]
create cv::SimpleBlobDetector::create
SimpleBlobDetector_create cv::SimpleBlobDetector::create
getDefaultName cv::SimpleBlobDetector::getDefaultName
n cv.KAZE
['cv::Feature2D']
cv::Feature2D
cv.KAZE
cv KAZE
create cv::KAZE::create
KAZE_create cv::KAZE::create
setExtended cv::KAZE::setExtended
getExtended cv::KAZE::getExtended
setUpright cv::KAZE::setUpright
getUpright cv::KAZE::getUpright
setThreshold cv::KAZE::setThreshold
getThreshold cv::KAZE::getThreshold
setNOctaves cv::KAZE::setNOctaves
getNOctaves cv::KAZE::getNOctaves
setNOctaveLayers cv::KAZE::setNOctaveLayers
getNOctaveLayers cv::KAZE::getNOctaveLayers
setDiffusivity cv::KAZE::setDiffusivity
getDiffusivity cv::KAZE::getDiffusivity
getDefaultName cv::KAZE::getDefaultName
n cv.AKAZE
['cv::Feature2D']
cv::Feature2D
cv.AKAZE
cv AKAZE
create cv::AKAZE::create
AKAZE_create cv::AKAZE::create
setDescriptorType cv::AKAZE::setDescriptorType
getDescriptorType cv::AKAZE::getDescriptorType
setDescriptorSize cv::AKAZE::setDescriptorSize
getDescriptorSize cv::AKAZE::getDescriptorSize
setDescriptorChannels cv::AKAZE::setDescriptorChannels
getDescriptorChannels cv::AKAZE::getDescriptorChannels
setThreshold cv::AKAZE::setThreshold
getThreshold cv::AKAZE::getThreshold
setNOctaves cv::AKAZE::setNOctaves
getNOctaves cv::AKAZE::getNOctaves
setNOctaveLayers cv::AKAZE::setNOctaveLayers
getNOctaveLayers cv::AKAZE::getNOctaveLayers
setDiffusivity cv::AKAZE::setDiffusivity
getDiffusivity cv::AKAZE::getDiffusivity
getDefaultName cv::AKAZE::getDefaultName
n cv.DescriptorMatcher
['cv::Algorithm']
cv::Algorithm
cv.DescriptorMatcher
cv DescriptorMatcher
add cv::DescriptorMatcher::add
add cv::DescriptorMatcher::add
getTrainDescriptors cv::DescriptorMatcher::getTrainDescriptors
clear cv::DescriptorMatcher::clear
empty cv::DescriptorMatcher::empty
isMaskSupported cv::DescriptorMatcher::isMaskSupported
train cv::DescriptorMatcher::train
match cv::DescriptorMatcher::match
match cv::DescriptorMatcher::match
knnMatch cv::DescriptorMatcher::knnMatch
knnMatch cv::DescriptorMatcher::knnMatch
radiusMatch cv::DescriptorMatcher::radiusMatch
radiusMatch cv::DescriptorMatcher::radiusMatch
match cv::DescriptorMatcher::match
match cv::DescriptorMatcher::match
knnMatch cv::DescriptorMatcher::knnMatch
knnMatch cv::DescriptorMatcher::knnMatch
radiusMatch cv::DescriptorMatcher::radiusMatch
radiusMatch cv::DescriptorMatcher::radiusMatch
write cv::DescriptorMatcher::write
read cv::DescriptorMatcher::read
read cv::DescriptorMatcher::read
clone cv::DescriptorMatcher::clone
create cv::DescriptorMatcher::create
DescriptorMatcher_create cv::DescriptorMatcher::create
create cv::DescriptorMatcher::create
DescriptorMatcher_create cv::DescriptorMatcher::create
write cv::DescriptorMatcher::write
n cv.BFMatcher
['cv::DescriptorMatcher']
cv::DescriptorMatcher
cv.BFMatcher
cv BFMatcher
BFMatcher cv::BFMatcher::BFMatcher
[]
create cv::BFMatcher::create
BFMatcher_create cv::BFMatcher::create
n cv.FlannBasedMatcher
['cv::DescriptorMatcher']
cv::DescriptorMatcher
cv.FlannBasedMatcher
cv FlannBasedMatcher
FlannBasedMatcher cv::FlannBasedMatcher::FlannBasedMatcher
[]
create cv::FlannBasedMatcher::create
FlannBasedMatcher_create cv::FlannBasedMatcher::create
drawKeypoints cv::drawKeypoints
drawKeypoints cv::drawKeypoints
drawMatches cv::drawMatches
drawMatches cv::drawMatches
drawMatchesKnn cv::drawMatches
drawMatchesKnn cv::drawMatches
n cv.BOWTrainer
cv.BOWTrainer
cv BOWTrainer
add cv::BOWTrainer::add
add cv::BOWTrainer::add
getDescriptors cv::BOWTrainer::getDescriptors
descriptorsCount cv::BOWTrainer::descriptorsCount
clear cv::BOWTrainer::clear
cluster cv::BOWTrainer::cluster
cluster cv::BOWTrainer::cluster
cluster cv::BOWTrainer::cluster
n cv.BOWKMeansTrainer
['cv::BOWTrainer']
cv::BOWTrainer
cv.BOWKMeansTrainer
cv BOWKMeansTrainer
BOWKMeansTrainer cv::BOWKMeansTrainer::BOWKMeansTrainer
[]
cluster cv::BOWKMeansTrainer::cluster
cluster cv::BOWKMeansTrainer::cluster
cluster cv::BOWKMeansTrainer::cluster
n cv.BOWImgDescriptorExtractor
cv.BOWImgDescriptorExtractor
cv BOWImgDescriptorExtractor
BOWImgDescriptorExtractor cv::BOWImgDescriptorExtractor::BOWImgDescriptorExtractor
[]
setVocabulary cv::BOWImgDescriptorExtractor::setVocabulary
setVocabulary cv::BOWImgDescriptorExtractor::setVocabulary
getVocabulary cv::BOWImgDescriptorExtractor::getVocabulary
compute cv::BOWImgDescriptorExtractor::compute2
compute cv::BOWImgDescriptorExtractor::compute2
descriptorSize cv::BOWImgDescriptorExtractor::descriptorSize
descriptorType cv::BOWImgDescriptorExtractor::descriptorType
CamShift cv::CamShift
CamShift cv::CamShift
meanShift cv::meanShift
meanShift cv::meanShift
buildOpticalFlowPyramid cv::buildOpticalFlowPyramid
buildOpticalFlowPyramid cv::buildOpticalFlowPyramid
calcOpticalFlowPyrLK cv::calcOpticalFlowPyrLK
calcOpticalFlowPyrLK cv::calcOpticalFlowPyrLK
calcOpticalFlowFarneback cv::calcOpticalFlowFarneback
calcOpticalFlowFarneback cv::calcOpticalFlowFarneback
computeECC cv::computeECC
computeECC cv::computeECC
findTransformECC cv::findTransformECC
findTransformECC cv::findTransformECC
n cv.KalmanFilter
cv.KalmanFilter
cv KalmanFilter
KalmanFilter cv::KalmanFilter::KalmanFilter
[]
KalmanFilter cv::KalmanFilter::KalmanFilter
[]
predict cv::KalmanFilter::predict
predict cv::KalmanFilter::predict
correct cv::KalmanFilter::correct
correct cv::KalmanFilter::correct
readOpticalFlow cv::readOpticalFlow
writeOpticalFlow cv::writeOpticalFlow
writeOpticalFlow cv::writeOpticalFlow
n cv.DenseOpticalFlow
['cv::Algorithm']
cv::Algorithm
cv.DenseOpticalFlow
cv DenseOpticalFlow
calc cv::DenseOpticalFlow::calc
calc cv::DenseOpticalFlow::calc
collectGarbage cv::DenseOpticalFlow::collectGarbage
n cv.SparseOpticalFlow
['cv::Algorithm']
cv::Algorithm
cv.SparseOpticalFlow
cv SparseOpticalFlow
calc cv::SparseOpticalFlow::calc
calc cv::SparseOpticalFlow::calc
n cv.FarnebackOpticalFlow
['cv::DenseOpticalFlow']
cv::DenseOpticalFlow
cv.FarnebackOpticalFlow
cv FarnebackOpticalFlow
getNumLevels cv::FarnebackOpticalFlow::getNumLevels
setNumLevels cv::FarnebackOpticalFlow::setNumLevels
getPyrScale cv::FarnebackOpticalFlow::getPyrScale
setPyrScale cv::FarnebackOpticalFlow::setPyrScale
getFastPyramids cv::FarnebackOpticalFlow::getFastPyramids
setFastPyramids cv::FarnebackOpticalFlow::setFastPyramids
getWinSize cv::FarnebackOpticalFlow::getWinSize
setWinSize cv::FarnebackOpticalFlow::setWinSize
getNumIters cv::FarnebackOpticalFlow::getNumIters
setNumIters cv::FarnebackOpticalFlow::setNumIters
getPolyN cv::FarnebackOpticalFlow::getPolyN
setPolyN cv::FarnebackOpticalFlow::setPolyN
getPolySigma cv::FarnebackOpticalFlow::getPolySigma
setPolySigma cv::FarnebackOpticalFlow::setPolySigma
getFlags cv::FarnebackOpticalFlow::getFlags
setFlags cv::FarnebackOpticalFlow::setFlags
create cv::FarnebackOpticalFlow::create
FarnebackOpticalFlow_create cv::FarnebackOpticalFlow::create
n cv.VariationalRefinement
['cv::DenseOpticalFlow']
cv::DenseOpticalFlow
cv.VariationalRefinement
cv VariationalRefinement
calcUV cv::VariationalRefinement::calcUV
calcUV cv::VariationalRefinement::calcUV
getFixedPointIterations cv::VariationalRefinement::getFixedPointIterations
setFixedPointIterations cv::VariationalRefinement::setFixedPointIterations
getSorIterations cv::VariationalRefinement::getSorIterations
setSorIterations cv::VariationalRefinement::setSorIterations
getOmega cv::VariationalRefinement::getOmega
setOmega cv::VariationalRefinement::setOmega
getAlpha cv::VariationalRefinement::getAlpha
setAlpha cv::VariationalRefinement::setAlpha
getDelta cv::VariationalRefinement::getDelta
setDelta cv::VariationalRefinement::setDelta
getGamma cv::VariationalRefinement::getGamma
setGamma cv::VariationalRefinement::setGamma
create cv::VariationalRefinement::create
VariationalRefinement_create cv::VariationalRefinement::create
n cv.DISOpticalFlow
['cv::DenseOpticalFlow']
cv::DenseOpticalFlow
cv.DISOpticalFlow
cv DISOpticalFlow
getFinestScale cv::DISOpticalFlow::getFinestScale
setFinestScale cv::DISOpticalFlow::setFinestScale
getPatchSize cv::DISOpticalFlow::getPatchSize
setPatchSize cv::DISOpticalFlow::setPatchSize
getPatchStride cv::DISOpticalFlow::getPatchStride
setPatchStride cv::DISOpticalFlow::setPatchStride
getGradientDescentIterations cv::DISOpticalFlow::getGradientDescentIterations
setGradientDescentIterations cv::DISOpticalFlow::setGradientDescentIterations
getVariationalRefinementIterations cv::DISOpticalFlow::getVariationalRefinementIterations
setVariationalRefinementIterations cv::DISOpticalFlow::setVariationalRefinementIterations
getVariationalRefinementAlpha cv::DISOpticalFlow::getVariationalRefinementAlpha
setVariationalRefinementAlpha cv::DISOpticalFlow::setVariationalRefinementAlpha
getVariationalRefinementDelta cv::DISOpticalFlow::getVariationalRefinementDelta
setVariationalRefinementDelta cv::DISOpticalFlow::setVariationalRefinementDelta
getVariationalRefinementGamma cv::DISOpticalFlow::getVariationalRefinementGamma
setVariationalRefinementGamma cv::DISOpticalFlow::setVariationalRefinementGamma
getUseMeanNormalization cv::DISOpticalFlow::getUseMeanNormalization
setUseMeanNormalization cv::DISOpticalFlow::setUseMeanNormalization
getUseSpatialPropagation cv::DISOpticalFlow::getUseSpatialPropagation
setUseSpatialPropagation cv::DISOpticalFlow::setUseSpatialPropagation
create cv::DISOpticalFlow::create
DISOpticalFlow_create cv::DISOpticalFlow::create
n cv.SparsePyrLKOpticalFlow
['cv::SparseOpticalFlow']
cv::SparseOpticalFlow
cv.SparsePyrLKOpticalFlow
cv SparsePyrLKOpticalFlow
getWinSize cv::SparsePyrLKOpticalFlow::getWinSize
setWinSize cv::SparsePyrLKOpticalFlow::setWinSize
getMaxLevel cv::SparsePyrLKOpticalFlow::getMaxLevel
setMaxLevel cv::SparsePyrLKOpticalFlow::setMaxLevel
getTermCriteria cv::SparsePyrLKOpticalFlow::getTermCriteria
setTermCriteria cv::SparsePyrLKOpticalFlow::setTermCriteria
getFlags cv::SparsePyrLKOpticalFlow::getFlags
setFlags cv::SparsePyrLKOpticalFlow::setFlags
getMinEigThreshold cv::SparsePyrLKOpticalFlow::getMinEigThreshold
setMinEigThreshold cv::SparsePyrLKOpticalFlow::setMinEigThreshold
create cv::SparsePyrLKOpticalFlow::create
SparsePyrLKOpticalFlow_create cv::SparsePyrLKOpticalFlow::create
n cv.BackgroundSubtractor
['cv::Algorithm']
cv::Algorithm
cv.BackgroundSubtractor
cv BackgroundSubtractor
apply cv::BackgroundSubtractor::apply
apply cv::BackgroundSubtractor::apply
getBackgroundImage cv::BackgroundSubtractor::getBackgroundImage
getBackgroundImage cv::BackgroundSubtractor::getBackgroundImage
n cv.BackgroundSubtractorMOG2
['cv::BackgroundSubtractor']
cv::BackgroundSubtractor
cv.BackgroundSubtractorMOG2
cv BackgroundSubtractorMOG2
getHistory cv::BackgroundSubtractorMOG2::getHistory
setHistory cv::BackgroundSubtractorMOG2::setHistory
getNMixtures cv::BackgroundSubtractorMOG2::getNMixtures
setNMixtures cv::BackgroundSubtractorMOG2::setNMixtures
getBackgroundRatio cv::BackgroundSubtractorMOG2::getBackgroundRatio
setBackgroundRatio cv::BackgroundSubtractorMOG2::setBackgroundRatio
getVarThreshold cv::BackgroundSubtractorMOG2::getVarThreshold
setVarThreshold cv::BackgroundSubtractorMOG2::setVarThreshold
getVarThresholdGen cv::BackgroundSubtractorMOG2::getVarThresholdGen
setVarThresholdGen cv::BackgroundSubtractorMOG2::setVarThresholdGen
getVarInit cv::BackgroundSubtractorMOG2::getVarInit
setVarInit cv::BackgroundSubtractorMOG2::setVarInit
getVarMin cv::BackgroundSubtractorMOG2::getVarMin
setVarMin cv::BackgroundSubtractorMOG2::setVarMin
getVarMax cv::BackgroundSubtractorMOG2::getVarMax
setVarMax cv::BackgroundSubtractorMOG2::setVarMax
getComplexityReductionThreshold cv::BackgroundSubtractorMOG2::getComplexityReductionThreshold
setComplexityReductionThreshold cv::BackgroundSubtractorMOG2::setComplexityReductionThreshold
getDetectShadows cv::BackgroundSubtractorMOG2::getDetectShadows
setDetectShadows cv::BackgroundSubtractorMOG2::setDetectShadows
getShadowValue cv::BackgroundSubtractorMOG2::getShadowValue
setShadowValue cv::BackgroundSubtractorMOG2::setShadowValue
getShadowThreshold cv::BackgroundSubtractorMOG2::getShadowThreshold
setShadowThreshold cv::BackgroundSubtractorMOG2::setShadowThreshold
apply cv::BackgroundSubtractorMOG2::apply
apply cv::BackgroundSubtractorMOG2::apply
createBackgroundSubtractorMOG2 cv::createBackgroundSubtractorMOG2
n cv.BackgroundSubtractorKNN
['cv::BackgroundSubtractor']
cv::BackgroundSubtractor
cv.BackgroundSubtractorKNN
cv BackgroundSubtractorKNN
getHistory cv::BackgroundSubtractorKNN::getHistory
setHistory cv::BackgroundSubtractorKNN::setHistory
getNSamples cv::BackgroundSubtractorKNN::getNSamples
setNSamples cv::BackgroundSubtractorKNN::setNSamples
getDist2Threshold cv::BackgroundSubtractorKNN::getDist2Threshold
setDist2Threshold cv::BackgroundSubtractorKNN::setDist2Threshold
getkNNSamples cv::BackgroundSubtractorKNN::getkNNSamples
setkNNSamples cv::BackgroundSubtractorKNN::setkNNSamples
getDetectShadows cv::BackgroundSubtractorKNN::getDetectShadows
setDetectShadows cv::BackgroundSubtractorKNN::setDetectShadows
getShadowValue cv::BackgroundSubtractorKNN::getShadowValue
setShadowValue cv::BackgroundSubtractorKNN::setShadowValue
getShadowThreshold cv::BackgroundSubtractorKNN::getShadowThreshold
setShadowThreshold cv::BackgroundSubtractorKNN::setShadowThreshold
createBackgroundSubtractorKNN cv::createBackgroundSubtractorKNN
groupRectangles cv::groupRectangles
n cv.BaseCascadeClassifier
['cv::Algorithm']
cv::Algorithm
cv.BaseCascadeClassifier
cv BaseCascadeClassifier
n cv.CascadeClassifier
cv.CascadeClassifier
cv CascadeClassifier
CascadeClassifier cv::CascadeClassifier::CascadeClassifier
[]
CascadeClassifier cv::CascadeClassifier::CascadeClassifier
[]
empty cv::CascadeClassifier::empty
load cv::CascadeClassifier::load
read cv::CascadeClassifier::read
detectMultiScale cv::CascadeClassifier::detectMultiScale
detectMultiScale cv::CascadeClassifier::detectMultiScale
detectMultiScale2 cv::CascadeClassifier::detectMultiScale
detectMultiScale2 cv::CascadeClassifier::detectMultiScale
detectMultiScale3 cv::CascadeClassifier::detectMultiScale
detectMultiScale3 cv::CascadeClassifier::detectMultiScale
isOldFormatCascade cv::CascadeClassifier::isOldFormatCascade
getOriginalWindowSize cv::CascadeClassifier::getOriginalWindowSize
getFeatureType cv::CascadeClassifier::getFeatureType
convert cv::CascadeClassifier::convert
CascadeClassifier_convert cv::CascadeClassifier::convert
n cv.HOGDescriptor
cv.HOGDescriptor
cv HOGDescriptor
HOGDescriptor cv::HOGDescriptor::HOGDescriptor
[]
HOGDescriptor cv::HOGDescriptor::HOGDescriptor
[]
HOGDescriptor cv::HOGDescriptor::HOGDescriptor
[]
getDescriptorSize cv::HOGDescriptor::getDescriptorSize
checkDetectorSize cv::HOGDescriptor::checkDetectorSize
getWinSigma cv::HOGDescriptor::getWinSigma
setSVMDetector cv::HOGDescriptor::setSVMDetector
setSVMDetector cv::HOGDescriptor::setSVMDetector
load cv::HOGDescriptor::load
save cv::HOGDescriptor::save
compute cv::HOGDescriptor::compute
compute cv::HOGDescriptor::compute
detect cv::HOGDescriptor::detect
detect cv::HOGDescriptor::detect
detectMultiScale cv::HOGDescriptor::detectMultiScale
detectMultiScale cv::HOGDescriptor::detectMultiScale
computeGradient cv::HOGDescriptor::computeGradient
computeGradient cv::HOGDescriptor::computeGradient
getDefaultPeopleDetector cv::HOGDescriptor::getDefaultPeopleDetector
HOGDescriptor_getDefaultPeopleDetector cv::HOGDescriptor::getDefaultPeopleDetector
getDaimlerPeopleDetector cv::HOGDescriptor::getDaimlerPeopleDetector
HOGDescriptor_getDaimlerPeopleDetector cv::HOGDescriptor::getDaimlerPeopleDetector
n cv.QRCodeDetector
cv.QRCodeDetector
cv QRCodeDetector
QRCodeDetector cv::QRCodeDetector::QRCodeDetector
[]
setEpsX cv::QRCodeDetector::setEpsX
setEpsY cv::QRCodeDetector::setEpsY
detect cv::QRCodeDetector::detect
detect cv::QRCodeDetector::detect
decode cv::QRCodeDetector::decode
decode cv::QRCodeDetector::decode
detectAndDecode cv::QRCodeDetector::detectAndDecode
detectAndDecode cv::QRCodeDetector::detectAndDecode
detectMulti cv::QRCodeDetector::detectMulti
detectMulti cv::QRCodeDetector::detectMulti
decodeMulti cv::QRCodeDetector::decodeMulti
decodeMulti cv::QRCodeDetector::decodeMulti
detectAndDecodeMulti cv::QRCodeDetector::detectAndDecodeMulti
detectAndDecodeMulti cv::QRCodeDetector::detectAndDecodeMulti
imread cv::imread
imreadmulti cv::imreadmulti
imreadmulti cv::imreadmulti
imwrite cv::imwrite
imwrite cv::imwrite
imdecode cv::imdecode
imdecode cv::imdecode
imencode cv::imencode
imencode cv::imencode
haveImageReader cv::haveImageReader
haveImageWriter cv::haveImageWriter
n cv.VideoCapture
cv.VideoCapture
cv VideoCapture
VideoCapture cv::VideoCapture::VideoCapture
[]
VideoCapture cv::VideoCapture::VideoCapture
[('retval', 'explicit', 'explicit')]
VideoCapture cv::VideoCapture::VideoCapture
[('retval', 'explicit', 'explicit')]
open cv::VideoCapture::open
open cv::VideoCapture::open
isOpened cv::VideoCapture::isOpened
release cv::VideoCapture::release
grab cv::VideoCapture::grab
retrieve cv::VideoCapture::retrieve
retrieve cv::VideoCapture::retrieve
read cv::VideoCapture::read
read cv::VideoCapture::read
set cv::VideoCapture::set
get cv::VideoCapture::get
getBackendName cv::VideoCapture::getBackendName
setExceptionMode cv::VideoCapture::setExceptionMode
getExceptionMode cv::VideoCapture::getExceptionMode
n cv.VideoWriter
cv.VideoWriter
cv VideoWriter
VideoWriter cv::VideoWriter::VideoWriter
[]
VideoWriter cv::VideoWriter::VideoWriter
[]
VideoWriter cv::VideoWriter::VideoWriter
[]
open cv::VideoWriter::open
open cv::VideoWriter::open
isOpened cv::VideoWriter::isOpened
release cv::VideoWriter::release
write cv::VideoWriter::write
write cv::VideoWriter::write
set cv::VideoWriter::set
get cv::VideoWriter::get
fourcc cv::VideoWriter::fourcc
VideoWriter_fourcc cv::VideoWriter::fourcc
getBackendName cv::VideoWriter::getBackendName
namedWindow cv::namedWindow
destroyWindow cv::destroyWindow
destroyAllWindows cv::destroyAllWindows
startWindowThread cv::startWindowThread
waitKeyEx cv::waitKeyEx
waitKey cv::waitKey
imshow cv::imshow
imshow cv::imshow
resizeWindow cv::resizeWindow
resizeWindow cv::resizeWindow
moveWindow cv::moveWindow
setWindowProperty cv::setWindowProperty
setWindowTitle cv::setWindowTitle
getWindowProperty cv::getWindowProperty
getWindowImageRect cv::getWindowImageRect
selectROI cv::selectROI
selectROI cv::selectROI
selectROI cv::selectROI
selectROI cv::selectROI
selectROIs cv::selectROIs
selectROIs cv::selectROIs
getTrackbarPos cv::getTrackbarPos
setTrackbarPos cv::setTrackbarPos
setTrackbarMax cv::setTrackbarMax
setTrackbarMin cv::setTrackbarMin
addText cv::addText
addText cv::addText
displayOverlay cv::displayOverlay
displayStatusBar cv::displayStatusBar
{'cv.Algorithm': <__main__.ClassInfo object at 0x7fb78dde65f8>, 'cv.ocl.Device': <__main__.ClassInfo object at 0x7fb78de61780>, 'cv.flann.Index': <__main__.ClassInfo object at 0x7fb78de6aeb8>, 'cv.ml.ParamGrid': <__main__.ClassInfo object at 0x7fb78de17438>, 'cv.ml.TrainData': <__main__.ClassInfo object at 0x7fb78de13080>, 'cv.ml.StatModel': <__main__.ClassInfo object at 0x7fb78de76fd0>, 'cv.ml.NormalBayesClassifier': <__main__.ClassInfo object at 0x7fb78ddfd3c8>, 'cv.ml.KNearest': <__main__.ClassInfo object at 0x7fb78ddfdf60>, 'cv.ml.SVM': <__main__.ClassInfo object at 0x7fb78de06668>, 'cv.ml.EM': <__main__.ClassInfo object at 0x7fb78dcdd2b0>, 'cv.ml.DTrees': <__main__.ClassInfo object at 0x7fb78dcebb38>, 'cv.ml.RTrees': <__main__.ClassInfo object at 0x7fb78dcf9e80>, 'cv.ml.Boost': <__main__.ClassInfo object at 0x7fb78dce31d0>, 'cv.ml.ANN_MLP': <__main__.ClassInfo object at 0x7fb78dcdddd8>, 'cv.ml.LogisticRegression': <__main__.ClassInfo object at 0x7fb78dd01518>, 'cv.ml.SVMSGD': <__main__.ClassInfo object at 0x7fb78dca3470>, 'cv.GeneralizedHough': <__main__.ClassInfo object at 0x7fb78dd91160>, 'cv.GeneralizedHoughBallard': <__main__.ClassInfo object at 0x7fb78dd910b8>, 'cv.GeneralizedHoughGuil': <__main__.ClassInfo object at 0x7fb78dd98dd8>, 'cv.CLAHE': <__main__.ClassInfo object at 0x7fb78dd98d30>, 'cv.Subdiv2D': <__main__.ClassInfo object at 0x7fb78ddaf668>, 'cv.LineSegmentDetector': <__main__.ClassInfo object at 0x7fb78dd91208>, 'cv.CirclesGridFinderParameters': <__main__.ClassInfo object at 0x7fb78dcaea20>, 'cv.StereoMatcher': <__main__.ClassInfo object at 0x7fb78dc47ef0>, 'cv.StereoBM': <__main__.ClassInfo object at 0x7fb78dc47d68>, 'cv.StereoSGBM': <__main__.ClassInfo object at 0x7fb78dad2a20>, 'cv.Feature2D': <__main__.ClassInfo object at 0x7fb78dad99b0>, 'cv.BRISK': <__main__.ClassInfo object at 0x7fb78dc47f28>, 'cv.ORB': <__main__.ClassInfo object at 0x7fb78db06ba8>, 'cv.MSER': <__main__.ClassInfo object at 0x7fb78da522e8>, 'cv.FastFeatureDetector': <__main__.ClassInfo object at 0x7fb78da5bd68>, 'cv.AgastFeatureDetector': <__main__.ClassInfo object at 0x7fb78da6c5f8>, 'cv.GFTTDetector': <__main__.ClassInfo object at 0x7fb78da6c5c0>, 'cv.SimpleBlobDetector': <__main__.ClassInfo object at 0x7fb78da1b4a8>, 'cv.SimpleBlobDetector.Params': <__main__.ClassInfo object at 0x7fb78da1b470>, 'SimpleBlobDetector.Params': <__main__.ClassInfo object at 0x7fb78da3e6d8>, 'cv.KAZE': <__main__.ClassInfo object at 0x7fb78da3e908>, 'cv.AKAZE': <__main__.ClassInfo object at 0x7fb78da3e8d0>, 'cv.DescriptorMatcher': <__main__.ClassInfo object at 0x7fb78da4beb8>, 'cv.BFMatcher': <__main__.ClassInfo object at 0x7fb78da4be80>, 'cv.FlannBasedMatcher': <__main__.ClassInfo object at 0x7fb78d9df320>, 'cv.BOWTrainer': <__main__.ClassInfo object at 0x7fb78d9df278>, 'cv.BOWKMeansTrainer': <__main__.ClassInfo object at 0x7fb78dadedd8>, 'cv.BOWImgDescriptorExtractor': <__main__.ClassInfo object at 0x7fb78dad2f98>, 'cv.KalmanFilter': <__main__.ClassInfo object at 0x7fb78daca048>, 'cv.DenseOpticalFlow': <__main__.ClassInfo object at 0x7fb78da3a4e0>, 'cv.SparseOpticalFlow': <__main__.ClassInfo object at 0x7fb78da3b320>, 'cv.FarnebackOpticalFlow': <__main__.ClassInfo object at 0x7fb78da3e588>, 'cv.VariationalRefinement': <__main__.ClassInfo object at 0x7fb78da3bc88>, 'cv.DISOpticalFlow': <__main__.ClassInfo object at 0x7fb78da05710>, 'cv.SparsePyrLKOpticalFlow': <__main__.ClassInfo object at 0x7fb78da056d8>, 'cv.BackgroundSubtractor': <__main__.ClassInfo object at 0x7fb78d9e7dd8>, 'cv.BackgroundSubtractorMOG2': <__main__.ClassInfo object at 0x7fb78d9e7b70>, 'cv.BackgroundSubtractorKNN': <__main__.ClassInfo object at 0x7fb78da3e208>, 'cv.BaseCascadeClassifier': <__main__.ClassInfo object at 0x7fb78da3b518>, 'cv.CascadeClassifier': <__main__.ClassInfo object at 0x7fb78d99b518>, 'cv.HOGDescriptor': <__main__.ClassInfo object at 0x7fb78da02d68>, 'cv.QRCodeDetector': <__main__.ClassInfo object at 0x7fb78d9bfa20>, 'cv.VideoCapture': <__main__.ClassInfo object at 0x7fb78d9bf9e8>, 'cv.VideoWriter': <__main__.ClassInfo object at 0x7fb78d99b080>}
cv.Algorithm
cv.ml.StatModel
cv.ml.StatModel
cv.ml.StatModel
cv.ml.StatModel
cv.ml.StatModel
cv.ml.DTrees
cv.ml.DTrees
cv.ml.StatModel
cv.ml.StatModel
cv.ml.StatModel
cv.Algorithm
cv.GeneralizedHough
cv.GeneralizedHough
cv.Algorithm
cv.Algorithm
cv.Algorithm
cv.StereoMatcher
cv.StereoMatcher
cv.Algorithm
cv.Feature2D
cv.Feature2D
cv.Feature2D
cv.Feature2D
cv.Feature2D
cv.Feature2D
cv.Feature2D
cv.Feature2D
cv.Feature2D
cv.Algorithm
cv.DescriptorMatcher
cv.DescriptorMatcher
cv.BOWTrainer
cv.Algorithm
cv.Algorithm
cv.DenseOpticalFlow
cv.DenseOpticalFlow
cv.DenseOpticalFlow
cv.SparseOpticalFlow
cv.Algorithm
cv.BackgroundSubtractor
cv.BackgroundSubtractor
cv.Algorithm
cv
	 Algorithm False
		 clear
		 .method("jlopencv_cv_Algorithm_clear",  [](Algorithm &cobj) { cobj.clear();  ;})
		 clear() -> nothing
		 write
		 .method("jlopencv_cv_Algorithm_write",  [](Algorithm &cobj, Ptr<FileStorage> &fs, String &name) { cobj.write(fs, name);  ;})
		 write(fs::Ptr<FileStorage>, name::String) -> nothing
		 read
		 .method("jlopencv_cv_Algorithm_read",  [](Algorithm &cobj, FileNode &fn) { cobj.read(fn);  ;})
		 read(fn::FileNode) -> nothing
		 empty
		 .method("jlopencv_cv_Algorithm_empty",  [](Algorithm &cobj) { auto retval = cobj.empty();  return retval;})
		 empty() -> ( retval::bool ) 
		 save
		 .method("jlopencv_cv_Algorithm_save",  [](Algorithm &cobj, String &filename) { cobj.save(filename);  ;})
		 save(filename::String) -> nothing
		 getDefaultName
		 .method("jlopencv_cv_Algorithm_getDefaultName",  [](Algorithm &cobj) { auto retval = cobj.getDefaultName();  return retval;})
		 getDefaultName() -> ( retval::String ) 
	 .add_type<cv::Algorithm>("Algorithm")
	 function Base.getproperty(m::Algorithm, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::Algorithm, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 GeneralizedHough True
		 setTemplate
		 .method("jlopencv_cv_GeneralizedHough_setTemplate",  [](cv::Ptr<GeneralizedHough> &cobj, Mat &templ, Point &templCenter) { cobj->setTemplate(templ, templCenter);  ;})
		 setTemplate(templ::Mat, templCenter::Point) -> nothing
		 setTemplate
		 .method("jlopencv_cv_GeneralizedHough_setTemplate",  [](cv::Ptr<GeneralizedHough> &cobj, UMat &templ, Point &templCenter) { cobj->setTemplate(templ, templCenter);  ;})
		 setTemplate(templ::UMat, templCenter::Point) -> nothing
		 setTemplate
		 .method("jlopencv_cv_GeneralizedHough_setTemplate",  [](cv::Ptr<GeneralizedHough> &cobj, Mat &edges, Mat &dx, Mat &dy, Point &templCenter) { cobj->setTemplate(edges, dx, dy, templCenter);  ;})
		 setTemplate(edges::Mat, dx::Mat, dy::Mat, templCenter::Point) -> nothing
		 setTemplate
		 .method("jlopencv_cv_GeneralizedHough_setTemplate",  [](cv::Ptr<GeneralizedHough> &cobj, UMat &edges, UMat &dx, UMat &dy, Point &templCenter) { cobj->setTemplate(edges, dx, dy, templCenter);  ;})
		 setTemplate(edges::UMat, dx::UMat, dy::UMat, templCenter::Point) -> nothing
		 detect
		 .method("jlopencv_cv_GeneralizedHough_detect",  [](cv::Ptr<GeneralizedHough> &cobj, Mat &image, Mat &positions, Mat &votes) { cobj->detect(image, positions, votes);  return make_tuple<Mat,Mat>(positions,votes);})
		 detect(image::Mat; positions::Mat, votes::Mat) -> ( positions::Mat, votes::Mat ) 
		 detect
		 .method("jlopencv_cv_GeneralizedHough_detect",  [](cv::Ptr<GeneralizedHough> &cobj, UMat &image, UMat &positions, UMat &votes) { cobj->detect(image, positions, votes);  return make_tuple<UMat,UMat>(positions,votes);})
		 detect(image::UMat; positions::UMat, votes::UMat) -> ( positions::UMat, votes::UMat ) 
		 detect
		 .method("jlopencv_cv_GeneralizedHough_detect",  [](cv::Ptr<GeneralizedHough> &cobj, Mat &edges, Mat &dx, Mat &dy, Mat &positions, Mat &votes) { cobj->detect(edges, dx, dy, positions, votes);  return make_tuple<Mat,Mat>(positions,votes);})
		 detect(edges::Mat, dx::Mat, dy::Mat; positions::Mat, votes::Mat) -> ( positions::Mat, votes::Mat ) 
		 detect
		 .method("jlopencv_cv_GeneralizedHough_detect",  [](cv::Ptr<GeneralizedHough> &cobj, UMat &edges, UMat &dx, UMat &dy, UMat &positions, UMat &votes) { cobj->detect(edges, dx, dy, positions, votes);  return make_tuple<UMat,UMat>(positions,votes);})
		 detect(edges::UMat, dx::UMat, dy::UMat; positions::UMat, votes::UMat) -> ( positions::UMat, votes::UMat ) 
		 setCannyLowThresh
		 .method("jlopencv_cv_GeneralizedHough_setCannyLowThresh",  [](cv::Ptr<GeneralizedHough> &cobj, int &cannyLowThresh) { cobj->setCannyLowThresh(cannyLowThresh);  ;})
		 setCannyLowThresh(cannyLowThresh::int) -> nothing
		 getCannyLowThresh
		 .method("jlopencv_cv_GeneralizedHough_getCannyLowThresh",  [](cv::Ptr<GeneralizedHough> &cobj) { auto retval = cobj->getCannyLowThresh();  return retval;})
		 getCannyLowThresh() -> ( retval::int ) 
		 setCannyHighThresh
		 .method("jlopencv_cv_GeneralizedHough_setCannyHighThresh",  [](cv::Ptr<GeneralizedHough> &cobj, int &cannyHighThresh) { cobj->setCannyHighThresh(cannyHighThresh);  ;})
		 setCannyHighThresh(cannyHighThresh::int) -> nothing
		 getCannyHighThresh
		 .method("jlopencv_cv_GeneralizedHough_getCannyHighThresh",  [](cv::Ptr<GeneralizedHough> &cobj) { auto retval = cobj->getCannyHighThresh();  return retval;})
		 getCannyHighThresh() -> ( retval::int ) 
		 setMinDist
		 .method("jlopencv_cv_GeneralizedHough_setMinDist",  [](cv::Ptr<GeneralizedHough> &cobj, double &minDist) { cobj->setMinDist(minDist);  ;})
		 setMinDist(minDist::double) -> nothing
		 getMinDist
		 .method("jlopencv_cv_GeneralizedHough_getMinDist",  [](cv::Ptr<GeneralizedHough> &cobj) { auto retval = cobj->getMinDist();  return retval;})
		 getMinDist() -> ( retval::double ) 
		 setDp
		 .method("jlopencv_cv_GeneralizedHough_setDp",  [](cv::Ptr<GeneralizedHough> &cobj, double &dp) { cobj->setDp(dp);  ;})
		 setDp(dp::double) -> nothing
		 getDp
		 .method("jlopencv_cv_GeneralizedHough_getDp",  [](cv::Ptr<GeneralizedHough> &cobj) { auto retval = cobj->getDp();  return retval;})
		 getDp() -> ( retval::double ) 
		 setMaxBufferSize
		 .method("jlopencv_cv_GeneralizedHough_setMaxBufferSize",  [](cv::Ptr<GeneralizedHough> &cobj, int &maxBufferSize) { cobj->setMaxBufferSize(maxBufferSize);  ;})
		 setMaxBufferSize(maxBufferSize::int) -> nothing
		 getMaxBufferSize
		 .method("jlopencv_cv_GeneralizedHough_getMaxBufferSize",  [](cv::Ptr<GeneralizedHough> &cobj) { auto retval = cobj->getMaxBufferSize();  return retval;})
		 getMaxBufferSize() -> ( retval::int ) 
	 WIP
	 function Base.getproperty(m::GeneralizedHough, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::GeneralizedHough, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 GeneralizedHoughBallard True
		 setLevels
		 .method("jlopencv_cv_GeneralizedHoughBallard_setLevels",  [](cv::Ptr<GeneralizedHoughBallard> &cobj, int &levels) { cobj->setLevels(levels);  ;})
		 setLevels(levels::int) -> nothing
		 getLevels
		 .method("jlopencv_cv_GeneralizedHoughBallard_getLevels",  [](cv::Ptr<GeneralizedHoughBallard> &cobj) { auto retval = cobj->getLevels();  return retval;})
		 getLevels() -> ( retval::int ) 
		 setVotesThreshold
		 .method("jlopencv_cv_GeneralizedHoughBallard_setVotesThreshold",  [](cv::Ptr<GeneralizedHoughBallard> &cobj, int &votesThreshold) { cobj->setVotesThreshold(votesThreshold);  ;})
		 setVotesThreshold(votesThreshold::int) -> nothing
		 getVotesThreshold
		 .method("jlopencv_cv_GeneralizedHoughBallard_getVotesThreshold",  [](cv::Ptr<GeneralizedHoughBallard> &cobj) { auto retval = cobj->getVotesThreshold();  return retval;})
		 getVotesThreshold() -> ( retval::int ) 
	 WIP
	 function Base.getproperty(m::GeneralizedHoughBallard, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::GeneralizedHoughBallard, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 GeneralizedHoughGuil True
		 setXi
		 .method("jlopencv_cv_GeneralizedHoughGuil_setXi",  [](cv::Ptr<GeneralizedHoughGuil> &cobj, double &xi) { cobj->setXi(xi);  ;})
		 setXi(xi::double) -> nothing
		 getXi
		 .method("jlopencv_cv_GeneralizedHoughGuil_getXi",  [](cv::Ptr<GeneralizedHoughGuil> &cobj) { auto retval = cobj->getXi();  return retval;})
		 getXi() -> ( retval::double ) 
		 setLevels
		 .method("jlopencv_cv_GeneralizedHoughGuil_setLevels",  [](cv::Ptr<GeneralizedHoughGuil> &cobj, int &levels) { cobj->setLevels(levels);  ;})
		 setLevels(levels::int) -> nothing
		 getLevels
		 .method("jlopencv_cv_GeneralizedHoughGuil_getLevels",  [](cv::Ptr<GeneralizedHoughGuil> &cobj) { auto retval = cobj->getLevels();  return retval;})
		 getLevels() -> ( retval::int ) 
		 setAngleEpsilon
		 .method("jlopencv_cv_GeneralizedHoughGuil_setAngleEpsilon",  [](cv::Ptr<GeneralizedHoughGuil> &cobj, double &angleEpsilon) { cobj->setAngleEpsilon(angleEpsilon);  ;})
		 setAngleEpsilon(angleEpsilon::double) -> nothing
		 getAngleEpsilon
		 .method("jlopencv_cv_GeneralizedHoughGuil_getAngleEpsilon",  [](cv::Ptr<GeneralizedHoughGuil> &cobj) { auto retval = cobj->getAngleEpsilon();  return retval;})
		 getAngleEpsilon() -> ( retval::double ) 
		 setMinAngle
		 .method("jlopencv_cv_GeneralizedHoughGuil_setMinAngle",  [](cv::Ptr<GeneralizedHoughGuil> &cobj, double &minAngle) { cobj->setMinAngle(minAngle);  ;})
		 setMinAngle(minAngle::double) -> nothing
		 getMinAngle
		 .method("jlopencv_cv_GeneralizedHoughGuil_getMinAngle",  [](cv::Ptr<GeneralizedHoughGuil> &cobj) { auto retval = cobj->getMinAngle();  return retval;})
		 getMinAngle() -> ( retval::double ) 
		 setMaxAngle
		 .method("jlopencv_cv_GeneralizedHoughGuil_setMaxAngle",  [](cv::Ptr<GeneralizedHoughGuil> &cobj, double &maxAngle) { cobj->setMaxAngle(maxAngle);  ;})
		 setMaxAngle(maxAngle::double) -> nothing
		 getMaxAngle
		 .method("jlopencv_cv_GeneralizedHoughGuil_getMaxAngle",  [](cv::Ptr<GeneralizedHoughGuil> &cobj) { auto retval = cobj->getMaxAngle();  return retval;})
		 getMaxAngle() -> ( retval::double ) 
		 setAngleStep
		 .method("jlopencv_cv_GeneralizedHoughGuil_setAngleStep",  [](cv::Ptr<GeneralizedHoughGuil> &cobj, double &angleStep) { cobj->setAngleStep(angleStep);  ;})
		 setAngleStep(angleStep::double) -> nothing
		 getAngleStep
		 .method("jlopencv_cv_GeneralizedHoughGuil_getAngleStep",  [](cv::Ptr<GeneralizedHoughGuil> &cobj) { auto retval = cobj->getAngleStep();  return retval;})
		 getAngleStep() -> ( retval::double ) 
		 setAngleThresh
		 .method("jlopencv_cv_GeneralizedHoughGuil_setAngleThresh",  [](cv::Ptr<GeneralizedHoughGuil> &cobj, int &angleThresh) { cobj->setAngleThresh(angleThresh);  ;})
		 setAngleThresh(angleThresh::int) -> nothing
		 getAngleThresh
		 .method("jlopencv_cv_GeneralizedHoughGuil_getAngleThresh",  [](cv::Ptr<GeneralizedHoughGuil> &cobj) { auto retval = cobj->getAngleThresh();  return retval;})
		 getAngleThresh() -> ( retval::int ) 
		 setMinScale
		 .method("jlopencv_cv_GeneralizedHoughGuil_setMinScale",  [](cv::Ptr<GeneralizedHoughGuil> &cobj, double &minScale) { cobj->setMinScale(minScale);  ;})
		 setMinScale(minScale::double) -> nothing
		 getMinScale
		 .method("jlopencv_cv_GeneralizedHoughGuil_getMinScale",  [](cv::Ptr<GeneralizedHoughGuil> &cobj) { auto retval = cobj->getMinScale();  return retval;})
		 getMinScale() -> ( retval::double ) 
		 setMaxScale
		 .method("jlopencv_cv_GeneralizedHoughGuil_setMaxScale",  [](cv::Ptr<GeneralizedHoughGuil> &cobj, double &maxScale) { cobj->setMaxScale(maxScale);  ;})
		 setMaxScale(maxScale::double) -> nothing
		 getMaxScale
		 .method("jlopencv_cv_GeneralizedHoughGuil_getMaxScale",  [](cv::Ptr<GeneralizedHoughGuil> &cobj) { auto retval = cobj->getMaxScale();  return retval;})
		 getMaxScale() -> ( retval::double ) 
		 setScaleStep
		 .method("jlopencv_cv_GeneralizedHoughGuil_setScaleStep",  [](cv::Ptr<GeneralizedHoughGuil> &cobj, double &scaleStep) { cobj->setScaleStep(scaleStep);  ;})
		 setScaleStep(scaleStep::double) -> nothing
		 getScaleStep
		 .method("jlopencv_cv_GeneralizedHoughGuil_getScaleStep",  [](cv::Ptr<GeneralizedHoughGuil> &cobj) { auto retval = cobj->getScaleStep();  return retval;})
		 getScaleStep() -> ( retval::double ) 
		 setScaleThresh
		 .method("jlopencv_cv_GeneralizedHoughGuil_setScaleThresh",  [](cv::Ptr<GeneralizedHoughGuil> &cobj, int &scaleThresh) { cobj->setScaleThresh(scaleThresh);  ;})
		 setScaleThresh(scaleThresh::int) -> nothing
		 getScaleThresh
		 .method("jlopencv_cv_GeneralizedHoughGuil_getScaleThresh",  [](cv::Ptr<GeneralizedHoughGuil> &cobj) { auto retval = cobj->getScaleThresh();  return retval;})
		 getScaleThresh() -> ( retval::int ) 
		 setPosThresh
		 .method("jlopencv_cv_GeneralizedHoughGuil_setPosThresh",  [](cv::Ptr<GeneralizedHoughGuil> &cobj, int &posThresh) { cobj->setPosThresh(posThresh);  ;})
		 setPosThresh(posThresh::int) -> nothing
		 getPosThresh
		 .method("jlopencv_cv_GeneralizedHoughGuil_getPosThresh",  [](cv::Ptr<GeneralizedHoughGuil> &cobj) { auto retval = cobj->getPosThresh();  return retval;})
		 getPosThresh() -> ( retval::int ) 
	 WIP
	 function Base.getproperty(m::GeneralizedHoughGuil, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::GeneralizedHoughGuil, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 CLAHE True
		 apply
		 .method("jlopencv_cv_CLAHE_apply",  [](cv::Ptr<CLAHE> &cobj, Mat &src, Mat &dst) { cobj->apply(src, dst);  return dst;})
		 apply(src::Mat; dst::Mat) -> ( dst::Mat ) 
		 apply
		 .method("jlopencv_cv_CLAHE_apply",  [](cv::Ptr<CLAHE> &cobj, UMat &src, UMat &dst) { cobj->apply(src, dst);  return dst;})
		 apply(src::UMat; dst::UMat) -> ( dst::UMat ) 
		 setClipLimit
		 .method("jlopencv_cv_CLAHE_setClipLimit",  [](cv::Ptr<CLAHE> &cobj, double &clipLimit) { cobj->setClipLimit(clipLimit);  ;})
		 setClipLimit(clipLimit::double) -> nothing
		 getClipLimit
		 .method("jlopencv_cv_CLAHE_getClipLimit",  [](cv::Ptr<CLAHE> &cobj) { auto retval = cobj->getClipLimit();  return retval;})
		 getClipLimit() -> ( retval::double ) 
		 setTilesGridSize
		 .method("jlopencv_cv_CLAHE_setTilesGridSize",  [](cv::Ptr<CLAHE> &cobj, Size &tileGridSize) { cobj->setTilesGridSize(tileGridSize);  ;})
		 setTilesGridSize(tileGridSize::Size) -> nothing
		 getTilesGridSize
		 .method("jlopencv_cv_CLAHE_getTilesGridSize",  [](cv::Ptr<CLAHE> &cobj) { auto retval = cobj->getTilesGridSize();  return retval;})
		 getTilesGridSize() -> ( retval::Size ) 
		 collectGarbage
		 .method("jlopencv_cv_CLAHE_collectGarbage",  [](cv::Ptr<CLAHE> &cobj) { cobj->collectGarbage();  ;})
		 collectGarbage() -> nothing
	 WIP
	 function Base.getproperty(m::CLAHE, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::CLAHE, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 Subdiv2D False
		 initDelaunay
		 .method("jlopencv_cv_Subdiv2D_initDelaunay",  [](Subdiv2D &cobj, Rect &rect) { cobj.initDelaunay(rect);  ;})
		 initDelaunay(rect::Rect) -> nothing
		 insert
		 .method("jlopencv_cv_Subdiv2D_insert",  [](Subdiv2D &cobj, Point2f &pt) { auto retval = cobj.insert(pt);  return retval;})
		 insert(pt::Point2f) -> ( retval::int ) 
		 insert
		 .method("jlopencv_cv_Subdiv2D_insert",  [](Subdiv2D &cobj, vector<Point2f> &ptvec) { cobj.insert(ptvec);  ;})
		 insert(ptvec::vector<Point2f>) -> nothing
		 locate
		 .method("jlopencv_cv_Subdiv2D_locate",  [](Subdiv2D &cobj, Point2f &pt) {int edge;int vertex; auto retval = cobj.locate(pt, edge, vertex);  return make_tuple<int,int,int>(retval,edge,vertex);})
		 locate(pt::Point2f) -> ( retval::int, edge::int, vertex::int ) 
		 findNearest
		 .method("jlopencv_cv_Subdiv2D_findNearest",  [](Subdiv2D &cobj, Point2f &pt) {Point2f nearestPt; auto retval = cobj.findNearest(pt, &nearestPt);  return make_tuple<int,Point2f>(retval,nearestPt);})
		 findNearest(pt::Point2f) -> ( retval::int, nearestPt::Point2f* ) 
		 getEdgeList
		 .method("jlopencv_cv_Subdiv2D_getEdgeList",  [](Subdiv2D &cobj) {vector<Vec4f> edgeList; cobj.getEdgeList(edgeList);  return edgeList;})
		 getEdgeList() -> ( edgeList::vector<Vec4f> ) 
		 getLeadingEdgeList
		 .method("jlopencv_cv_Subdiv2D_getLeadingEdgeList",  [](Subdiv2D &cobj) {vector<int> leadingEdgeList; cobj.getLeadingEdgeList(leadingEdgeList);  return leadingEdgeList;})
		 getLeadingEdgeList() -> ( leadingEdgeList::vector<int> ) 
		 getTriangleList
		 .method("jlopencv_cv_Subdiv2D_getTriangleList",  [](Subdiv2D &cobj) {vector<Vec6f> triangleList; cobj.getTriangleList(triangleList);  return triangleList;})
		 getTriangleList() -> ( triangleList::vector<Vec6f> ) 
		 getVoronoiFacetList
		 .method("jlopencv_cv_Subdiv2D_getVoronoiFacetList",  [](Subdiv2D &cobj, vector<int> &idx) {vector<vector<Point2f>> facetList;vector<Point2f> facetCenters; cobj.getVoronoiFacetList(idx, facetList, facetCenters);  return make_tuple<vector<vector<Point2f>>,vector<Point2f>>(facetList,facetCenters);})
		 getVoronoiFacetList(idx::vector<int>) -> ( facetList::vector<vector<Point2f>>, facetCenters::vector<Point2f> ) 
		 getVertex
		 .method("jlopencv_cv_Subdiv2D_getVertex",  [](Subdiv2D &cobj, int &vertex) {int firstEdge; auto retval = cobj.getVertex(vertex, &firstEdge);  return make_tuple<Point2f,int>(retval,firstEdge);})
		 getVertex(vertex::int) -> ( retval::Point2f, firstEdge::int* ) 
		 getEdge
		 .method("jlopencv_cv_Subdiv2D_getEdge",  [](Subdiv2D &cobj, int &edge, int &nextEdgeType) { auto retval = cobj.getEdge(edge, nextEdgeType);  return retval;})
		 getEdge(edge::int, nextEdgeType::int) -> ( retval::int ) 
		 nextEdge
		 .method("jlopencv_cv_Subdiv2D_nextEdge",  [](Subdiv2D &cobj, int &edge) { auto retval = cobj.nextEdge(edge);  return retval;})
		 nextEdge(edge::int) -> ( retval::int ) 
		 rotateEdge
		 .method("jlopencv_cv_Subdiv2D_rotateEdge",  [](Subdiv2D &cobj, int &edge, int &rotate) { auto retval = cobj.rotateEdge(edge, rotate);  return retval;})
		 rotateEdge(edge::int, rotate::int) -> ( retval::int ) 
		 symEdge
		 .method("jlopencv_cv_Subdiv2D_symEdge",  [](Subdiv2D &cobj, int &edge) { auto retval = cobj.symEdge(edge);  return retval;})
		 symEdge(edge::int) -> ( retval::int ) 
		 edgeOrg
		 .method("jlopencv_cv_Subdiv2D_edgeOrg",  [](Subdiv2D &cobj, int &edge) {Point2f orgpt; auto retval = cobj.edgeOrg(edge, &orgpt);  return make_tuple<int,Point2f>(retval,orgpt);})
		 edgeOrg(edge::int) -> ( retval::int, orgpt::Point2f* ) 
		 edgeDst
		 .method("jlopencv_cv_Subdiv2D_edgeDst",  [](Subdiv2D &cobj, int &edge) {Point2f dstpt; auto retval = cobj.edgeDst(edge, &dstpt);  return make_tuple<int,Point2f>(retval,dstpt);})
		 edgeDst(edge::int) -> ( retval::int, dstpt::Point2f* ) 
	 .add_type<cv::Subdiv2D>("Subdiv2D").constructor<>().constructor<const Rect&>()
	 function Base.getproperty(m::Subdiv2D, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::Subdiv2D, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 LineSegmentDetector True
		 detect
		 .method("jlopencv_cv_LineSegmentDetector_detect",  [](cv::Ptr<LineSegmentDetector> &cobj, Mat &_image, Mat &_lines, Mat &width, Mat &prec, Mat &nfa) { cobj->detect(_image, _lines, width, prec, nfa);  return make_tuple<Mat,Mat,Mat,Mat>(_lines,width,prec,nfa);})
		 detect(_image::Mat; _lines::Mat, width::Mat, prec::Mat, nfa::Mat) -> ( _lines::Mat, width::Mat, prec::Mat, nfa::Mat ) 
		 detect
		 .method("jlopencv_cv_LineSegmentDetector_detect",  [](cv::Ptr<LineSegmentDetector> &cobj, UMat &_image, UMat &_lines, UMat &width, UMat &prec, UMat &nfa) { cobj->detect(_image, _lines, width, prec, nfa);  return make_tuple<UMat,UMat,UMat,UMat>(_lines,width,prec,nfa);})
		 detect(_image::UMat; _lines::UMat, width::UMat, prec::UMat, nfa::UMat) -> ( _lines::UMat, width::UMat, prec::UMat, nfa::UMat ) 
		 drawSegments
		 .method("jlopencv_cv_LineSegmentDetector_drawSegments",  [](cv::Ptr<LineSegmentDetector> &cobj, Mat &_image, Mat &lines) { cobj->drawSegments(_image, lines);  return _image;})
		 drawSegments(_image::Mat, lines::Mat) -> ( _image::Mat ) 
		 drawSegments
		 .method("jlopencv_cv_LineSegmentDetector_drawSegments",  [](cv::Ptr<LineSegmentDetector> &cobj, UMat &_image, UMat &lines) { cobj->drawSegments(_image, lines);  return _image;})
		 drawSegments(_image::UMat, lines::UMat) -> ( _image::UMat ) 
		 compareSegments
		 .method("jlopencv_cv_LineSegmentDetector_compareSegments",  [](cv::Ptr<LineSegmentDetector> &cobj, Size &size, Mat &lines1, Mat &lines2, Mat &_image) { auto retval = cobj->compareSegments(size, lines1, lines2, _image);  return make_tuple<int,Mat>(retval,_image);})
		 compareSegments(size::Size, lines1::Mat, lines2::Mat, _image::Mat) -> ( retval::int, _image::Mat ) 
		 compareSegments
		 .method("jlopencv_cv_LineSegmentDetector_compareSegments",  [](cv::Ptr<LineSegmentDetector> &cobj, Size &size, UMat &lines1, UMat &lines2, UMat &_image) { auto retval = cobj->compareSegments(size, lines1, lines2, _image);  return make_tuple<int,UMat>(retval,_image);})
		 compareSegments(size::Size, lines1::UMat, lines2::UMat, _image::UMat) -> ( retval::int, _image::UMat ) 
	 WIP
	 function Base.getproperty(m::LineSegmentDetector, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::LineSegmentDetector, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 CirclesGridFinderParameters False
	 .add_type<cv::CirclesGridFinderParameters>("CirclesGridFinderParameters").constructor<>().method("jlopencv_CirclesGridFinderParameters_set_densityNeighborhoodSize", [](cv::CirclesGridFinderParameters &cobj,const Size2f &v) {cobj.densityNeighborhoodSize=v;}).method("jlopencv_CirclesGridFinderParameters_set_minDensity", [](cv::CirclesGridFinderParameters &cobj,const float &v) {cobj.minDensity=v;}).method("jlopencv_CirclesGridFinderParameters_set_kmeansAttempts", [](cv::CirclesGridFinderParameters &cobj,const int &v) {cobj.kmeansAttempts=v;}).method("jlopencv_CirclesGridFinderParameters_set_minDistanceToAddKeypoint", [](cv::CirclesGridFinderParameters &cobj,const int &v) {cobj.minDistanceToAddKeypoint=v;}).method("jlopencv_CirclesGridFinderParameters_set_keypointScale", [](cv::CirclesGridFinderParameters &cobj,const int &v) {cobj.keypointScale=v;}).method("jlopencv_CirclesGridFinderParameters_set_minGraphConfidence", [](cv::CirclesGridFinderParameters &cobj,const float &v) {cobj.minGraphConfidence=v;}).method("jlopencv_CirclesGridFinderParameters_set_vertexGain", [](cv::CirclesGridFinderParameters &cobj,const float &v) {cobj.vertexGain=v;}).method("jlopencv_CirclesGridFinderParameters_set_vertexPenalty", [](cv::CirclesGridFinderParameters &cobj,const float &v) {cobj.vertexPenalty=v;}).method("jlopencv_CirclesGridFinderParameters_set_existingVertexGain", [](cv::CirclesGridFinderParameters &cobj,const float &v) {cobj.existingVertexGain=v;}).method("jlopencv_CirclesGridFinderParameters_set_edgeGain", [](cv::CirclesGridFinderParameters &cobj,const float &v) {cobj.edgeGain=v;}).method("jlopencv_CirclesGridFinderParameters_set_edgePenalty", [](cv::CirclesGridFinderParameters &cobj,const float &v) {cobj.edgePenalty=v;}).method("jlopencv_CirclesGridFinderParameters_set_convexHullFactor", [](cv::CirclesGridFinderParameters &cobj,const float &v) {cobj.convexHullFactor=v;}).method("jlopencv_CirclesGridFinderParameters_set_minRNGEdgeSwitchDist", [](cv::CirclesGridFinderParameters &cobj,const float &v) {cobj.minRNGEdgeSwitchDist=v;}).method("jlopencv_CirclesGridFinderParameters_set_squareSize", [](cv::CirclesGridFinderParameters &cobj,const float &v) {cobj.squareSize=v;}).method("jlopencv_CirclesGridFinderParameters_set_maxRectifiedDistance", [](cv::CirclesGridFinderParameters &cobj,const float &v) {cobj.maxRectifiedDistance=v;}).method("jlopencv_CirclesGridFinderParameters_get_densityNeighborhoodSize", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.densityNeighborhoodSize;}).method("jlopencv_CirclesGridFinderParameters_get_minDensity", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.minDensity;}).method("jlopencv_CirclesGridFinderParameters_get_kmeansAttempts", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.kmeansAttempts;}).method("jlopencv_CirclesGridFinderParameters_get_minDistanceToAddKeypoint", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.minDistanceToAddKeypoint;}).method("jlopencv_CirclesGridFinderParameters_get_keypointScale", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.keypointScale;}).method("jlopencv_CirclesGridFinderParameters_get_minGraphConfidence", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.minGraphConfidence;}).method("jlopencv_CirclesGridFinderParameters_get_vertexGain", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.vertexGain;}).method("jlopencv_CirclesGridFinderParameters_get_vertexPenalty", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.vertexPenalty;}).method("jlopencv_CirclesGridFinderParameters_get_existingVertexGain", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.existingVertexGain;}).method("jlopencv_CirclesGridFinderParameters_get_edgeGain", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.edgeGain;}).method("jlopencv_CirclesGridFinderParameters_get_edgePenalty", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.edgePenalty;}).method("jlopencv_CirclesGridFinderParameters_get_convexHullFactor", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.convexHullFactor;}).method("jlopencv_CirclesGridFinderParameters_get_minRNGEdgeSwitchDist", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.minRNGEdgeSwitchDist;}).method("jlopencv_CirclesGridFinderParameters_get_squareSize", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.squareSize;}).method("jlopencv_CirclesGridFinderParameters_get_maxRectifiedDistance", [](const cv::CirclesGridFinderParameters &cobj) {return cobj.maxRectifiedDistance;})
	 function Base.getproperty(m::CirclesGridFinderParameters, s::Symbol)
    if s==:densityNeighborhoodSize
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_densityNeighborhoodSize(m))
    end
    if s==:minDensity
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_minDensity(m))
    end
    if s==:kmeansAttempts
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_kmeansAttempts(m))
    end
    if s==:minDistanceToAddKeypoint
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_minDistanceToAddKeypoint(m))
    end
    if s==:keypointScale
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_keypointScale(m))
    end
    if s==:minGraphConfidence
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_minGraphConfidence(m))
    end
    if s==:vertexGain
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_vertexGain(m))
    end
    if s==:vertexPenalty
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_vertexPenalty(m))
    end
    if s==:existingVertexGain
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_existingVertexGain(m))
    end
    if s==:edgeGain
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_edgeGain(m))
    end
    if s==:edgePenalty
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_edgePenalty(m))
    end
    if s==:convexHullFactor
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_convexHullFactor(m))
    end
    if s==:minRNGEdgeSwitchDist
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_minRNGEdgeSwitchDist(m))
    end
    if s==:squareSize
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_squareSize(m))
    end
    if s==:maxRectifiedDistance
        return jlopencv_argconvert_jl(jlopencv_CirclesGridFinderParameters_get_maxRectifiedDistance(m))
    end
    return Base.getfield(m, s)
end
function Base.setproperty!(m::CirclesGridFinderParameters, s::Symbol, v)
    if s==:densityNeighborhoodSize
        jlopencv_CirclesGridFinderParameters_set_densityNeighborhoodSize(m, jlopencv_argconvert_cpp(v))
    end
    if s==:minDensity
        jlopencv_CirclesGridFinderParameters_set_minDensity(m, jlopencv_argconvert_cpp(v))
    end
    if s==:kmeansAttempts
        jlopencv_CirclesGridFinderParameters_set_kmeansAttempts(m, jlopencv_argconvert_cpp(v))
    end
    if s==:minDistanceToAddKeypoint
        jlopencv_CirclesGridFinderParameters_set_minDistanceToAddKeypoint(m, jlopencv_argconvert_cpp(v))
    end
    if s==:keypointScale
        jlopencv_CirclesGridFinderParameters_set_keypointScale(m, jlopencv_argconvert_cpp(v))
    end
    if s==:minGraphConfidence
        jlopencv_CirclesGridFinderParameters_set_minGraphConfidence(m, jlopencv_argconvert_cpp(v))
    end
    if s==:vertexGain
        jlopencv_CirclesGridFinderParameters_set_vertexGain(m, jlopencv_argconvert_cpp(v))
    end
    if s==:vertexPenalty
        jlopencv_CirclesGridFinderParameters_set_vertexPenalty(m, jlopencv_argconvert_cpp(v))
    end
    if s==:existingVertexGain
        jlopencv_CirclesGridFinderParameters_set_existingVertexGain(m, jlopencv_argconvert_cpp(v))
    end
    if s==:edgeGain
        jlopencv_CirclesGridFinderParameters_set_edgeGain(m, jlopencv_argconvert_cpp(v))
    end
    if s==:edgePenalty
        jlopencv_CirclesGridFinderParameters_set_edgePenalty(m, jlopencv_argconvert_cpp(v))
    end
    if s==:convexHullFactor
        jlopencv_CirclesGridFinderParameters_set_convexHullFactor(m, jlopencv_argconvert_cpp(v))
    end
    if s==:minRNGEdgeSwitchDist
        jlopencv_CirclesGridFinderParameters_set_minRNGEdgeSwitchDist(m, jlopencv_argconvert_cpp(v))
    end
    if s==:squareSize
        jlopencv_CirclesGridFinderParameters_set_squareSize(m, jlopencv_argconvert_cpp(v))
    end
    if s==:maxRectifiedDistance
        jlopencv_CirclesGridFinderParameters_set_maxRectifiedDistance(m, jlopencv_argconvert_cpp(v))
    end
    return Base.setfield(m, s, v)
end

	 StereoMatcher True
		 compute
		 .method("jlopencv_cv_StereoMatcher_compute",  [](cv::Ptr<StereoMatcher> &cobj, Mat &left, Mat &right, Mat &disparity) { cobj->compute(left, right, disparity);  return disparity;})
		 compute(left::Mat, right::Mat; disparity::Mat) -> ( disparity::Mat ) 
		 compute
		 .method("jlopencv_cv_StereoMatcher_compute",  [](cv::Ptr<StereoMatcher> &cobj, UMat &left, UMat &right, UMat &disparity) { cobj->compute(left, right, disparity);  return disparity;})
		 compute(left::UMat, right::UMat; disparity::UMat) -> ( disparity::UMat ) 
		 getMinDisparity
		 .method("jlopencv_cv_StereoMatcher_getMinDisparity",  [](cv::Ptr<StereoMatcher> &cobj) { auto retval = cobj->getMinDisparity();  return retval;})
		 getMinDisparity() -> ( retval::int ) 
		 setMinDisparity
		 .method("jlopencv_cv_StereoMatcher_setMinDisparity",  [](cv::Ptr<StereoMatcher> &cobj, int &minDisparity) { cobj->setMinDisparity(minDisparity);  ;})
		 setMinDisparity(minDisparity::int) -> nothing
		 getNumDisparities
		 .method("jlopencv_cv_StereoMatcher_getNumDisparities",  [](cv::Ptr<StereoMatcher> &cobj) { auto retval = cobj->getNumDisparities();  return retval;})
		 getNumDisparities() -> ( retval::int ) 
		 setNumDisparities
		 .method("jlopencv_cv_StereoMatcher_setNumDisparities",  [](cv::Ptr<StereoMatcher> &cobj, int &numDisparities) { cobj->setNumDisparities(numDisparities);  ;})
		 setNumDisparities(numDisparities::int) -> nothing
		 getBlockSize
		 .method("jlopencv_cv_StereoMatcher_getBlockSize",  [](cv::Ptr<StereoMatcher> &cobj) { auto retval = cobj->getBlockSize();  return retval;})
		 getBlockSize() -> ( retval::int ) 
		 setBlockSize
		 .method("jlopencv_cv_StereoMatcher_setBlockSize",  [](cv::Ptr<StereoMatcher> &cobj, int &blockSize) { cobj->setBlockSize(blockSize);  ;})
		 setBlockSize(blockSize::int) -> nothing
		 getSpeckleWindowSize
		 .method("jlopencv_cv_StereoMatcher_getSpeckleWindowSize",  [](cv::Ptr<StereoMatcher> &cobj) { auto retval = cobj->getSpeckleWindowSize();  return retval;})
		 getSpeckleWindowSize() -> ( retval::int ) 
		 setSpeckleWindowSize
		 .method("jlopencv_cv_StereoMatcher_setSpeckleWindowSize",  [](cv::Ptr<StereoMatcher> &cobj, int &speckleWindowSize) { cobj->setSpeckleWindowSize(speckleWindowSize);  ;})
		 setSpeckleWindowSize(speckleWindowSize::int) -> nothing
		 getSpeckleRange
		 .method("jlopencv_cv_StereoMatcher_getSpeckleRange",  [](cv::Ptr<StereoMatcher> &cobj) { auto retval = cobj->getSpeckleRange();  return retval;})
		 getSpeckleRange() -> ( retval::int ) 
		 setSpeckleRange
		 .method("jlopencv_cv_StereoMatcher_setSpeckleRange",  [](cv::Ptr<StereoMatcher> &cobj, int &speckleRange) { cobj->setSpeckleRange(speckleRange);  ;})
		 setSpeckleRange(speckleRange::int) -> nothing
		 getDisp12MaxDiff
		 .method("jlopencv_cv_StereoMatcher_getDisp12MaxDiff",  [](cv::Ptr<StereoMatcher> &cobj) { auto retval = cobj->getDisp12MaxDiff();  return retval;})
		 getDisp12MaxDiff() -> ( retval::int ) 
		 setDisp12MaxDiff
		 .method("jlopencv_cv_StereoMatcher_setDisp12MaxDiff",  [](cv::Ptr<StereoMatcher> &cobj, int &disp12MaxDiff) { cobj->setDisp12MaxDiff(disp12MaxDiff);  ;})
		 setDisp12MaxDiff(disp12MaxDiff::int) -> nothing
	 WIP
	 function Base.getproperty(m::StereoMatcher, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::StereoMatcher, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 StereoBM True
		 getPreFilterType
		 .method("jlopencv_cv_StereoBM_getPreFilterType",  [](cv::Ptr<StereoBM> &cobj) { auto retval = cobj->getPreFilterType();  return retval;})
		 getPreFilterType() -> ( retval::int ) 
		 setPreFilterType
		 .method("jlopencv_cv_StereoBM_setPreFilterType",  [](cv::Ptr<StereoBM> &cobj, int &preFilterType) { cobj->setPreFilterType(preFilterType);  ;})
		 setPreFilterType(preFilterType::int) -> nothing
		 getPreFilterSize
		 .method("jlopencv_cv_StereoBM_getPreFilterSize",  [](cv::Ptr<StereoBM> &cobj) { auto retval = cobj->getPreFilterSize();  return retval;})
		 getPreFilterSize() -> ( retval::int ) 
		 setPreFilterSize
		 .method("jlopencv_cv_StereoBM_setPreFilterSize",  [](cv::Ptr<StereoBM> &cobj, int &preFilterSize) { cobj->setPreFilterSize(preFilterSize);  ;})
		 setPreFilterSize(preFilterSize::int) -> nothing
		 getPreFilterCap
		 .method("jlopencv_cv_StereoBM_getPreFilterCap",  [](cv::Ptr<StereoBM> &cobj) { auto retval = cobj->getPreFilterCap();  return retval;})
		 getPreFilterCap() -> ( retval::int ) 
		 setPreFilterCap
		 .method("jlopencv_cv_StereoBM_setPreFilterCap",  [](cv::Ptr<StereoBM> &cobj, int &preFilterCap) { cobj->setPreFilterCap(preFilterCap);  ;})
		 setPreFilterCap(preFilterCap::int) -> nothing
		 getTextureThreshold
		 .method("jlopencv_cv_StereoBM_getTextureThreshold",  [](cv::Ptr<StereoBM> &cobj) { auto retval = cobj->getTextureThreshold();  return retval;})
		 getTextureThreshold() -> ( retval::int ) 
		 setTextureThreshold
		 .method("jlopencv_cv_StereoBM_setTextureThreshold",  [](cv::Ptr<StereoBM> &cobj, int &textureThreshold) { cobj->setTextureThreshold(textureThreshold);  ;})
		 setTextureThreshold(textureThreshold::int) -> nothing
		 getUniquenessRatio
		 .method("jlopencv_cv_StereoBM_getUniquenessRatio",  [](cv::Ptr<StereoBM> &cobj) { auto retval = cobj->getUniquenessRatio();  return retval;})
		 getUniquenessRatio() -> ( retval::int ) 
		 setUniquenessRatio
		 .method("jlopencv_cv_StereoBM_setUniquenessRatio",  [](cv::Ptr<StereoBM> &cobj, int &uniquenessRatio) { cobj->setUniquenessRatio(uniquenessRatio);  ;})
		 setUniquenessRatio(uniquenessRatio::int) -> nothing
		 getSmallerBlockSize
		 .method("jlopencv_cv_StereoBM_getSmallerBlockSize",  [](cv::Ptr<StereoBM> &cobj) { auto retval = cobj->getSmallerBlockSize();  return retval;})
		 getSmallerBlockSize() -> ( retval::int ) 
		 setSmallerBlockSize
		 .method("jlopencv_cv_StereoBM_setSmallerBlockSize",  [](cv::Ptr<StereoBM> &cobj, int &blockSize) { cobj->setSmallerBlockSize(blockSize);  ;})
		 setSmallerBlockSize(blockSize::int) -> nothing
		 getROI1
		 .method("jlopencv_cv_StereoBM_getROI1",  [](cv::Ptr<StereoBM> &cobj) { auto retval = cobj->getROI1();  return retval;})
		 getROI1() -> ( retval::Rect ) 
		 setROI1
		 .method("jlopencv_cv_StereoBM_setROI1",  [](cv::Ptr<StereoBM> &cobj, Rect &roi1) { cobj->setROI1(roi1);  ;})
		 setROI1(roi1::Rect) -> nothing
		 getROI2
		 .method("jlopencv_cv_StereoBM_getROI2",  [](cv::Ptr<StereoBM> &cobj) { auto retval = cobj->getROI2();  return retval;})
		 getROI2() -> ( retval::Rect ) 
		 setROI2
		 .method("jlopencv_cv_StereoBM_setROI2",  [](cv::Ptr<StereoBM> &cobj, Rect &roi2) { cobj->setROI2(roi2);  ;})
		 setROI2(roi2::Rect) -> nothing
		 create
		 .method("jlopencv_cv_StereoBM_create",  [](cv::Ptr<StereoBM> &cobj, int &numDisparities, int &blockSize) { auto retval = cv::StereoBM::create(numDisparities, blockSize); return retval;})
		 create(numDisparities::int, blockSize::int) -> ( retval::Ptr<StereoBM> ) 
	 WIP
	 function Base.getproperty(m::StereoBM, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::StereoBM, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 StereoSGBM True
		 getPreFilterCap
		 .method("jlopencv_cv_StereoSGBM_getPreFilterCap",  [](cv::Ptr<StereoSGBM> &cobj) { auto retval = cobj->getPreFilterCap();  return retval;})
		 getPreFilterCap() -> ( retval::int ) 
		 setPreFilterCap
		 .method("jlopencv_cv_StereoSGBM_setPreFilterCap",  [](cv::Ptr<StereoSGBM> &cobj, int &preFilterCap) { cobj->setPreFilterCap(preFilterCap);  ;})
		 setPreFilterCap(preFilterCap::int) -> nothing
		 getUniquenessRatio
		 .method("jlopencv_cv_StereoSGBM_getUniquenessRatio",  [](cv::Ptr<StereoSGBM> &cobj) { auto retval = cobj->getUniquenessRatio();  return retval;})
		 getUniquenessRatio() -> ( retval::int ) 
		 setUniquenessRatio
		 .method("jlopencv_cv_StereoSGBM_setUniquenessRatio",  [](cv::Ptr<StereoSGBM> &cobj, int &uniquenessRatio) { cobj->setUniquenessRatio(uniquenessRatio);  ;})
		 setUniquenessRatio(uniquenessRatio::int) -> nothing
		 getP1
		 .method("jlopencv_cv_StereoSGBM_getP1",  [](cv::Ptr<StereoSGBM> &cobj) { auto retval = cobj->getP1();  return retval;})
		 getP1() -> ( retval::int ) 
		 setP1
		 .method("jlopencv_cv_StereoSGBM_setP1",  [](cv::Ptr<StereoSGBM> &cobj, int &P1) { cobj->setP1(P1);  ;})
		 setP1(P1::int) -> nothing
		 getP2
		 .method("jlopencv_cv_StereoSGBM_getP2",  [](cv::Ptr<StereoSGBM> &cobj) { auto retval = cobj->getP2();  return retval;})
		 getP2() -> ( retval::int ) 
		 setP2
		 .method("jlopencv_cv_StereoSGBM_setP2",  [](cv::Ptr<StereoSGBM> &cobj, int &P2) { cobj->setP2(P2);  ;})
		 setP2(P2::int) -> nothing
		 getMode
		 .method("jlopencv_cv_StereoSGBM_getMode",  [](cv::Ptr<StereoSGBM> &cobj) { auto retval = cobj->getMode();  return retval;})
		 getMode() -> ( retval::int ) 
		 setMode
		 .method("jlopencv_cv_StereoSGBM_setMode",  [](cv::Ptr<StereoSGBM> &cobj, int &mode) { cobj->setMode(mode);  ;})
		 setMode(mode::int) -> nothing
		 create
		 .method("jlopencv_cv_StereoSGBM_create",  [](cv::Ptr<StereoSGBM> &cobj, int &minDisparity, int &numDisparities, int &blockSize, int &P1, int &P2, int &disp12MaxDiff, int &preFilterCap, int &uniquenessRatio, int &speckleWindowSize, int &speckleRange, int &mode) { auto retval = cv::StereoSGBM::create(minDisparity, numDisparities, blockSize, P1, P2, disp12MaxDiff, preFilterCap, uniquenessRatio, speckleWindowSize, speckleRange, mode); return retval;})
		 create(minDisparity::int, numDisparities::int, blockSize::int, P1::int, P2::int, disp12MaxDiff::int, preFilterCap::int, uniquenessRatio::int, speckleWindowSize::int, speckleRange::int, mode::int) -> ( retval::Ptr<StereoSGBM> ) 
	 WIP
	 function Base.getproperty(m::StereoSGBM, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::StereoSGBM, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 Feature2D True
		 detect
		 .method("jlopencv_cv_Feature2D_detect",  [](cv::Ptr<Feature2D> &cobj, Mat &image, Mat &mask) {vector<KeyPoint> keypoints; cobj->detect(image, keypoints, mask);  return keypoints;})
		 detect(image::Mat, mask::Mat) -> ( keypoints::vector<KeyPoint> ) 
		 detect
		 .method("jlopencv_cv_Feature2D_detect",  [](cv::Ptr<Feature2D> &cobj, UMat &image, UMat &mask) {vector<KeyPoint> keypoints; cobj->detect(image, keypoints, mask);  return keypoints;})
		 detect(image::UMat, mask::UMat) -> ( keypoints::vector<KeyPoint> ) 
		 detect
		 .method("jlopencv_cv_Feature2D_detect",  [](cv::Ptr<Feature2D> &cobj, vector<Mat> &images, vector<Mat> &masks) {vector<vector<KeyPoint>> keypoints; cobj->detect(images, keypoints, masks);  return keypoints;})
		 detect(images::vector<Mat>, masks::vector<Mat>) -> ( keypoints::vector<vector<KeyPoint>> ) 
		 detect
		 .method("jlopencv_cv_Feature2D_detect",  [](cv::Ptr<Feature2D> &cobj, vector<UMat> &images, vector<UMat> &masks) {vector<vector<KeyPoint>> keypoints; cobj->detect(images, keypoints, masks);  return keypoints;})
		 detect(images::vector<UMat>, masks::vector<UMat>) -> ( keypoints::vector<vector<KeyPoint>> ) 
		 compute
		 .method("jlopencv_cv_Feature2D_compute",  [](cv::Ptr<Feature2D> &cobj, Mat &image, vector<KeyPoint> &keypoints, Mat &descriptors) { cobj->compute(image, keypoints, descriptors);  return make_tuple<vector<KeyPoint>,Mat>(keypoints,descriptors);})
		 compute(image::Mat, keypoints::vector<KeyPoint>; descriptors::Mat) -> ( keypoints::vector<KeyPoint>, descriptors::Mat ) 
		 compute
		 .method("jlopencv_cv_Feature2D_compute",  [](cv::Ptr<Feature2D> &cobj, UMat &image, vector<KeyPoint> &keypoints, UMat &descriptors) { cobj->compute(image, keypoints, descriptors);  return make_tuple<vector<KeyPoint>,UMat>(keypoints,descriptors);})
		 compute(image::UMat, keypoints::vector<KeyPoint>; descriptors::UMat) -> ( keypoints::vector<KeyPoint>, descriptors::UMat ) 
		 compute
		 .method("jlopencv_cv_Feature2D_compute",  [](cv::Ptr<Feature2D> &cobj, vector<Mat> &images, vector<vector<KeyPoint>> &keypoints) {vector<Mat> descriptors; cobj->compute(images, keypoints, descriptors);  return make_tuple<vector<vector<KeyPoint>>,vector<Mat>>(keypoints,descriptors);})
		 compute(images::vector<Mat>, keypoints::vector<vector<KeyPoint>>) -> ( keypoints::vector<vector<KeyPoint>>, descriptors::vector<Mat> ) 
		 compute
		 .method("jlopencv_cv_Feature2D_compute",  [](cv::Ptr<Feature2D> &cobj, vector<UMat> &images, vector<vector<KeyPoint>> &keypoints) {vector<UMat> descriptors; cobj->compute(images, keypoints, descriptors);  return make_tuple<vector<vector<KeyPoint>>,vector<UMat>>(keypoints,descriptors);})
		 compute(images::vector<UMat>, keypoints::vector<vector<KeyPoint>>) -> ( keypoints::vector<vector<KeyPoint>>, descriptors::vector<UMat> ) 
		 detectAndCompute
		 .method("jlopencv_cv_Feature2D_detectAndCompute",  [](cv::Ptr<Feature2D> &cobj, Mat &image, Mat &mask, Mat &descriptors, bool &useProvidedKeypoints) {vector<KeyPoint> keypoints; cobj->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints);  return make_tuple<vector<KeyPoint>,Mat>(keypoints,descriptors);})
		 detectAndCompute(image::Mat, mask::Mat, descriptors::Mat, useProvidedKeypoints::bool) -> ( keypoints::vector<KeyPoint>, descriptors::Mat ) 
		 detectAndCompute
		 .method("jlopencv_cv_Feature2D_detectAndCompute",  [](cv::Ptr<Feature2D> &cobj, UMat &image, UMat &mask, UMat &descriptors, bool &useProvidedKeypoints) {vector<KeyPoint> keypoints; cobj->detectAndCompute(image, mask, keypoints, descriptors, useProvidedKeypoints);  return make_tuple<vector<KeyPoint>,UMat>(keypoints,descriptors);})
		 detectAndCompute(image::UMat, mask::UMat, descriptors::UMat, useProvidedKeypoints::bool) -> ( keypoints::vector<KeyPoint>, descriptors::UMat ) 
		 descriptorSize
		 .method("jlopencv_cv_Feature2D_descriptorSize",  [](cv::Ptr<Feature2D> &cobj) { auto retval = cobj->descriptorSize();  return retval;})
		 descriptorSize() -> ( retval::int ) 
		 descriptorType
		 .method("jlopencv_cv_Feature2D_descriptorType",  [](cv::Ptr<Feature2D> &cobj) { auto retval = cobj->descriptorType();  return retval;})
		 descriptorType() -> ( retval::int ) 
		 defaultNorm
		 .method("jlopencv_cv_Feature2D_defaultNorm",  [](cv::Ptr<Feature2D> &cobj) { auto retval = cobj->defaultNorm();  return retval;})
		 defaultNorm() -> ( retval::int ) 
		 write
		 .method("jlopencv_cv_Feature2D_write",  [](cv::Ptr<Feature2D> &cobj, String &fileName) { cobj->write(fileName);  ;})
		 write(fileName::String) -> nothing
		 write
		 .method("jlopencv_cv_Feature2D_write",  [](cv::Ptr<Feature2D> &cobj, Ptr<FileStorage> &fs, String &name) { cobj->write(fs, name);  ;})
		 write(fs::Ptr<FileStorage>, name::String) -> nothing
		 read
		 .method("jlopencv_cv_Feature2D_read",  [](cv::Ptr<Feature2D> &cobj, String &fileName) { cobj->read(fileName);  ;})
		 read(fileName::String) -> nothing
		 read
		 .method("jlopencv_cv_Feature2D_read",  [](cv::Ptr<Feature2D> &cobj, FileNode &arg1) { cobj->read(arg1);  ;})
		 read(arg1::FileNode) -> nothing
		 empty
		 .method("jlopencv_cv_Feature2D_empty",  [](cv::Ptr<Feature2D> &cobj) { auto retval = cobj->empty();  return retval;})
		 empty() -> ( retval::bool ) 
		 getDefaultName
		 .method("jlopencv_cv_Feature2D_getDefaultName",  [](cv::Ptr<Feature2D> &cobj) { auto retval = cobj->getDefaultName();  return retval;})
		 getDefaultName() -> ( retval::String ) 
	 WIP
	 function Base.getproperty(m::Feature2D, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::Feature2D, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 BRISK True
		 create
		 .method("jlopencv_cv_BRISK_create",  [](cv::Ptr<BRISK> &cobj, int &thresh, int &octaves, float &patternScale) { auto retval = cv::BRISK::create(thresh, octaves, patternScale); return retval;})
		 create(thresh::int, octaves::int, patternScale::float) -> ( retval::Ptr<BRISK> ) 
		 create
		 .method("jlopencv_cv_BRISK_create",  [](cv::Ptr<BRISK> &cobj, vector<float> &radiusList, vector<int> &numberList, float &dMax, float &dMin, vector<int> &indexChange) { auto retval = cv::BRISK::create(radiusList, numberList, dMax, dMin, indexChange); return retval;})
		 create(radiusList::vector<float>, numberList::vector<int>, dMax::float, dMin::float, indexChange::vector<int>) -> ( retval::Ptr<BRISK> ) 
		 create
		 .method("jlopencv_cv_BRISK_create",  [](cv::Ptr<BRISK> &cobj, int &thresh, int &octaves, vector<float> &radiusList, vector<int> &numberList, float &dMax, float &dMin, vector<int> &indexChange) { auto retval = cv::BRISK::create(thresh, octaves, radiusList, numberList, dMax, dMin, indexChange); return retval;})
		 create(thresh::int, octaves::int, radiusList::vector<float>, numberList::vector<int>, dMax::float, dMin::float, indexChange::vector<int>) -> ( retval::Ptr<BRISK> ) 
		 getDefaultName
		 .method("jlopencv_cv_BRISK_getDefaultName",  [](cv::Ptr<BRISK> &cobj) { auto retval = cobj->getDefaultName();  return retval;})
		 getDefaultName() -> ( retval::String ) 
		 setThreshold
		 .method("jlopencv_cv_BRISK_setThreshold",  [](cv::Ptr<BRISK> &cobj, int &threshold) { cobj->setThreshold(threshold);  ;})
		 setThreshold(threshold::int) -> nothing
		 getThreshold
		 .method("jlopencv_cv_BRISK_getThreshold",  [](cv::Ptr<BRISK> &cobj) { auto retval = cobj->getThreshold();  return retval;})
		 getThreshold() -> ( retval::int ) 
		 setOctaves
		 .method("jlopencv_cv_BRISK_setOctaves",  [](cv::Ptr<BRISK> &cobj, int &octaves) { cobj->setOctaves(octaves);  ;})
		 setOctaves(octaves::int) -> nothing
		 getOctaves
		 .method("jlopencv_cv_BRISK_getOctaves",  [](cv::Ptr<BRISK> &cobj) { auto retval = cobj->getOctaves();  return retval;})
		 getOctaves() -> ( retval::int ) 
	 WIP
	 function Base.getproperty(m::BRISK, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::BRISK, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 ORB True
		 create
		 .method("jlopencv_cv_ORB_create",  [](cv::Ptr<ORB> &cobj, int &nfeatures, float &scaleFactor, int &nlevels, int &edgeThreshold, int &firstLevel, int &WTA_K, ORB_ScoreType &scoreType, int &patchSize, int &fastThreshold) { auto retval = cv::ORB::create(nfeatures, scaleFactor, nlevels, edgeThreshold, firstLevel, WTA_K, scoreType, patchSize, fastThreshold); return retval;})
		 create(nfeatures::int, scaleFactor::float, nlevels::int, edgeThreshold::int, firstLevel::int, WTA_K::int, scoreType::ORB_ScoreType, patchSize::int, fastThreshold::int) -> ( retval::Ptr<ORB> ) 
		 setMaxFeatures
		 .method("jlopencv_cv_ORB_setMaxFeatures",  [](cv::Ptr<ORB> &cobj, int &maxFeatures) { cobj->setMaxFeatures(maxFeatures);  ;})
		 setMaxFeatures(maxFeatures::int) -> nothing
		 getMaxFeatures
		 .method("jlopencv_cv_ORB_getMaxFeatures",  [](cv::Ptr<ORB> &cobj) { auto retval = cobj->getMaxFeatures();  return retval;})
		 getMaxFeatures() -> ( retval::int ) 
		 setScaleFactor
		 .method("jlopencv_cv_ORB_setScaleFactor",  [](cv::Ptr<ORB> &cobj, double &scaleFactor) { cobj->setScaleFactor(scaleFactor);  ;})
		 setScaleFactor(scaleFactor::double) -> nothing
		 getScaleFactor
		 .method("jlopencv_cv_ORB_getScaleFactor",  [](cv::Ptr<ORB> &cobj) { auto retval = cobj->getScaleFactor();  return retval;})
		 getScaleFactor() -> ( retval::double ) 
		 setNLevels
		 .method("jlopencv_cv_ORB_setNLevels",  [](cv::Ptr<ORB> &cobj, int &nlevels) { cobj->setNLevels(nlevels);  ;})
		 setNLevels(nlevels::int) -> nothing
		 getNLevels
		 .method("jlopencv_cv_ORB_getNLevels",  [](cv::Ptr<ORB> &cobj) { auto retval = cobj->getNLevels();  return retval;})
		 getNLevels() -> ( retval::int ) 
		 setEdgeThreshold
		 .method("jlopencv_cv_ORB_setEdgeThreshold",  [](cv::Ptr<ORB> &cobj, int &edgeThreshold) { cobj->setEdgeThreshold(edgeThreshold);  ;})
		 setEdgeThreshold(edgeThreshold::int) -> nothing
		 getEdgeThreshold
		 .method("jlopencv_cv_ORB_getEdgeThreshold",  [](cv::Ptr<ORB> &cobj) { auto retval = cobj->getEdgeThreshold();  return retval;})
		 getEdgeThreshold() -> ( retval::int ) 
		 setFirstLevel
		 .method("jlopencv_cv_ORB_setFirstLevel",  [](cv::Ptr<ORB> &cobj, int &firstLevel) { cobj->setFirstLevel(firstLevel);  ;})
		 setFirstLevel(firstLevel::int) -> nothing
		 getFirstLevel
		 .method("jlopencv_cv_ORB_getFirstLevel",  [](cv::Ptr<ORB> &cobj) { auto retval = cobj->getFirstLevel();  return retval;})
		 getFirstLevel() -> ( retval::int ) 
		 setWTA_K
		 .method("jlopencv_cv_ORB_setWTA_K",  [](cv::Ptr<ORB> &cobj, int &wta_k) { cobj->setWTA_K(wta_k);  ;})
		 setWTA_K(wta_k::int) -> nothing
		 getWTA_K
		 .method("jlopencv_cv_ORB_getWTA_K",  [](cv::Ptr<ORB> &cobj) { auto retval = cobj->getWTA_K();  return retval;})
		 getWTA_K() -> ( retval::int ) 
		 setScoreType
		 .method("jlopencv_cv_ORB_setScoreType",  [](cv::Ptr<ORB> &cobj, ORB_ScoreType &scoreType) { cobj->setScoreType(scoreType);  ;})
		 setScoreType(scoreType::ORB_ScoreType) -> nothing
		 getScoreType
		 .method("jlopencv_cv_ORB_getScoreType",  [](cv::Ptr<ORB> &cobj) { auto retval = cobj->getScoreType();  return retval;})
		 getScoreType() -> ( retval::ORB::ScoreType ) 
		 setPatchSize
		 .method("jlopencv_cv_ORB_setPatchSize",  [](cv::Ptr<ORB> &cobj, int &patchSize) { cobj->setPatchSize(patchSize);  ;})
		 setPatchSize(patchSize::int) -> nothing
		 getPatchSize
		 .method("jlopencv_cv_ORB_getPatchSize",  [](cv::Ptr<ORB> &cobj) { auto retval = cobj->getPatchSize();  return retval;})
		 getPatchSize() -> ( retval::int ) 
		 setFastThreshold
		 .method("jlopencv_cv_ORB_setFastThreshold",  [](cv::Ptr<ORB> &cobj, int &fastThreshold) { cobj->setFastThreshold(fastThreshold);  ;})
		 setFastThreshold(fastThreshold::int) -> nothing
		 getFastThreshold
		 .method("jlopencv_cv_ORB_getFastThreshold",  [](cv::Ptr<ORB> &cobj) { auto retval = cobj->getFastThreshold();  return retval;})
		 getFastThreshold() -> ( retval::int ) 
		 getDefaultName
		 .method("jlopencv_cv_ORB_getDefaultName",  [](cv::Ptr<ORB> &cobj) { auto retval = cobj->getDefaultName();  return retval;})
		 getDefaultName() -> ( retval::String ) 
	 WIP
	 function Base.getproperty(m::ORB, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ORB, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 MSER True
		 create
		 .method("jlopencv_cv_MSER_create",  [](cv::Ptr<MSER> &cobj, int &_delta, int &_min_area, int &_max_area, double &_max_variation, double &_min_diversity, int &_max_evolution, double &_area_threshold, double &_min_margin, int &_edge_blur_size) { auto retval = cv::MSER::create(_delta, _min_area, _max_area, _max_variation, _min_diversity, _max_evolution, _area_threshold, _min_margin, _edge_blur_size); return retval;})
		 create(_delta::int, _min_area::int, _max_area::int, _max_variation::double, _min_diversity::double, _max_evolution::int, _area_threshold::double, _min_margin::double, _edge_blur_size::int) -> ( retval::Ptr<MSER> ) 
		 detectRegions
		 .method("jlopencv_cv_MSER_detectRegions",  [](cv::Ptr<MSER> &cobj, Mat &image) {vector<vector<Point>> msers;vector<Rect> bboxes; cobj->detectRegions(image, msers, bboxes);  return make_tuple<vector<vector<Point>>,vector<Rect>>(msers,bboxes);})
		 detectRegions(image::Mat) -> ( msers::vector<vector<Point>>, bboxes::vector<Rect> ) 
		 detectRegions
		 .method("jlopencv_cv_MSER_detectRegions",  [](cv::Ptr<MSER> &cobj, UMat &image) {vector<vector<Point>> msers;vector<Rect> bboxes; cobj->detectRegions(image, msers, bboxes);  return make_tuple<vector<vector<Point>>,vector<Rect>>(msers,bboxes);})
		 detectRegions(image::UMat) -> ( msers::vector<vector<Point>>, bboxes::vector<Rect> ) 
		 setDelta
		 .method("jlopencv_cv_MSER_setDelta",  [](cv::Ptr<MSER> &cobj, int &delta) { cobj->setDelta(delta);  ;})
		 setDelta(delta::int) -> nothing
		 getDelta
		 .method("jlopencv_cv_MSER_getDelta",  [](cv::Ptr<MSER> &cobj) { auto retval = cobj->getDelta();  return retval;})
		 getDelta() -> ( retval::int ) 
		 setMinArea
		 .method("jlopencv_cv_MSER_setMinArea",  [](cv::Ptr<MSER> &cobj, int &minArea) { cobj->setMinArea(minArea);  ;})
		 setMinArea(minArea::int) -> nothing
		 getMinArea
		 .method("jlopencv_cv_MSER_getMinArea",  [](cv::Ptr<MSER> &cobj) { auto retval = cobj->getMinArea();  return retval;})
		 getMinArea() -> ( retval::int ) 
		 setMaxArea
		 .method("jlopencv_cv_MSER_setMaxArea",  [](cv::Ptr<MSER> &cobj, int &maxArea) { cobj->setMaxArea(maxArea);  ;})
		 setMaxArea(maxArea::int) -> nothing
		 getMaxArea
		 .method("jlopencv_cv_MSER_getMaxArea",  [](cv::Ptr<MSER> &cobj) { auto retval = cobj->getMaxArea();  return retval;})
		 getMaxArea() -> ( retval::int ) 
		 setPass2Only
		 .method("jlopencv_cv_MSER_setPass2Only",  [](cv::Ptr<MSER> &cobj, bool &f) { cobj->setPass2Only(f);  ;})
		 setPass2Only(f::bool) -> nothing
		 getPass2Only
		 .method("jlopencv_cv_MSER_getPass2Only",  [](cv::Ptr<MSER> &cobj) { auto retval = cobj->getPass2Only();  return retval;})
		 getPass2Only() -> ( retval::bool ) 
		 getDefaultName
		 .method("jlopencv_cv_MSER_getDefaultName",  [](cv::Ptr<MSER> &cobj) { auto retval = cobj->getDefaultName();  return retval;})
		 getDefaultName() -> ( retval::String ) 
	 WIP
	 function Base.getproperty(m::MSER, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::MSER, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 FastFeatureDetector True
		 create
		 .method("jlopencv_cv_FastFeatureDetector_create",  [](cv::Ptr<FastFeatureDetector> &cobj, int &threshold, bool &nonmaxSuppression, FastFeatureDetector_DetectorType &type) { auto retval = cv::FastFeatureDetector::create(threshold, nonmaxSuppression, type); return retval;})
		 create(threshold::int, nonmaxSuppression::bool, type::FastFeatureDetector_DetectorType) -> ( retval::Ptr<FastFeatureDetector> ) 
		 setThreshold
		 .method("jlopencv_cv_FastFeatureDetector_setThreshold",  [](cv::Ptr<FastFeatureDetector> &cobj, int &threshold) { cobj->setThreshold(threshold);  ;})
		 setThreshold(threshold::int) -> nothing
		 getThreshold
		 .method("jlopencv_cv_FastFeatureDetector_getThreshold",  [](cv::Ptr<FastFeatureDetector> &cobj) { auto retval = cobj->getThreshold();  return retval;})
		 getThreshold() -> ( retval::int ) 
		 setNonmaxSuppression
		 .method("jlopencv_cv_FastFeatureDetector_setNonmaxSuppression",  [](cv::Ptr<FastFeatureDetector> &cobj, bool &f) { cobj->setNonmaxSuppression(f);  ;})
		 setNonmaxSuppression(f::bool) -> nothing
		 getNonmaxSuppression
		 .method("jlopencv_cv_FastFeatureDetector_getNonmaxSuppression",  [](cv::Ptr<FastFeatureDetector> &cobj) { auto retval = cobj->getNonmaxSuppression();  return retval;})
		 getNonmaxSuppression() -> ( retval::bool ) 
		 setType
		 .method("jlopencv_cv_FastFeatureDetector_setType",  [](cv::Ptr<FastFeatureDetector> &cobj, FastFeatureDetector_DetectorType &type) { cobj->setType(type);  ;})
		 setType(type::FastFeatureDetector_DetectorType) -> nothing
		 getType
		 .method("jlopencv_cv_FastFeatureDetector_getType",  [](cv::Ptr<FastFeatureDetector> &cobj) { auto retval = cobj->getType();  return retval;})
		 getType() -> ( retval::FastFeatureDetector::DetectorType ) 
		 getDefaultName
		 .method("jlopencv_cv_FastFeatureDetector_getDefaultName",  [](cv::Ptr<FastFeatureDetector> &cobj) { auto retval = cobj->getDefaultName();  return retval;})
		 getDefaultName() -> ( retval::String ) 
	 WIP
	 function Base.getproperty(m::FastFeatureDetector, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::FastFeatureDetector, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 AgastFeatureDetector True
		 create
		 .method("jlopencv_cv_AgastFeatureDetector_create",  [](cv::Ptr<AgastFeatureDetector> &cobj, int &threshold, bool &nonmaxSuppression, AgastFeatureDetector_DetectorType &type) { auto retval = cv::AgastFeatureDetector::create(threshold, nonmaxSuppression, type); return retval;})
		 create(threshold::int, nonmaxSuppression::bool, type::AgastFeatureDetector_DetectorType) -> ( retval::Ptr<AgastFeatureDetector> ) 
		 setThreshold
		 .method("jlopencv_cv_AgastFeatureDetector_setThreshold",  [](cv::Ptr<AgastFeatureDetector> &cobj, int &threshold) { cobj->setThreshold(threshold);  ;})
		 setThreshold(threshold::int) -> nothing
		 getThreshold
		 .method("jlopencv_cv_AgastFeatureDetector_getThreshold",  [](cv::Ptr<AgastFeatureDetector> &cobj) { auto retval = cobj->getThreshold();  return retval;})
		 getThreshold() -> ( retval::int ) 
		 setNonmaxSuppression
		 .method("jlopencv_cv_AgastFeatureDetector_setNonmaxSuppression",  [](cv::Ptr<AgastFeatureDetector> &cobj, bool &f) { cobj->setNonmaxSuppression(f);  ;})
		 setNonmaxSuppression(f::bool) -> nothing
		 getNonmaxSuppression
		 .method("jlopencv_cv_AgastFeatureDetector_getNonmaxSuppression",  [](cv::Ptr<AgastFeatureDetector> &cobj) { auto retval = cobj->getNonmaxSuppression();  return retval;})
		 getNonmaxSuppression() -> ( retval::bool ) 
		 setType
		 .method("jlopencv_cv_AgastFeatureDetector_setType",  [](cv::Ptr<AgastFeatureDetector> &cobj, AgastFeatureDetector_DetectorType &type) { cobj->setType(type);  ;})
		 setType(type::AgastFeatureDetector_DetectorType) -> nothing
		 getType
		 .method("jlopencv_cv_AgastFeatureDetector_getType",  [](cv::Ptr<AgastFeatureDetector> &cobj) { auto retval = cobj->getType();  return retval;})
		 getType() -> ( retval::AgastFeatureDetector::DetectorType ) 
		 getDefaultName
		 .method("jlopencv_cv_AgastFeatureDetector_getDefaultName",  [](cv::Ptr<AgastFeatureDetector> &cobj) { auto retval = cobj->getDefaultName();  return retval;})
		 getDefaultName() -> ( retval::String ) 
	 WIP
	 function Base.getproperty(m::AgastFeatureDetector, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::AgastFeatureDetector, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 GFTTDetector True
		 create
		 .method("jlopencv_cv_GFTTDetector_create",  [](cv::Ptr<GFTTDetector> &cobj, int &maxCorners, double &qualityLevel, double &minDistance, int &blockSize, bool &useHarrisDetector, double &k) { auto retval = cv::GFTTDetector::create(maxCorners, qualityLevel, minDistance, blockSize, useHarrisDetector, k); return retval;})
		 create(maxCorners::int, qualityLevel::double, minDistance::double, blockSize::int, useHarrisDetector::bool, k::double) -> ( retval::Ptr<GFTTDetector> ) 
		 create
		 .method("jlopencv_cv_GFTTDetector_create",  [](cv::Ptr<GFTTDetector> &cobj, int &maxCorners, double &qualityLevel, double &minDistance, int &blockSize, int &gradiantSize, bool &useHarrisDetector, double &k) { auto retval = cv::GFTTDetector::create(maxCorners, qualityLevel, minDistance, blockSize, gradiantSize, useHarrisDetector, k); return retval;})
		 create(maxCorners::int, qualityLevel::double, minDistance::double, blockSize::int, gradiantSize::int, useHarrisDetector::bool, k::double) -> ( retval::Ptr<GFTTDetector> ) 
		 setMaxFeatures
		 .method("jlopencv_cv_GFTTDetector_setMaxFeatures",  [](cv::Ptr<GFTTDetector> &cobj, int &maxFeatures) { cobj->setMaxFeatures(maxFeatures);  ;})
		 setMaxFeatures(maxFeatures::int) -> nothing
		 getMaxFeatures
		 .method("jlopencv_cv_GFTTDetector_getMaxFeatures",  [](cv::Ptr<GFTTDetector> &cobj) { auto retval = cobj->getMaxFeatures();  return retval;})
		 getMaxFeatures() -> ( retval::int ) 
		 setQualityLevel
		 .method("jlopencv_cv_GFTTDetector_setQualityLevel",  [](cv::Ptr<GFTTDetector> &cobj, double &qlevel) { cobj->setQualityLevel(qlevel);  ;})
		 setQualityLevel(qlevel::double) -> nothing
		 getQualityLevel
		 .method("jlopencv_cv_GFTTDetector_getQualityLevel",  [](cv::Ptr<GFTTDetector> &cobj) { auto retval = cobj->getQualityLevel();  return retval;})
		 getQualityLevel() -> ( retval::double ) 
		 setMinDistance
		 .method("jlopencv_cv_GFTTDetector_setMinDistance",  [](cv::Ptr<GFTTDetector> &cobj, double &minDistance) { cobj->setMinDistance(minDistance);  ;})
		 setMinDistance(minDistance::double) -> nothing
		 getMinDistance
		 .method("jlopencv_cv_GFTTDetector_getMinDistance",  [](cv::Ptr<GFTTDetector> &cobj) { auto retval = cobj->getMinDistance();  return retval;})
		 getMinDistance() -> ( retval::double ) 
		 setBlockSize
		 .method("jlopencv_cv_GFTTDetector_setBlockSize",  [](cv::Ptr<GFTTDetector> &cobj, int &blockSize) { cobj->setBlockSize(blockSize);  ;})
		 setBlockSize(blockSize::int) -> nothing
		 getBlockSize
		 .method("jlopencv_cv_GFTTDetector_getBlockSize",  [](cv::Ptr<GFTTDetector> &cobj) { auto retval = cobj->getBlockSize();  return retval;})
		 getBlockSize() -> ( retval::int ) 
		 setHarrisDetector
		 .method("jlopencv_cv_GFTTDetector_setHarrisDetector",  [](cv::Ptr<GFTTDetector> &cobj, bool &val) { cobj->setHarrisDetector(val);  ;})
		 setHarrisDetector(val::bool) -> nothing
		 getHarrisDetector
		 .method("jlopencv_cv_GFTTDetector_getHarrisDetector",  [](cv::Ptr<GFTTDetector> &cobj) { auto retval = cobj->getHarrisDetector();  return retval;})
		 getHarrisDetector() -> ( retval::bool ) 
		 setK
		 .method("jlopencv_cv_GFTTDetector_setK",  [](cv::Ptr<GFTTDetector> &cobj, double &k) { cobj->setK(k);  ;})
		 setK(k::double) -> nothing
		 getK
		 .method("jlopencv_cv_GFTTDetector_getK",  [](cv::Ptr<GFTTDetector> &cobj) { auto retval = cobj->getK();  return retval;})
		 getK() -> ( retval::double ) 
		 getDefaultName
		 .method("jlopencv_cv_GFTTDetector_getDefaultName",  [](cv::Ptr<GFTTDetector> &cobj) { auto retval = cobj->getDefaultName();  return retval;})
		 getDefaultName() -> ( retval::String ) 
	 WIP
	 function Base.getproperty(m::GFTTDetector, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::GFTTDetector, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 SimpleBlobDetector True
		 create
		 .method("jlopencv_cv_SimpleBlobDetector_create",  [](cv::Ptr<SimpleBlobDetector> &cobj, SimpleBlobDetector_Params &parameters) { auto retval = cv::SimpleBlobDetector::create(parameters); return retval;})
		 create(parameters::SimpleBlobDetector_Params) -> ( retval::Ptr<SimpleBlobDetector> ) 
		 getDefaultName
		 .method("jlopencv_cv_SimpleBlobDetector_getDefaultName",  [](cv::Ptr<SimpleBlobDetector> &cobj) { auto retval = cobj->getDefaultName();  return retval;})
		 getDefaultName() -> ( retval::String ) 
	 WIP
	 function Base.getproperty(m::SimpleBlobDetector, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::SimpleBlobDetector, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 SimpleBlobDetector_Params False
	 .add_type<cv::SimpleBlobDetector::Params>("SimpleBlobDetector_Params").method("jlopencv_SimpleBlobDetector_Params_set_thresholdStep", [](cv::SimpleBlobDetector::Params &cobj,const float &v) {cobj.thresholdStep=v;}).method("jlopencv_SimpleBlobDetector_Params_set_minThreshold", [](cv::SimpleBlobDetector::Params &cobj,const float &v) {cobj.minThreshold=v;}).method("jlopencv_SimpleBlobDetector_Params_set_maxThreshold", [](cv::SimpleBlobDetector::Params &cobj,const float &v) {cobj.maxThreshold=v;}).method("jlopencv_SimpleBlobDetector_Params_set_minRepeatability", [](cv::SimpleBlobDetector::Params &cobj,const size_t &v) {cobj.minRepeatability=v;}).method("jlopencv_SimpleBlobDetector_Params_set_minDistBetweenBlobs", [](cv::SimpleBlobDetector::Params &cobj,const float &v) {cobj.minDistBetweenBlobs=v;}).method("jlopencv_SimpleBlobDetector_Params_set_filterByColor", [](cv::SimpleBlobDetector::Params &cobj,const bool &v) {cobj.filterByColor=v;}).method("jlopencv_SimpleBlobDetector_Params_set_blobColor", [](cv::SimpleBlobDetector::Params &cobj,const uchar &v) {cobj.blobColor=v;}).method("jlopencv_SimpleBlobDetector_Params_set_filterByArea", [](cv::SimpleBlobDetector::Params &cobj,const bool &v) {cobj.filterByArea=v;}).method("jlopencv_SimpleBlobDetector_Params_set_minArea", [](cv::SimpleBlobDetector::Params &cobj,const float &v) {cobj.minArea=v;}).method("jlopencv_SimpleBlobDetector_Params_set_maxArea", [](cv::SimpleBlobDetector::Params &cobj,const float &v) {cobj.maxArea=v;}).method("jlopencv_SimpleBlobDetector_Params_set_filterByCircularity", [](cv::SimpleBlobDetector::Params &cobj,const bool &v) {cobj.filterByCircularity=v;}).method("jlopencv_SimpleBlobDetector_Params_set_minCircularity", [](cv::SimpleBlobDetector::Params &cobj,const float &v) {cobj.minCircularity=v;}).method("jlopencv_SimpleBlobDetector_Params_set_maxCircularity", [](cv::SimpleBlobDetector::Params &cobj,const float &v) {cobj.maxCircularity=v;}).method("jlopencv_SimpleBlobDetector_Params_set_filterByInertia", [](cv::SimpleBlobDetector::Params &cobj,const bool &v) {cobj.filterByInertia=v;}).method("jlopencv_SimpleBlobDetector_Params_set_minInertiaRatio", [](cv::SimpleBlobDetector::Params &cobj,const float &v) {cobj.minInertiaRatio=v;}).method("jlopencv_SimpleBlobDetector_Params_set_maxInertiaRatio", [](cv::SimpleBlobDetector::Params &cobj,const float &v) {cobj.maxInertiaRatio=v;}).method("jlopencv_SimpleBlobDetector_Params_set_filterByConvexity", [](cv::SimpleBlobDetector::Params &cobj,const bool &v) {cobj.filterByConvexity=v;}).method("jlopencv_SimpleBlobDetector_Params_set_minConvexity", [](cv::SimpleBlobDetector::Params &cobj,const float &v) {cobj.minConvexity=v;}).method("jlopencv_SimpleBlobDetector_Params_set_maxConvexity", [](cv::SimpleBlobDetector::Params &cobj,const float &v) {cobj.maxConvexity=v;}).method("jlopencv_SimpleBlobDetector_Params_get_thresholdStep", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.thresholdStep;}).method("jlopencv_SimpleBlobDetector_Params_get_minThreshold", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.minThreshold;}).method("jlopencv_SimpleBlobDetector_Params_get_maxThreshold", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.maxThreshold;}).method("jlopencv_SimpleBlobDetector_Params_get_minRepeatability", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.minRepeatability;}).method("jlopencv_SimpleBlobDetector_Params_get_minDistBetweenBlobs", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.minDistBetweenBlobs;}).method("jlopencv_SimpleBlobDetector_Params_get_filterByColor", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.filterByColor;}).method("jlopencv_SimpleBlobDetector_Params_get_blobColor", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.blobColor;}).method("jlopencv_SimpleBlobDetector_Params_get_filterByArea", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.filterByArea;}).method("jlopencv_SimpleBlobDetector_Params_get_minArea", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.minArea;}).method("jlopencv_SimpleBlobDetector_Params_get_maxArea", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.maxArea;}).method("jlopencv_SimpleBlobDetector_Params_get_filterByCircularity", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.filterByCircularity;}).method("jlopencv_SimpleBlobDetector_Params_get_minCircularity", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.minCircularity;}).method("jlopencv_SimpleBlobDetector_Params_get_maxCircularity", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.maxCircularity;}).method("jlopencv_SimpleBlobDetector_Params_get_filterByInertia", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.filterByInertia;}).method("jlopencv_SimpleBlobDetector_Params_get_minInertiaRatio", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.minInertiaRatio;}).method("jlopencv_SimpleBlobDetector_Params_get_maxInertiaRatio", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.maxInertiaRatio;}).method("jlopencv_SimpleBlobDetector_Params_get_filterByConvexity", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.filterByConvexity;}).method("jlopencv_SimpleBlobDetector_Params_get_minConvexity", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.minConvexity;}).method("jlopencv_SimpleBlobDetector_Params_get_maxConvexity", [](const cv::SimpleBlobDetector::Params &cobj) {return cobj.maxConvexity;})
	 function Base.getproperty(m::SimpleBlobDetector_Params, s::Symbol)
    if s==:thresholdStep
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_thresholdStep(m))
    end
    if s==:minThreshold
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_minThreshold(m))
    end
    if s==:maxThreshold
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_maxThreshold(m))
    end
    if s==:minRepeatability
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_minRepeatability(m))
    end
    if s==:minDistBetweenBlobs
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_minDistBetweenBlobs(m))
    end
    if s==:filterByColor
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_filterByColor(m))
    end
    if s==:blobColor
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_blobColor(m))
    end
    if s==:filterByArea
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_filterByArea(m))
    end
    if s==:minArea
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_minArea(m))
    end
    if s==:maxArea
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_maxArea(m))
    end
    if s==:filterByCircularity
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_filterByCircularity(m))
    end
    if s==:minCircularity
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_minCircularity(m))
    end
    if s==:maxCircularity
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_maxCircularity(m))
    end
    if s==:filterByInertia
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_filterByInertia(m))
    end
    if s==:minInertiaRatio
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_minInertiaRatio(m))
    end
    if s==:maxInertiaRatio
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_maxInertiaRatio(m))
    end
    if s==:filterByConvexity
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_filterByConvexity(m))
    end
    if s==:minConvexity
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_minConvexity(m))
    end
    if s==:maxConvexity
        return jlopencv_argconvert_jl(jlopencv_SimpleBlobDetector_Params_get_maxConvexity(m))
    end
    return Base.getfield(m, s)
end
function Base.setproperty!(m::SimpleBlobDetector_Params, s::Symbol, v)
    if s==:thresholdStep
        jlopencv_SimpleBlobDetector_Params_set_thresholdStep(m, jlopencv_argconvert_cpp(v))
    end
    if s==:minThreshold
        jlopencv_SimpleBlobDetector_Params_set_minThreshold(m, jlopencv_argconvert_cpp(v))
    end
    if s==:maxThreshold
        jlopencv_SimpleBlobDetector_Params_set_maxThreshold(m, jlopencv_argconvert_cpp(v))
    end
    if s==:minRepeatability
        jlopencv_SimpleBlobDetector_Params_set_minRepeatability(m, jlopencv_argconvert_cpp(v))
    end
    if s==:minDistBetweenBlobs
        jlopencv_SimpleBlobDetector_Params_set_minDistBetweenBlobs(m, jlopencv_argconvert_cpp(v))
    end
    if s==:filterByColor
        jlopencv_SimpleBlobDetector_Params_set_filterByColor(m, jlopencv_argconvert_cpp(v))
    end
    if s==:blobColor
        jlopencv_SimpleBlobDetector_Params_set_blobColor(m, jlopencv_argconvert_cpp(v))
    end
    if s==:filterByArea
        jlopencv_SimpleBlobDetector_Params_set_filterByArea(m, jlopencv_argconvert_cpp(v))
    end
    if s==:minArea
        jlopencv_SimpleBlobDetector_Params_set_minArea(m, jlopencv_argconvert_cpp(v))
    end
    if s==:maxArea
        jlopencv_SimpleBlobDetector_Params_set_maxArea(m, jlopencv_argconvert_cpp(v))
    end
    if s==:filterByCircularity
        jlopencv_SimpleBlobDetector_Params_set_filterByCircularity(m, jlopencv_argconvert_cpp(v))
    end
    if s==:minCircularity
        jlopencv_SimpleBlobDetector_Params_set_minCircularity(m, jlopencv_argconvert_cpp(v))
    end
    if s==:maxCircularity
        jlopencv_SimpleBlobDetector_Params_set_maxCircularity(m, jlopencv_argconvert_cpp(v))
    end
    if s==:filterByInertia
        jlopencv_SimpleBlobDetector_Params_set_filterByInertia(m, jlopencv_argconvert_cpp(v))
    end
    if s==:minInertiaRatio
        jlopencv_SimpleBlobDetector_Params_set_minInertiaRatio(m, jlopencv_argconvert_cpp(v))
    end
    if s==:maxInertiaRatio
        jlopencv_SimpleBlobDetector_Params_set_maxInertiaRatio(m, jlopencv_argconvert_cpp(v))
    end
    if s==:filterByConvexity
        jlopencv_SimpleBlobDetector_Params_set_filterByConvexity(m, jlopencv_argconvert_cpp(v))
    end
    if s==:minConvexity
        jlopencv_SimpleBlobDetector_Params_set_minConvexity(m, jlopencv_argconvert_cpp(v))
    end
    if s==:maxConvexity
        jlopencv_SimpleBlobDetector_Params_set_maxConvexity(m, jlopencv_argconvert_cpp(v))
    end
    return Base.setfield(m, s, v)
end

	 SimpleBlobDetector_Params False
	 .add_type<SimpleBlobDetector::Params>("SimpleBlobDetector_Params").constructor<>()
	 function Base.getproperty(m::SimpleBlobDetector_Params, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::SimpleBlobDetector_Params, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 KAZE True
		 create
		 .method("jlopencv_cv_KAZE_create",  [](cv::Ptr<KAZE> &cobj, bool &extended, bool &upright, float &threshold, int &nOctaves, int &nOctaveLayers, KAZE_DiffusivityType &diffusivity) { auto retval = cv::KAZE::create(extended, upright, threshold, nOctaves, nOctaveLayers, diffusivity); return retval;})
		 create(extended::bool, upright::bool, threshold::float, nOctaves::int, nOctaveLayers::int, diffusivity::KAZE_DiffusivityType) -> ( retval::Ptr<KAZE> ) 
		 setExtended
		 .method("jlopencv_cv_KAZE_setExtended",  [](cv::Ptr<KAZE> &cobj, bool &extended) { cobj->setExtended(extended);  ;})
		 setExtended(extended::bool) -> nothing
		 getExtended
		 .method("jlopencv_cv_KAZE_getExtended",  [](cv::Ptr<KAZE> &cobj) { auto retval = cobj->getExtended();  return retval;})
		 getExtended() -> ( retval::bool ) 
		 setUpright
		 .method("jlopencv_cv_KAZE_setUpright",  [](cv::Ptr<KAZE> &cobj, bool &upright) { cobj->setUpright(upright);  ;})
		 setUpright(upright::bool) -> nothing
		 getUpright
		 .method("jlopencv_cv_KAZE_getUpright",  [](cv::Ptr<KAZE> &cobj) { auto retval = cobj->getUpright();  return retval;})
		 getUpright() -> ( retval::bool ) 
		 setThreshold
		 .method("jlopencv_cv_KAZE_setThreshold",  [](cv::Ptr<KAZE> &cobj, double &threshold) { cobj->setThreshold(threshold);  ;})
		 setThreshold(threshold::double) -> nothing
		 getThreshold
		 .method("jlopencv_cv_KAZE_getThreshold",  [](cv::Ptr<KAZE> &cobj) { auto retval = cobj->getThreshold();  return retval;})
		 getThreshold() -> ( retval::double ) 
		 setNOctaves
		 .method("jlopencv_cv_KAZE_setNOctaves",  [](cv::Ptr<KAZE> &cobj, int &octaves) { cobj->setNOctaves(octaves);  ;})
		 setNOctaves(octaves::int) -> nothing
		 getNOctaves
		 .method("jlopencv_cv_KAZE_getNOctaves",  [](cv::Ptr<KAZE> &cobj) { auto retval = cobj->getNOctaves();  return retval;})
		 getNOctaves() -> ( retval::int ) 
		 setNOctaveLayers
		 .method("jlopencv_cv_KAZE_setNOctaveLayers",  [](cv::Ptr<KAZE> &cobj, int &octaveLayers) { cobj->setNOctaveLayers(octaveLayers);  ;})
		 setNOctaveLayers(octaveLayers::int) -> nothing
		 getNOctaveLayers
		 .method("jlopencv_cv_KAZE_getNOctaveLayers",  [](cv::Ptr<KAZE> &cobj) { auto retval = cobj->getNOctaveLayers();  return retval;})
		 getNOctaveLayers() -> ( retval::int ) 
		 setDiffusivity
		 .method("jlopencv_cv_KAZE_setDiffusivity",  [](cv::Ptr<KAZE> &cobj, KAZE_DiffusivityType &diff) { cobj->setDiffusivity(diff);  ;})
		 setDiffusivity(diff::KAZE_DiffusivityType) -> nothing
		 getDiffusivity
		 .method("jlopencv_cv_KAZE_getDiffusivity",  [](cv::Ptr<KAZE> &cobj) { auto retval = cobj->getDiffusivity();  return retval;})
		 getDiffusivity() -> ( retval::KAZE::DiffusivityType ) 
		 getDefaultName
		 .method("jlopencv_cv_KAZE_getDefaultName",  [](cv::Ptr<KAZE> &cobj) { auto retval = cobj->getDefaultName();  return retval;})
		 getDefaultName() -> ( retval::String ) 
	 WIP
	 function Base.getproperty(m::KAZE, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::KAZE, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 AKAZE True
		 create
		 .method("jlopencv_cv_AKAZE_create",  [](cv::Ptr<AKAZE> &cobj, AKAZE_DescriptorType &descriptor_type, int &descriptor_size, int &descriptor_channels, float &threshold, int &nOctaves, int &nOctaveLayers, KAZE_DiffusivityType &diffusivity) { auto retval = cv::AKAZE::create(descriptor_type, descriptor_size, descriptor_channels, threshold, nOctaves, nOctaveLayers, diffusivity); return retval;})
		 create(descriptor_type::AKAZE_DescriptorType, descriptor_size::int, descriptor_channels::int, threshold::float, nOctaves::int, nOctaveLayers::int, diffusivity::KAZE_DiffusivityType) -> ( retval::Ptr<AKAZE> ) 
		 setDescriptorType
		 .method("jlopencv_cv_AKAZE_setDescriptorType",  [](cv::Ptr<AKAZE> &cobj, AKAZE_DescriptorType &dtype) { cobj->setDescriptorType(dtype);  ;})
		 setDescriptorType(dtype::AKAZE_DescriptorType) -> nothing
		 getDescriptorType
		 .method("jlopencv_cv_AKAZE_getDescriptorType",  [](cv::Ptr<AKAZE> &cobj) { auto retval = cobj->getDescriptorType();  return retval;})
		 getDescriptorType() -> ( retval::AKAZE::DescriptorType ) 
		 setDescriptorSize
		 .method("jlopencv_cv_AKAZE_setDescriptorSize",  [](cv::Ptr<AKAZE> &cobj, int &dsize) { cobj->setDescriptorSize(dsize);  ;})
		 setDescriptorSize(dsize::int) -> nothing
		 getDescriptorSize
		 .method("jlopencv_cv_AKAZE_getDescriptorSize",  [](cv::Ptr<AKAZE> &cobj) { auto retval = cobj->getDescriptorSize();  return retval;})
		 getDescriptorSize() -> ( retval::int ) 
		 setDescriptorChannels
		 .method("jlopencv_cv_AKAZE_setDescriptorChannels",  [](cv::Ptr<AKAZE> &cobj, int &dch) { cobj->setDescriptorChannels(dch);  ;})
		 setDescriptorChannels(dch::int) -> nothing
		 getDescriptorChannels
		 .method("jlopencv_cv_AKAZE_getDescriptorChannels",  [](cv::Ptr<AKAZE> &cobj) { auto retval = cobj->getDescriptorChannels();  return retval;})
		 getDescriptorChannels() -> ( retval::int ) 
		 setThreshold
		 .method("jlopencv_cv_AKAZE_setThreshold",  [](cv::Ptr<AKAZE> &cobj, double &threshold) { cobj->setThreshold(threshold);  ;})
		 setThreshold(threshold::double) -> nothing
		 getThreshold
		 .method("jlopencv_cv_AKAZE_getThreshold",  [](cv::Ptr<AKAZE> &cobj) { auto retval = cobj->getThreshold();  return retval;})
		 getThreshold() -> ( retval::double ) 
		 setNOctaves
		 .method("jlopencv_cv_AKAZE_setNOctaves",  [](cv::Ptr<AKAZE> &cobj, int &octaves) { cobj->setNOctaves(octaves);  ;})
		 setNOctaves(octaves::int) -> nothing
		 getNOctaves
		 .method("jlopencv_cv_AKAZE_getNOctaves",  [](cv::Ptr<AKAZE> &cobj) { auto retval = cobj->getNOctaves();  return retval;})
		 getNOctaves() -> ( retval::int ) 
		 setNOctaveLayers
		 .method("jlopencv_cv_AKAZE_setNOctaveLayers",  [](cv::Ptr<AKAZE> &cobj, int &octaveLayers) { cobj->setNOctaveLayers(octaveLayers);  ;})
		 setNOctaveLayers(octaveLayers::int) -> nothing
		 getNOctaveLayers
		 .method("jlopencv_cv_AKAZE_getNOctaveLayers",  [](cv::Ptr<AKAZE> &cobj) { auto retval = cobj->getNOctaveLayers();  return retval;})
		 getNOctaveLayers() -> ( retval::int ) 
		 setDiffusivity
		 .method("jlopencv_cv_AKAZE_setDiffusivity",  [](cv::Ptr<AKAZE> &cobj, KAZE_DiffusivityType &diff) { cobj->setDiffusivity(diff);  ;})
		 setDiffusivity(diff::KAZE_DiffusivityType) -> nothing
		 getDiffusivity
		 .method("jlopencv_cv_AKAZE_getDiffusivity",  [](cv::Ptr<AKAZE> &cobj) { auto retval = cobj->getDiffusivity();  return retval;})
		 getDiffusivity() -> ( retval::KAZE::DiffusivityType ) 
		 getDefaultName
		 .method("jlopencv_cv_AKAZE_getDefaultName",  [](cv::Ptr<AKAZE> &cobj) { auto retval = cobj->getDefaultName();  return retval;})
		 getDefaultName() -> ( retval::String ) 
	 WIP
	 function Base.getproperty(m::AKAZE, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::AKAZE, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 DescriptorMatcher True
		 add
		 .method("jlopencv_cv_DescriptorMatcher_add",  [](cv::Ptr<DescriptorMatcher> &cobj, vector<Mat> &descriptors) { cobj->add(descriptors);  ;})
		 add(descriptors::vector<Mat>) -> nothing
		 add
		 .method("jlopencv_cv_DescriptorMatcher_add",  [](cv::Ptr<DescriptorMatcher> &cobj, vector<UMat> &descriptors) { cobj->add(descriptors);  ;})
		 add(descriptors::vector<UMat>) -> nothing
		 getTrainDescriptors
		 .method("jlopencv_cv_DescriptorMatcher_getTrainDescriptors",  [](cv::Ptr<DescriptorMatcher> &cobj) { auto retval = cobj->getTrainDescriptors();  return retval;})
		 getTrainDescriptors() -> ( retval::std::vector<Mat> ) 
		 clear
		 .method("jlopencv_cv_DescriptorMatcher_clear",  [](cv::Ptr<DescriptorMatcher> &cobj) { cobj->clear();  ;})
		 clear() -> nothing
		 empty
		 .method("jlopencv_cv_DescriptorMatcher_empty",  [](cv::Ptr<DescriptorMatcher> &cobj) { auto retval = cobj->empty();  return retval;})
		 empty() -> ( retval::bool ) 
		 isMaskSupported
		 .method("jlopencv_cv_DescriptorMatcher_isMaskSupported",  [](cv::Ptr<DescriptorMatcher> &cobj) { auto retval = cobj->isMaskSupported();  return retval;})
		 isMaskSupported() -> ( retval::bool ) 
		 train
		 .method("jlopencv_cv_DescriptorMatcher_train",  [](cv::Ptr<DescriptorMatcher> &cobj) { cobj->train();  ;})
		 train() -> nothing
		 match
		 .method("jlopencv_cv_DescriptorMatcher_match",  [](cv::Ptr<DescriptorMatcher> &cobj, Mat &queryDescriptors, Mat &trainDescriptors, Mat &mask) {vector<DMatch> matches; cobj->match(queryDescriptors, trainDescriptors, matches, mask);  return matches;})
		 match(queryDescriptors::Mat, trainDescriptors::Mat, mask::Mat) -> ( matches::vector<DMatch> ) 
		 match
		 .method("jlopencv_cv_DescriptorMatcher_match",  [](cv::Ptr<DescriptorMatcher> &cobj, UMat &queryDescriptors, UMat &trainDescriptors, UMat &mask) {vector<DMatch> matches; cobj->match(queryDescriptors, trainDescriptors, matches, mask);  return matches;})
		 match(queryDescriptors::UMat, trainDescriptors::UMat, mask::UMat) -> ( matches::vector<DMatch> ) 
		 match
		 .method("jlopencv_cv_DescriptorMatcher_match",  [](cv::Ptr<DescriptorMatcher> &cobj, Mat &queryDescriptors, vector<Mat> &masks) {vector<DMatch> matches; cobj->match(queryDescriptors, matches, masks);  return matches;})
		 match(queryDescriptors::Mat, masks::vector<Mat>) -> ( matches::vector<DMatch> ) 
		 match
		 .method("jlopencv_cv_DescriptorMatcher_match",  [](cv::Ptr<DescriptorMatcher> &cobj, UMat &queryDescriptors, vector<UMat> &masks) {vector<DMatch> matches; cobj->match(queryDescriptors, matches, masks);  return matches;})
		 match(queryDescriptors::UMat, masks::vector<UMat>) -> ( matches::vector<DMatch> ) 
		 knnMatch
		 .method("jlopencv_cv_DescriptorMatcher_knnMatch",  [](cv::Ptr<DescriptorMatcher> &cobj, Mat &queryDescriptors, Mat &trainDescriptors, int &k, Mat &mask, bool &compactResult) {vector<vector<DMatch>> matches; cobj->knnMatch(queryDescriptors, trainDescriptors, matches, k, mask, compactResult);  return matches;})
		 knnMatch(queryDescriptors::Mat, trainDescriptors::Mat, k::int, mask::Mat, compactResult::bool) -> ( matches::vector<vector<DMatch>> ) 
		 knnMatch
		 .method("jlopencv_cv_DescriptorMatcher_knnMatch",  [](cv::Ptr<DescriptorMatcher> &cobj, UMat &queryDescriptors, UMat &trainDescriptors, int &k, UMat &mask, bool &compactResult) {vector<vector<DMatch>> matches; cobj->knnMatch(queryDescriptors, trainDescriptors, matches, k, mask, compactResult);  return matches;})
		 knnMatch(queryDescriptors::UMat, trainDescriptors::UMat, k::int, mask::UMat, compactResult::bool) -> ( matches::vector<vector<DMatch>> ) 
		 knnMatch
		 .method("jlopencv_cv_DescriptorMatcher_knnMatch",  [](cv::Ptr<DescriptorMatcher> &cobj, Mat &queryDescriptors, int &k, vector<Mat> &masks, bool &compactResult) {vector<vector<DMatch>> matches; cobj->knnMatch(queryDescriptors, matches, k, masks, compactResult);  return matches;})
		 knnMatch(queryDescriptors::Mat, k::int, masks::vector<Mat>, compactResult::bool) -> ( matches::vector<vector<DMatch>> ) 
		 knnMatch
		 .method("jlopencv_cv_DescriptorMatcher_knnMatch",  [](cv::Ptr<DescriptorMatcher> &cobj, UMat &queryDescriptors, int &k, vector<UMat> &masks, bool &compactResult) {vector<vector<DMatch>> matches; cobj->knnMatch(queryDescriptors, matches, k, masks, compactResult);  return matches;})
		 knnMatch(queryDescriptors::UMat, k::int, masks::vector<UMat>, compactResult::bool) -> ( matches::vector<vector<DMatch>> ) 
		 radiusMatch
		 .method("jlopencv_cv_DescriptorMatcher_radiusMatch",  [](cv::Ptr<DescriptorMatcher> &cobj, Mat &queryDescriptors, Mat &trainDescriptors, float &maxDistance, Mat &mask, bool &compactResult) {vector<vector<DMatch>> matches; cobj->radiusMatch(queryDescriptors, trainDescriptors, matches, maxDistance, mask, compactResult);  return matches;})
		 radiusMatch(queryDescriptors::Mat, trainDescriptors::Mat, maxDistance::float, mask::Mat, compactResult::bool) -> ( matches::vector<vector<DMatch>> ) 
		 radiusMatch
		 .method("jlopencv_cv_DescriptorMatcher_radiusMatch",  [](cv::Ptr<DescriptorMatcher> &cobj, UMat &queryDescriptors, UMat &trainDescriptors, float &maxDistance, UMat &mask, bool &compactResult) {vector<vector<DMatch>> matches; cobj->radiusMatch(queryDescriptors, trainDescriptors, matches, maxDistance, mask, compactResult);  return matches;})
		 radiusMatch(queryDescriptors::UMat, trainDescriptors::UMat, maxDistance::float, mask::UMat, compactResult::bool) -> ( matches::vector<vector<DMatch>> ) 
		 radiusMatch
		 .method("jlopencv_cv_DescriptorMatcher_radiusMatch",  [](cv::Ptr<DescriptorMatcher> &cobj, Mat &queryDescriptors, float &maxDistance, vector<Mat> &masks, bool &compactResult) {vector<vector<DMatch>> matches; cobj->radiusMatch(queryDescriptors, matches, maxDistance, masks, compactResult);  return matches;})
		 radiusMatch(queryDescriptors::Mat, maxDistance::float, masks::vector<Mat>, compactResult::bool) -> ( matches::vector<vector<DMatch>> ) 
		 radiusMatch
		 .method("jlopencv_cv_DescriptorMatcher_radiusMatch",  [](cv::Ptr<DescriptorMatcher> &cobj, UMat &queryDescriptors, float &maxDistance, vector<UMat> &masks, bool &compactResult) {vector<vector<DMatch>> matches; cobj->radiusMatch(queryDescriptors, matches, maxDistance, masks, compactResult);  return matches;})
		 radiusMatch(queryDescriptors::UMat, maxDistance::float, masks::vector<UMat>, compactResult::bool) -> ( matches::vector<vector<DMatch>> ) 
		 write
		 .method("jlopencv_cv_DescriptorMatcher_write",  [](cv::Ptr<DescriptorMatcher> &cobj, String &fileName) { cobj->write(fileName);  ;})
		 write(fileName::String) -> nothing
		 write
		 .method("jlopencv_cv_DescriptorMatcher_write",  [](cv::Ptr<DescriptorMatcher> &cobj, Ptr<FileStorage> &fs, String &name) { cobj->write(fs, name);  ;})
		 write(fs::Ptr<FileStorage>, name::String) -> nothing
		 read
		 .method("jlopencv_cv_DescriptorMatcher_read",  [](cv::Ptr<DescriptorMatcher> &cobj, String &fileName) { cobj->read(fileName);  ;})
		 read(fileName::String) -> nothing
		 read
		 .method("jlopencv_cv_DescriptorMatcher_read",  [](cv::Ptr<DescriptorMatcher> &cobj, FileNode &arg1) { cobj->read(arg1);  ;})
		 read(arg1::FileNode) -> nothing
		 clone
		 .method("jlopencv_cv_DescriptorMatcher_clone",  [](cv::Ptr<DescriptorMatcher> &cobj, bool &emptyTrainData) { auto retval = cobj->clone(emptyTrainData);  return retval;})
		 clone(emptyTrainData::bool) -> ( retval::Ptr<DescriptorMatcher> ) 
		 create
		 .method("jlopencv_cv_DescriptorMatcher_create",  [](cv::Ptr<DescriptorMatcher> &cobj, String &descriptorMatcherType) { auto retval = cv::DescriptorMatcher::create(descriptorMatcherType); return retval;})
		 create(descriptorMatcherType::String) -> ( retval::Ptr<DescriptorMatcher> ) 
		 create
		 .method("jlopencv_cv_DescriptorMatcher_create",  [](cv::Ptr<DescriptorMatcher> &cobj, DescriptorMatcher_MatcherType &matcherType) { auto retval = cv::DescriptorMatcher::create(matcherType); return retval;})
		 create(matcherType::DescriptorMatcher_MatcherType) -> ( retval::Ptr<DescriptorMatcher> ) 
	 WIP
	 function Base.getproperty(m::DescriptorMatcher, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::DescriptorMatcher, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 BFMatcher True
		 create
		 .method("jlopencv_cv_BFMatcher_create",  [](cv::Ptr<BFMatcher> &cobj, int &normType, bool &crossCheck) { auto retval = cv::BFMatcher::create(normType, crossCheck); return retval;})
		 create(normType::int, crossCheck::bool) -> ( retval::Ptr<BFMatcher> ) 
	 WIP
	 function Base.getproperty(m::BFMatcher, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::BFMatcher, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 FlannBasedMatcher True
		 create
		 .method("jlopencv_cv_FlannBasedMatcher_create",  [](cv::Ptr<FlannBasedMatcher> &cobj) { auto retval = cv::FlannBasedMatcher::create(); return retval;})
		 create() -> ( retval::Ptr<FlannBasedMatcher> ) 
	 WIP
	 function Base.getproperty(m::FlannBasedMatcher, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::FlannBasedMatcher, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 BOWTrainer False
		 add
		 .method("jlopencv_cv_BOWTrainer_add",  [](BOWTrainer &cobj, Mat &descriptors) { cobj.add(descriptors);  ;})
		 add(descriptors::Mat) -> nothing
		 add
		 .method("jlopencv_cv_BOWTrainer_add",  [](BOWTrainer &cobj, Mat &descriptors) { cobj.add(descriptors);  ;})
		 add(descriptors::Mat) -> nothing
		 getDescriptors
		 .method("jlopencv_cv_BOWTrainer_getDescriptors",  [](BOWTrainer &cobj) { auto retval = cobj.getDescriptors();  return retval;})
		 getDescriptors() -> ( retval::std::vector<Mat> ) 
		 descriptorsCount
		 .method("jlopencv_cv_BOWTrainer_descriptorsCount",  [](BOWTrainer &cobj) { auto retval = cobj.descriptorsCount();  return retval;})
		 descriptorsCount() -> ( retval::int ) 
		 clear
		 .method("jlopencv_cv_BOWTrainer_clear",  [](BOWTrainer &cobj) { cobj.clear();  ;})
		 clear() -> nothing
		 cluster
		 .method("jlopencv_cv_BOWTrainer_cluster",  [](BOWTrainer &cobj) { auto retval = cobj.cluster();  return retval;})
		 cluster() -> ( retval::Mat ) 
		 cluster
		 .method("jlopencv_cv_BOWTrainer_cluster",  [](BOWTrainer &cobj, Mat &descriptors) { auto retval = cobj.cluster(descriptors);  return retval;})
		 cluster(descriptors::Mat) -> ( retval::Mat ) 
		 cluster
		 .method("jlopencv_cv_BOWTrainer_cluster",  [](BOWTrainer &cobj, Mat &descriptors) { auto retval = cobj.cluster(descriptors);  return retval;})
		 cluster(descriptors::Mat) -> ( retval::Mat ) 
	 .add_type<cv::BOWTrainer>("BOWTrainer")
	 function Base.getproperty(m::BOWTrainer, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::BOWTrainer, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 BOWKMeansTrainer False
		 cluster
		 .method("jlopencv_cv_BOWKMeansTrainer_cluster",  [](BOWKMeansTrainer &cobj) { auto retval = cobj.cluster();  return retval;})
		 cluster() -> ( retval::Mat ) 
		 cluster
		 .method("jlopencv_cv_BOWKMeansTrainer_cluster",  [](BOWKMeansTrainer &cobj, Mat &descriptors) { auto retval = cobj.cluster(descriptors);  return retval;})
		 cluster(descriptors::Mat) -> ( retval::Mat ) 
		 cluster
		 .method("jlopencv_cv_BOWKMeansTrainer_cluster",  [](BOWKMeansTrainer &cobj, Mat &descriptors) { auto retval = cobj.cluster(descriptors);  return retval;})
		 cluster(descriptors::Mat) -> ( retval::Mat ) 
	 .add_type<cv::BOWKMeansTrainer>("BOWKMeansTrainer").constructor<const int&,const TermCriteria&,const int&,const int&>()
	 function Base.getproperty(m::BOWKMeansTrainer, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::BOWKMeansTrainer, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 BOWImgDescriptorExtractor False
		 setVocabulary
		 .method("jlopencv_cv_BOWImgDescriptorExtractor_setVocabulary",  [](BOWImgDescriptorExtractor &cobj, Mat &vocabulary) { cobj.setVocabulary(vocabulary);  ;})
		 setVocabulary(vocabulary::Mat) -> nothing
		 setVocabulary
		 .method("jlopencv_cv_BOWImgDescriptorExtractor_setVocabulary",  [](BOWImgDescriptorExtractor &cobj, Mat &vocabulary) { cobj.setVocabulary(vocabulary);  ;})
		 setVocabulary(vocabulary::Mat) -> nothing
		 getVocabulary
		 .method("jlopencv_cv_BOWImgDescriptorExtractor_getVocabulary",  [](BOWImgDescriptorExtractor &cobj) { auto retval = cobj.getVocabulary();  return retval;})
		 getVocabulary() -> ( retval::Mat ) 
		 compute
		 .method("jlopencv_cv_BOWImgDescriptorExtractor_compute",  [](BOWImgDescriptorExtractor &cobj, Mat &image, vector<KeyPoint> &keypoints, Mat &imgDescriptor) { cobj.compute(image, keypoints, imgDescriptor);  return imgDescriptor;})
		 compute(image::Mat, keypoints::vector<KeyPoint>; imgDescriptor::Mat) -> ( imgDescriptor::Mat ) 
		 compute
		 .method("jlopencv_cv_BOWImgDescriptorExtractor_compute",  [](BOWImgDescriptorExtractor &cobj, Mat &image, vector<KeyPoint> &keypoints, Mat &imgDescriptor) { cobj.compute(image, keypoints, imgDescriptor);  return imgDescriptor;})
		 compute(image::Mat, keypoints::vector<KeyPoint>; imgDescriptor::Mat) -> ( imgDescriptor::Mat ) 
		 descriptorSize
		 .method("jlopencv_cv_BOWImgDescriptorExtractor_descriptorSize",  [](BOWImgDescriptorExtractor &cobj) { auto retval = cobj.descriptorSize();  return retval;})
		 descriptorSize() -> ( retval::int ) 
		 descriptorType
		 .method("jlopencv_cv_BOWImgDescriptorExtractor_descriptorType",  [](BOWImgDescriptorExtractor &cobj) { auto retval = cobj.descriptorType();  return retval;})
		 descriptorType() -> ( retval::int ) 
	 .add_type<cv::BOWImgDescriptorExtractor>("BOWImgDescriptorExtractor").constructor<const Ptr<DescriptorExtractor>&,const Ptr<DescriptorMatcher>&>()
	 function Base.getproperty(m::BOWImgDescriptorExtractor, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::BOWImgDescriptorExtractor, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 KalmanFilter False
		 predict
		 .method("jlopencv_cv_KalmanFilter_predict",  [](KalmanFilter &cobj, Mat &control) { auto retval = cobj.predict(control);  return retval;})
		 predict(control::Mat) -> ( retval::Mat ) 
		 predict
		 .method("jlopencv_cv_KalmanFilter_predict",  [](KalmanFilter &cobj, Mat &control) { auto retval = cobj.predict(control);  return retval;})
		 predict(control::Mat) -> ( retval::Mat ) 
		 correct
		 .method("jlopencv_cv_KalmanFilter_correct",  [](KalmanFilter &cobj, Mat &measurement) { auto retval = cobj.correct(measurement);  return retval;})
		 correct(measurement::Mat) -> ( retval::Mat ) 
		 correct
		 .method("jlopencv_cv_KalmanFilter_correct",  [](KalmanFilter &cobj, Mat &measurement) { auto retval = cobj.correct(measurement);  return retval;})
		 correct(measurement::Mat) -> ( retval::Mat ) 
	 .add_type<cv::KalmanFilter>("KalmanFilter").constructor<>().constructor<const int&,const int&,const int&,const int&>().method("jlopencv_KalmanFilter_set_statePre", [](cv::KalmanFilter &cobj,const Mat &v) {cobj.statePre=v;}).method("jlopencv_KalmanFilter_set_statePost", [](cv::KalmanFilter &cobj,const Mat &v) {cobj.statePost=v;}).method("jlopencv_KalmanFilter_set_transitionMatrix", [](cv::KalmanFilter &cobj,const Mat &v) {cobj.transitionMatrix=v;}).method("jlopencv_KalmanFilter_set_controlMatrix", [](cv::KalmanFilter &cobj,const Mat &v) {cobj.controlMatrix=v;}).method("jlopencv_KalmanFilter_set_measurementMatrix", [](cv::KalmanFilter &cobj,const Mat &v) {cobj.measurementMatrix=v;}).method("jlopencv_KalmanFilter_set_processNoiseCov", [](cv::KalmanFilter &cobj,const Mat &v) {cobj.processNoiseCov=v;}).method("jlopencv_KalmanFilter_set_measurementNoiseCov", [](cv::KalmanFilter &cobj,const Mat &v) {cobj.measurementNoiseCov=v;}).method("jlopencv_KalmanFilter_set_errorCovPre", [](cv::KalmanFilter &cobj,const Mat &v) {cobj.errorCovPre=v;}).method("jlopencv_KalmanFilter_set_gain", [](cv::KalmanFilter &cobj,const Mat &v) {cobj.gain=v;}).method("jlopencv_KalmanFilter_set_errorCovPost", [](cv::KalmanFilter &cobj,const Mat &v) {cobj.errorCovPost=v;}).method("jlopencv_KalmanFilter_get_statePre", [](const cv::KalmanFilter &cobj) {return cobj.statePre;}).method("jlopencv_KalmanFilter_get_statePost", [](const cv::KalmanFilter &cobj) {return cobj.statePost;}).method("jlopencv_KalmanFilter_get_transitionMatrix", [](const cv::KalmanFilter &cobj) {return cobj.transitionMatrix;}).method("jlopencv_KalmanFilter_get_controlMatrix", [](const cv::KalmanFilter &cobj) {return cobj.controlMatrix;}).method("jlopencv_KalmanFilter_get_measurementMatrix", [](const cv::KalmanFilter &cobj) {return cobj.measurementMatrix;}).method("jlopencv_KalmanFilter_get_processNoiseCov", [](const cv::KalmanFilter &cobj) {return cobj.processNoiseCov;}).method("jlopencv_KalmanFilter_get_measurementNoiseCov", [](const cv::KalmanFilter &cobj) {return cobj.measurementNoiseCov;}).method("jlopencv_KalmanFilter_get_errorCovPre", [](const cv::KalmanFilter &cobj) {return cobj.errorCovPre;}).method("jlopencv_KalmanFilter_get_gain", [](const cv::KalmanFilter &cobj) {return cobj.gain;}).method("jlopencv_KalmanFilter_get_errorCovPost", [](const cv::KalmanFilter &cobj) {return cobj.errorCovPost;})
	 function Base.getproperty(m::KalmanFilter, s::Symbol)
    if s==:statePre
        return jlopencv_argconvert_jl(jlopencv_KalmanFilter_get_statePre(m))
    end
    if s==:statePost
        return jlopencv_argconvert_jl(jlopencv_KalmanFilter_get_statePost(m))
    end
    if s==:transitionMatrix
        return jlopencv_argconvert_jl(jlopencv_KalmanFilter_get_transitionMatrix(m))
    end
    if s==:controlMatrix
        return jlopencv_argconvert_jl(jlopencv_KalmanFilter_get_controlMatrix(m))
    end
    if s==:measurementMatrix
        return jlopencv_argconvert_jl(jlopencv_KalmanFilter_get_measurementMatrix(m))
    end
    if s==:processNoiseCov
        return jlopencv_argconvert_jl(jlopencv_KalmanFilter_get_processNoiseCov(m))
    end
    if s==:measurementNoiseCov
        return jlopencv_argconvert_jl(jlopencv_KalmanFilter_get_measurementNoiseCov(m))
    end
    if s==:errorCovPre
        return jlopencv_argconvert_jl(jlopencv_KalmanFilter_get_errorCovPre(m))
    end
    if s==:gain
        return jlopencv_argconvert_jl(jlopencv_KalmanFilter_get_gain(m))
    end
    if s==:errorCovPost
        return jlopencv_argconvert_jl(jlopencv_KalmanFilter_get_errorCovPost(m))
    end
    return Base.getfield(m, s)
end
function Base.setproperty!(m::KalmanFilter, s::Symbol, v)
    if s==:statePre
        jlopencv_KalmanFilter_set_statePre(m, jlopencv_argconvert_cpp(v))
    end
    if s==:statePost
        jlopencv_KalmanFilter_set_statePost(m, jlopencv_argconvert_cpp(v))
    end
    if s==:transitionMatrix
        jlopencv_KalmanFilter_set_transitionMatrix(m, jlopencv_argconvert_cpp(v))
    end
    if s==:controlMatrix
        jlopencv_KalmanFilter_set_controlMatrix(m, jlopencv_argconvert_cpp(v))
    end
    if s==:measurementMatrix
        jlopencv_KalmanFilter_set_measurementMatrix(m, jlopencv_argconvert_cpp(v))
    end
    if s==:processNoiseCov
        jlopencv_KalmanFilter_set_processNoiseCov(m, jlopencv_argconvert_cpp(v))
    end
    if s==:measurementNoiseCov
        jlopencv_KalmanFilter_set_measurementNoiseCov(m, jlopencv_argconvert_cpp(v))
    end
    if s==:errorCovPre
        jlopencv_KalmanFilter_set_errorCovPre(m, jlopencv_argconvert_cpp(v))
    end
    if s==:gain
        jlopencv_KalmanFilter_set_gain(m, jlopencv_argconvert_cpp(v))
    end
    if s==:errorCovPost
        jlopencv_KalmanFilter_set_errorCovPost(m, jlopencv_argconvert_cpp(v))
    end
    return Base.setfield(m, s, v)
end

	 DenseOpticalFlow True
		 calc
		 .method("jlopencv_cv_DenseOpticalFlow_calc",  [](cv::Ptr<DenseOpticalFlow> &cobj, Mat &I0, Mat &I1, Mat &flow) { cobj->calc(I0, I1, flow);  return flow;})
		 calc(I0::Mat, I1::Mat, flow::Mat) -> ( flow::Mat ) 
		 calc
		 .method("jlopencv_cv_DenseOpticalFlow_calc",  [](cv::Ptr<DenseOpticalFlow> &cobj, UMat &I0, UMat &I1, UMat &flow) { cobj->calc(I0, I1, flow);  return flow;})
		 calc(I0::UMat, I1::UMat, flow::UMat) -> ( flow::UMat ) 
		 collectGarbage
		 .method("jlopencv_cv_DenseOpticalFlow_collectGarbage",  [](cv::Ptr<DenseOpticalFlow> &cobj) { cobj->collectGarbage();  ;})
		 collectGarbage() -> nothing
	 WIP
	 function Base.getproperty(m::DenseOpticalFlow, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::DenseOpticalFlow, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 SparseOpticalFlow True
		 calc
		 .method("jlopencv_cv_SparseOpticalFlow_calc",  [](cv::Ptr<SparseOpticalFlow> &cobj, Mat &prevImg, Mat &nextImg, Mat &prevPts, Mat &nextPts, Mat &status, Mat &err) { cobj->calc(prevImg, nextImg, prevPts, nextPts, status, err);  return make_tuple<Mat,Mat,Mat>(nextPts,status,err);})
		 calc(prevImg::Mat, nextImg::Mat, prevPts::Mat, nextPts::Mat; status::Mat, err::Mat) -> ( nextPts::Mat, status::Mat, err::Mat ) 
		 calc
		 .method("jlopencv_cv_SparseOpticalFlow_calc",  [](cv::Ptr<SparseOpticalFlow> &cobj, UMat &prevImg, UMat &nextImg, UMat &prevPts, UMat &nextPts, UMat &status, UMat &err) { cobj->calc(prevImg, nextImg, prevPts, nextPts, status, err);  return make_tuple<UMat,UMat,UMat>(nextPts,status,err);})
		 calc(prevImg::UMat, nextImg::UMat, prevPts::UMat, nextPts::UMat; status::UMat, err::UMat) -> ( nextPts::UMat, status::UMat, err::UMat ) 
	 WIP
	 function Base.getproperty(m::SparseOpticalFlow, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::SparseOpticalFlow, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 FarnebackOpticalFlow True
		 getNumLevels
		 .method("jlopencv_cv_FarnebackOpticalFlow_getNumLevels",  [](cv::Ptr<FarnebackOpticalFlow> &cobj) { auto retval = cobj->getNumLevels();  return retval;})
		 getNumLevels() -> ( retval::int ) 
		 setNumLevels
		 .method("jlopencv_cv_FarnebackOpticalFlow_setNumLevels",  [](cv::Ptr<FarnebackOpticalFlow> &cobj, int &numLevels) { cobj->setNumLevels(numLevels);  ;})
		 setNumLevels(numLevels::int) -> nothing
		 getPyrScale
		 .method("jlopencv_cv_FarnebackOpticalFlow_getPyrScale",  [](cv::Ptr<FarnebackOpticalFlow> &cobj) { auto retval = cobj->getPyrScale();  return retval;})
		 getPyrScale() -> ( retval::double ) 
		 setPyrScale
		 .method("jlopencv_cv_FarnebackOpticalFlow_setPyrScale",  [](cv::Ptr<FarnebackOpticalFlow> &cobj, double &pyrScale) { cobj->setPyrScale(pyrScale);  ;})
		 setPyrScale(pyrScale::double) -> nothing
		 getFastPyramids
		 .method("jlopencv_cv_FarnebackOpticalFlow_getFastPyramids",  [](cv::Ptr<FarnebackOpticalFlow> &cobj) { auto retval = cobj->getFastPyramids();  return retval;})
		 getFastPyramids() -> ( retval::bool ) 
		 setFastPyramids
		 .method("jlopencv_cv_FarnebackOpticalFlow_setFastPyramids",  [](cv::Ptr<FarnebackOpticalFlow> &cobj, bool &fastPyramids) { cobj->setFastPyramids(fastPyramids);  ;})
		 setFastPyramids(fastPyramids::bool) -> nothing
		 getWinSize
		 .method("jlopencv_cv_FarnebackOpticalFlow_getWinSize",  [](cv::Ptr<FarnebackOpticalFlow> &cobj) { auto retval = cobj->getWinSize();  return retval;})
		 getWinSize() -> ( retval::int ) 
		 setWinSize
		 .method("jlopencv_cv_FarnebackOpticalFlow_setWinSize",  [](cv::Ptr<FarnebackOpticalFlow> &cobj, int &winSize) { cobj->setWinSize(winSize);  ;})
		 setWinSize(winSize::int) -> nothing
		 getNumIters
		 .method("jlopencv_cv_FarnebackOpticalFlow_getNumIters",  [](cv::Ptr<FarnebackOpticalFlow> &cobj) { auto retval = cobj->getNumIters();  return retval;})
		 getNumIters() -> ( retval::int ) 
		 setNumIters
		 .method("jlopencv_cv_FarnebackOpticalFlow_setNumIters",  [](cv::Ptr<FarnebackOpticalFlow> &cobj, int &numIters) { cobj->setNumIters(numIters);  ;})
		 setNumIters(numIters::int) -> nothing
		 getPolyN
		 .method("jlopencv_cv_FarnebackOpticalFlow_getPolyN",  [](cv::Ptr<FarnebackOpticalFlow> &cobj) { auto retval = cobj->getPolyN();  return retval;})
		 getPolyN() -> ( retval::int ) 
		 setPolyN
		 .method("jlopencv_cv_FarnebackOpticalFlow_setPolyN",  [](cv::Ptr<FarnebackOpticalFlow> &cobj, int &polyN) { cobj->setPolyN(polyN);  ;})
		 setPolyN(polyN::int) -> nothing
		 getPolySigma
		 .method("jlopencv_cv_FarnebackOpticalFlow_getPolySigma",  [](cv::Ptr<FarnebackOpticalFlow> &cobj) { auto retval = cobj->getPolySigma();  return retval;})
		 getPolySigma() -> ( retval::double ) 
		 setPolySigma
		 .method("jlopencv_cv_FarnebackOpticalFlow_setPolySigma",  [](cv::Ptr<FarnebackOpticalFlow> &cobj, double &polySigma) { cobj->setPolySigma(polySigma);  ;})
		 setPolySigma(polySigma::double) -> nothing
		 getFlags
		 .method("jlopencv_cv_FarnebackOpticalFlow_getFlags",  [](cv::Ptr<FarnebackOpticalFlow> &cobj) { auto retval = cobj->getFlags();  return retval;})
		 getFlags() -> ( retval::int ) 
		 setFlags
		 .method("jlopencv_cv_FarnebackOpticalFlow_setFlags",  [](cv::Ptr<FarnebackOpticalFlow> &cobj, int &flags) { cobj->setFlags(flags);  ;})
		 setFlags(flags::int) -> nothing
		 create
		 .method("jlopencv_cv_FarnebackOpticalFlow_create",  [](cv::Ptr<FarnebackOpticalFlow> &cobj, int &numLevels, double &pyrScale, bool &fastPyramids, int &winSize, int &numIters, int &polyN, double &polySigma, int &flags) { auto retval = cv::FarnebackOpticalFlow::create(numLevels, pyrScale, fastPyramids, winSize, numIters, polyN, polySigma, flags); return retval;})
		 create(numLevels::int, pyrScale::double, fastPyramids::bool, winSize::int, numIters::int, polyN::int, polySigma::double, flags::int) -> ( retval::Ptr<FarnebackOpticalFlow> ) 
	 WIP
	 function Base.getproperty(m::FarnebackOpticalFlow, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::FarnebackOpticalFlow, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 VariationalRefinement True
		 calcUV
		 .method("jlopencv_cv_VariationalRefinement_calcUV",  [](cv::Ptr<VariationalRefinement> &cobj, Mat &I0, Mat &I1, Mat &flow_u, Mat &flow_v) { cobj->calcUV(I0, I1, flow_u, flow_v);  return make_tuple<Mat,Mat>(flow_u,flow_v);})
		 calcUV(I0::Mat, I1::Mat, flow_u::Mat, flow_v::Mat) -> ( flow_u::Mat, flow_v::Mat ) 
		 calcUV
		 .method("jlopencv_cv_VariationalRefinement_calcUV",  [](cv::Ptr<VariationalRefinement> &cobj, UMat &I0, UMat &I1, UMat &flow_u, UMat &flow_v) { cobj->calcUV(I0, I1, flow_u, flow_v);  return make_tuple<UMat,UMat>(flow_u,flow_v);})
		 calcUV(I0::UMat, I1::UMat, flow_u::UMat, flow_v::UMat) -> ( flow_u::UMat, flow_v::UMat ) 
		 getFixedPointIterations
		 .method("jlopencv_cv_VariationalRefinement_getFixedPointIterations",  [](cv::Ptr<VariationalRefinement> &cobj) { auto retval = cobj->getFixedPointIterations();  return retval;})
		 getFixedPointIterations() -> ( retval::int ) 
		 setFixedPointIterations
		 .method("jlopencv_cv_VariationalRefinement_setFixedPointIterations",  [](cv::Ptr<VariationalRefinement> &cobj, int &val) { cobj->setFixedPointIterations(val);  ;})
		 setFixedPointIterations(val::int) -> nothing
		 getSorIterations
		 .method("jlopencv_cv_VariationalRefinement_getSorIterations",  [](cv::Ptr<VariationalRefinement> &cobj) { auto retval = cobj->getSorIterations();  return retval;})
		 getSorIterations() -> ( retval::int ) 
		 setSorIterations
		 .method("jlopencv_cv_VariationalRefinement_setSorIterations",  [](cv::Ptr<VariationalRefinement> &cobj, int &val) { cobj->setSorIterations(val);  ;})
		 setSorIterations(val::int) -> nothing
		 getOmega
		 .method("jlopencv_cv_VariationalRefinement_getOmega",  [](cv::Ptr<VariationalRefinement> &cobj) { auto retval = cobj->getOmega();  return retval;})
		 getOmega() -> ( retval::float ) 
		 setOmega
		 .method("jlopencv_cv_VariationalRefinement_setOmega",  [](cv::Ptr<VariationalRefinement> &cobj, float &val) { cobj->setOmega(val);  ;})
		 setOmega(val::float) -> nothing
		 getAlpha
		 .method("jlopencv_cv_VariationalRefinement_getAlpha",  [](cv::Ptr<VariationalRefinement> &cobj) { auto retval = cobj->getAlpha();  return retval;})
		 getAlpha() -> ( retval::float ) 
		 setAlpha
		 .method("jlopencv_cv_VariationalRefinement_setAlpha",  [](cv::Ptr<VariationalRefinement> &cobj, float &val) { cobj->setAlpha(val);  ;})
		 setAlpha(val::float) -> nothing
		 getDelta
		 .method("jlopencv_cv_VariationalRefinement_getDelta",  [](cv::Ptr<VariationalRefinement> &cobj) { auto retval = cobj->getDelta();  return retval;})
		 getDelta() -> ( retval::float ) 
		 setDelta
		 .method("jlopencv_cv_VariationalRefinement_setDelta",  [](cv::Ptr<VariationalRefinement> &cobj, float &val) { cobj->setDelta(val);  ;})
		 setDelta(val::float) -> nothing
		 getGamma
		 .method("jlopencv_cv_VariationalRefinement_getGamma",  [](cv::Ptr<VariationalRefinement> &cobj) { auto retval = cobj->getGamma();  return retval;})
		 getGamma() -> ( retval::float ) 
		 setGamma
		 .method("jlopencv_cv_VariationalRefinement_setGamma",  [](cv::Ptr<VariationalRefinement> &cobj, float &val) { cobj->setGamma(val);  ;})
		 setGamma(val::float) -> nothing
		 create
		 .method("jlopencv_cv_VariationalRefinement_create",  [](cv::Ptr<VariationalRefinement> &cobj) { auto retval = cv::VariationalRefinement::create(); return retval;})
		 create() -> ( retval::Ptr<VariationalRefinement> ) 
	 WIP
	 function Base.getproperty(m::VariationalRefinement, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::VariationalRefinement, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 DISOpticalFlow True
		 getFinestScale
		 .method("jlopencv_cv_DISOpticalFlow_getFinestScale",  [](cv::Ptr<DISOpticalFlow> &cobj) { auto retval = cobj->getFinestScale();  return retval;})
		 getFinestScale() -> ( retval::int ) 
		 setFinestScale
		 .method("jlopencv_cv_DISOpticalFlow_setFinestScale",  [](cv::Ptr<DISOpticalFlow> &cobj, int &val) { cobj->setFinestScale(val);  ;})
		 setFinestScale(val::int) -> nothing
		 getPatchSize
		 .method("jlopencv_cv_DISOpticalFlow_getPatchSize",  [](cv::Ptr<DISOpticalFlow> &cobj) { auto retval = cobj->getPatchSize();  return retval;})
		 getPatchSize() -> ( retval::int ) 
		 setPatchSize
		 .method("jlopencv_cv_DISOpticalFlow_setPatchSize",  [](cv::Ptr<DISOpticalFlow> &cobj, int &val) { cobj->setPatchSize(val);  ;})
		 setPatchSize(val::int) -> nothing
		 getPatchStride
		 .method("jlopencv_cv_DISOpticalFlow_getPatchStride",  [](cv::Ptr<DISOpticalFlow> &cobj) { auto retval = cobj->getPatchStride();  return retval;})
		 getPatchStride() -> ( retval::int ) 
		 setPatchStride
		 .method("jlopencv_cv_DISOpticalFlow_setPatchStride",  [](cv::Ptr<DISOpticalFlow> &cobj, int &val) { cobj->setPatchStride(val);  ;})
		 setPatchStride(val::int) -> nothing
		 getGradientDescentIterations
		 .method("jlopencv_cv_DISOpticalFlow_getGradientDescentIterations",  [](cv::Ptr<DISOpticalFlow> &cobj) { auto retval = cobj->getGradientDescentIterations();  return retval;})
		 getGradientDescentIterations() -> ( retval::int ) 
		 setGradientDescentIterations
		 .method("jlopencv_cv_DISOpticalFlow_setGradientDescentIterations",  [](cv::Ptr<DISOpticalFlow> &cobj, int &val) { cobj->setGradientDescentIterations(val);  ;})
		 setGradientDescentIterations(val::int) -> nothing
		 getVariationalRefinementIterations
		 .method("jlopencv_cv_DISOpticalFlow_getVariationalRefinementIterations",  [](cv::Ptr<DISOpticalFlow> &cobj) { auto retval = cobj->getVariationalRefinementIterations();  return retval;})
		 getVariationalRefinementIterations() -> ( retval::int ) 
		 setVariationalRefinementIterations
		 .method("jlopencv_cv_DISOpticalFlow_setVariationalRefinementIterations",  [](cv::Ptr<DISOpticalFlow> &cobj, int &val) { cobj->setVariationalRefinementIterations(val);  ;})
		 setVariationalRefinementIterations(val::int) -> nothing
		 getVariationalRefinementAlpha
		 .method("jlopencv_cv_DISOpticalFlow_getVariationalRefinementAlpha",  [](cv::Ptr<DISOpticalFlow> &cobj) { auto retval = cobj->getVariationalRefinementAlpha();  return retval;})
		 getVariationalRefinementAlpha() -> ( retval::float ) 
		 setVariationalRefinementAlpha
		 .method("jlopencv_cv_DISOpticalFlow_setVariationalRefinementAlpha",  [](cv::Ptr<DISOpticalFlow> &cobj, float &val) { cobj->setVariationalRefinementAlpha(val);  ;})
		 setVariationalRefinementAlpha(val::float) -> nothing
		 getVariationalRefinementDelta
		 .method("jlopencv_cv_DISOpticalFlow_getVariationalRefinementDelta",  [](cv::Ptr<DISOpticalFlow> &cobj) { auto retval = cobj->getVariationalRefinementDelta();  return retval;})
		 getVariationalRefinementDelta() -> ( retval::float ) 
		 setVariationalRefinementDelta
		 .method("jlopencv_cv_DISOpticalFlow_setVariationalRefinementDelta",  [](cv::Ptr<DISOpticalFlow> &cobj, float &val) { cobj->setVariationalRefinementDelta(val);  ;})
		 setVariationalRefinementDelta(val::float) -> nothing
		 getVariationalRefinementGamma
		 .method("jlopencv_cv_DISOpticalFlow_getVariationalRefinementGamma",  [](cv::Ptr<DISOpticalFlow> &cobj) { auto retval = cobj->getVariationalRefinementGamma();  return retval;})
		 getVariationalRefinementGamma() -> ( retval::float ) 
		 setVariationalRefinementGamma
		 .method("jlopencv_cv_DISOpticalFlow_setVariationalRefinementGamma",  [](cv::Ptr<DISOpticalFlow> &cobj, float &val) { cobj->setVariationalRefinementGamma(val);  ;})
		 setVariationalRefinementGamma(val::float) -> nothing
		 getUseMeanNormalization
		 .method("jlopencv_cv_DISOpticalFlow_getUseMeanNormalization",  [](cv::Ptr<DISOpticalFlow> &cobj) { auto retval = cobj->getUseMeanNormalization();  return retval;})
		 getUseMeanNormalization() -> ( retval::bool ) 
		 setUseMeanNormalization
		 .method("jlopencv_cv_DISOpticalFlow_setUseMeanNormalization",  [](cv::Ptr<DISOpticalFlow> &cobj, bool &val) { cobj->setUseMeanNormalization(val);  ;})
		 setUseMeanNormalization(val::bool) -> nothing
		 getUseSpatialPropagation
		 .method("jlopencv_cv_DISOpticalFlow_getUseSpatialPropagation",  [](cv::Ptr<DISOpticalFlow> &cobj) { auto retval = cobj->getUseSpatialPropagation();  return retval;})
		 getUseSpatialPropagation() -> ( retval::bool ) 
		 setUseSpatialPropagation
		 .method("jlopencv_cv_DISOpticalFlow_setUseSpatialPropagation",  [](cv::Ptr<DISOpticalFlow> &cobj, bool &val) { cobj->setUseSpatialPropagation(val);  ;})
		 setUseSpatialPropagation(val::bool) -> nothing
		 create
		 .method("jlopencv_cv_DISOpticalFlow_create",  [](cv::Ptr<DISOpticalFlow> &cobj, int &preset) { auto retval = cv::DISOpticalFlow::create(preset); return retval;})
		 create(preset::int) -> ( retval::Ptr<DISOpticalFlow> ) 
	 WIP
	 function Base.getproperty(m::DISOpticalFlow, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::DISOpticalFlow, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 SparsePyrLKOpticalFlow True
		 getWinSize
		 .method("jlopencv_cv_SparsePyrLKOpticalFlow_getWinSize",  [](cv::Ptr<SparsePyrLKOpticalFlow> &cobj) { auto retval = cobj->getWinSize();  return retval;})
		 getWinSize() -> ( retval::Size ) 
		 setWinSize
		 .method("jlopencv_cv_SparsePyrLKOpticalFlow_setWinSize",  [](cv::Ptr<SparsePyrLKOpticalFlow> &cobj, Size &winSize) { cobj->setWinSize(winSize);  ;})
		 setWinSize(winSize::Size) -> nothing
		 getMaxLevel
		 .method("jlopencv_cv_SparsePyrLKOpticalFlow_getMaxLevel",  [](cv::Ptr<SparsePyrLKOpticalFlow> &cobj) { auto retval = cobj->getMaxLevel();  return retval;})
		 getMaxLevel() -> ( retval::int ) 
		 setMaxLevel
		 .method("jlopencv_cv_SparsePyrLKOpticalFlow_setMaxLevel",  [](cv::Ptr<SparsePyrLKOpticalFlow> &cobj, int &maxLevel) { cobj->setMaxLevel(maxLevel);  ;})
		 setMaxLevel(maxLevel::int) -> nothing
		 getTermCriteria
		 .method("jlopencv_cv_SparsePyrLKOpticalFlow_getTermCriteria",  [](cv::Ptr<SparsePyrLKOpticalFlow> &cobj) { auto retval = cobj->getTermCriteria();  return retval;})
		 getTermCriteria() -> ( retval::TermCriteria ) 
		 setTermCriteria
		 .method("jlopencv_cv_SparsePyrLKOpticalFlow_setTermCriteria",  [](cv::Ptr<SparsePyrLKOpticalFlow> &cobj, TermCriteria &crit) { cobj->setTermCriteria(crit);  ;})
		 setTermCriteria(crit::TermCriteria) -> nothing
		 getFlags
		 .method("jlopencv_cv_SparsePyrLKOpticalFlow_getFlags",  [](cv::Ptr<SparsePyrLKOpticalFlow> &cobj) { auto retval = cobj->getFlags();  return retval;})
		 getFlags() -> ( retval::int ) 
		 setFlags
		 .method("jlopencv_cv_SparsePyrLKOpticalFlow_setFlags",  [](cv::Ptr<SparsePyrLKOpticalFlow> &cobj, int &flags) { cobj->setFlags(flags);  ;})
		 setFlags(flags::int) -> nothing
		 getMinEigThreshold
		 .method("jlopencv_cv_SparsePyrLKOpticalFlow_getMinEigThreshold",  [](cv::Ptr<SparsePyrLKOpticalFlow> &cobj) { auto retval = cobj->getMinEigThreshold();  return retval;})
		 getMinEigThreshold() -> ( retval::double ) 
		 setMinEigThreshold
		 .method("jlopencv_cv_SparsePyrLKOpticalFlow_setMinEigThreshold",  [](cv::Ptr<SparsePyrLKOpticalFlow> &cobj, double &minEigThreshold) { cobj->setMinEigThreshold(minEigThreshold);  ;})
		 setMinEigThreshold(minEigThreshold::double) -> nothing
		 create
		 .method("jlopencv_cv_SparsePyrLKOpticalFlow_create",  [](cv::Ptr<SparsePyrLKOpticalFlow> &cobj, Size &winSize, int &maxLevel, TermCriteria &crit, int &flags, double &minEigThreshold) { auto retval = cv::SparsePyrLKOpticalFlow::create(winSize, maxLevel, crit, flags, minEigThreshold); return retval;})
		 create(winSize::Size, maxLevel::int, crit::TermCriteria, flags::int, minEigThreshold::double) -> ( retval::Ptr<SparsePyrLKOpticalFlow> ) 
	 WIP
	 function Base.getproperty(m::SparsePyrLKOpticalFlow, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::SparsePyrLKOpticalFlow, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 BackgroundSubtractor True
		 apply
		 .method("jlopencv_cv_BackgroundSubtractor_apply",  [](cv::Ptr<BackgroundSubtractor> &cobj, Mat &image, Mat &fgmask, double &learningRate) { cobj->apply(image, fgmask, learningRate);  return fgmask;})
		 apply(image::Mat, fgmask::Mat, learningRate::double) -> ( fgmask::Mat ) 
		 apply
		 .method("jlopencv_cv_BackgroundSubtractor_apply",  [](cv::Ptr<BackgroundSubtractor> &cobj, UMat &image, UMat &fgmask, double &learningRate) { cobj->apply(image, fgmask, learningRate);  return fgmask;})
		 apply(image::UMat, fgmask::UMat, learningRate::double) -> ( fgmask::UMat ) 
		 getBackgroundImage
		 .method("jlopencv_cv_BackgroundSubtractor_getBackgroundImage",  [](cv::Ptr<BackgroundSubtractor> &cobj, Mat &backgroundImage) { cobj->getBackgroundImage(backgroundImage);  return backgroundImage;})
		 getBackgroundImage(; backgroundImage::Mat) -> ( backgroundImage::Mat ) 
		 getBackgroundImage
		 .method("jlopencv_cv_BackgroundSubtractor_getBackgroundImage",  [](cv::Ptr<BackgroundSubtractor> &cobj, UMat &backgroundImage) { cobj->getBackgroundImage(backgroundImage);  return backgroundImage;})
		 getBackgroundImage(; backgroundImage::UMat) -> ( backgroundImage::UMat ) 
	 WIP
	 function Base.getproperty(m::BackgroundSubtractor, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::BackgroundSubtractor, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 BackgroundSubtractorMOG2 True
		 getHistory
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_getHistory",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj) { auto retval = cobj->getHistory();  return retval;})
		 getHistory() -> ( retval::int ) 
		 setHistory
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_setHistory",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj, int &history) { cobj->setHistory(history);  ;})
		 setHistory(history::int) -> nothing
		 getNMixtures
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_getNMixtures",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj) { auto retval = cobj->getNMixtures();  return retval;})
		 getNMixtures() -> ( retval::int ) 
		 setNMixtures
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_setNMixtures",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj, int &nmixtures) { cobj->setNMixtures(nmixtures);  ;})
		 setNMixtures(nmixtures::int) -> nothing
		 getBackgroundRatio
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_getBackgroundRatio",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj) { auto retval = cobj->getBackgroundRatio();  return retval;})
		 getBackgroundRatio() -> ( retval::double ) 
		 setBackgroundRatio
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_setBackgroundRatio",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj, double &ratio) { cobj->setBackgroundRatio(ratio);  ;})
		 setBackgroundRatio(ratio::double) -> nothing
		 getVarThreshold
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_getVarThreshold",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj) { auto retval = cobj->getVarThreshold();  return retval;})
		 getVarThreshold() -> ( retval::double ) 
		 setVarThreshold
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_setVarThreshold",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj, double &varThreshold) { cobj->setVarThreshold(varThreshold);  ;})
		 setVarThreshold(varThreshold::double) -> nothing
		 getVarThresholdGen
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_getVarThresholdGen",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj) { auto retval = cobj->getVarThresholdGen();  return retval;})
		 getVarThresholdGen() -> ( retval::double ) 
		 setVarThresholdGen
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_setVarThresholdGen",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj, double &varThresholdGen) { cobj->setVarThresholdGen(varThresholdGen);  ;})
		 setVarThresholdGen(varThresholdGen::double) -> nothing
		 getVarInit
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_getVarInit",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj) { auto retval = cobj->getVarInit();  return retval;})
		 getVarInit() -> ( retval::double ) 
		 setVarInit
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_setVarInit",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj, double &varInit) { cobj->setVarInit(varInit);  ;})
		 setVarInit(varInit::double) -> nothing
		 getVarMin
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_getVarMin",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj) { auto retval = cobj->getVarMin();  return retval;})
		 getVarMin() -> ( retval::double ) 
		 setVarMin
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_setVarMin",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj, double &varMin) { cobj->setVarMin(varMin);  ;})
		 setVarMin(varMin::double) -> nothing
		 getVarMax
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_getVarMax",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj) { auto retval = cobj->getVarMax();  return retval;})
		 getVarMax() -> ( retval::double ) 
		 setVarMax
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_setVarMax",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj, double &varMax) { cobj->setVarMax(varMax);  ;})
		 setVarMax(varMax::double) -> nothing
		 getComplexityReductionThreshold
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_getComplexityReductionThreshold",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj) { auto retval = cobj->getComplexityReductionThreshold();  return retval;})
		 getComplexityReductionThreshold() -> ( retval::double ) 
		 setComplexityReductionThreshold
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_setComplexityReductionThreshold",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj, double &ct) { cobj->setComplexityReductionThreshold(ct);  ;})
		 setComplexityReductionThreshold(ct::double) -> nothing
		 getDetectShadows
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_getDetectShadows",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj) { auto retval = cobj->getDetectShadows();  return retval;})
		 getDetectShadows() -> ( retval::bool ) 
		 setDetectShadows
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_setDetectShadows",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj, bool &detectShadows) { cobj->setDetectShadows(detectShadows);  ;})
		 setDetectShadows(detectShadows::bool) -> nothing
		 getShadowValue
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_getShadowValue",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj) { auto retval = cobj->getShadowValue();  return retval;})
		 getShadowValue() -> ( retval::int ) 
		 setShadowValue
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_setShadowValue",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj, int &value) { cobj->setShadowValue(value);  ;})
		 setShadowValue(value::int) -> nothing
		 getShadowThreshold
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_getShadowThreshold",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj) { auto retval = cobj->getShadowThreshold();  return retval;})
		 getShadowThreshold() -> ( retval::double ) 
		 setShadowThreshold
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_setShadowThreshold",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj, double &threshold) { cobj->setShadowThreshold(threshold);  ;})
		 setShadowThreshold(threshold::double) -> nothing
		 apply
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_apply",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj, Mat &image, Mat &fgmask, double &learningRate) { cobj->apply(image, fgmask, learningRate);  return fgmask;})
		 apply(image::Mat, fgmask::Mat, learningRate::double) -> ( fgmask::Mat ) 
		 apply
		 .method("jlopencv_cv_BackgroundSubtractorMOG2_apply",  [](cv::Ptr<BackgroundSubtractorMOG2> &cobj, UMat &image, UMat &fgmask, double &learningRate) { cobj->apply(image, fgmask, learningRate);  return fgmask;})
		 apply(image::UMat, fgmask::UMat, learningRate::double) -> ( fgmask::UMat ) 
	 WIP
	 function Base.getproperty(m::BackgroundSubtractorMOG2, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::BackgroundSubtractorMOG2, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 BackgroundSubtractorKNN True
		 getHistory
		 .method("jlopencv_cv_BackgroundSubtractorKNN_getHistory",  [](cv::Ptr<BackgroundSubtractorKNN> &cobj) { auto retval = cobj->getHistory();  return retval;})
		 getHistory() -> ( retval::int ) 
		 setHistory
		 .method("jlopencv_cv_BackgroundSubtractorKNN_setHistory",  [](cv::Ptr<BackgroundSubtractorKNN> &cobj, int &history) { cobj->setHistory(history);  ;})
		 setHistory(history::int) -> nothing
		 getNSamples
		 .method("jlopencv_cv_BackgroundSubtractorKNN_getNSamples",  [](cv::Ptr<BackgroundSubtractorKNN> &cobj) { auto retval = cobj->getNSamples();  return retval;})
		 getNSamples() -> ( retval::int ) 
		 setNSamples
		 .method("jlopencv_cv_BackgroundSubtractorKNN_setNSamples",  [](cv::Ptr<BackgroundSubtractorKNN> &cobj, int &_nN) { cobj->setNSamples(_nN);  ;})
		 setNSamples(_nN::int) -> nothing
		 getDist2Threshold
		 .method("jlopencv_cv_BackgroundSubtractorKNN_getDist2Threshold",  [](cv::Ptr<BackgroundSubtractorKNN> &cobj) { auto retval = cobj->getDist2Threshold();  return retval;})
		 getDist2Threshold() -> ( retval::double ) 
		 setDist2Threshold
		 .method("jlopencv_cv_BackgroundSubtractorKNN_setDist2Threshold",  [](cv::Ptr<BackgroundSubtractorKNN> &cobj, double &_dist2Threshold) { cobj->setDist2Threshold(_dist2Threshold);  ;})
		 setDist2Threshold(_dist2Threshold::double) -> nothing
		 getkNNSamples
		 .method("jlopencv_cv_BackgroundSubtractorKNN_getkNNSamples",  [](cv::Ptr<BackgroundSubtractorKNN> &cobj) { auto retval = cobj->getkNNSamples();  return retval;})
		 getkNNSamples() -> ( retval::int ) 
		 setkNNSamples
		 .method("jlopencv_cv_BackgroundSubtractorKNN_setkNNSamples",  [](cv::Ptr<BackgroundSubtractorKNN> &cobj, int &_nkNN) { cobj->setkNNSamples(_nkNN);  ;})
		 setkNNSamples(_nkNN::int) -> nothing
		 getDetectShadows
		 .method("jlopencv_cv_BackgroundSubtractorKNN_getDetectShadows",  [](cv::Ptr<BackgroundSubtractorKNN> &cobj) { auto retval = cobj->getDetectShadows();  return retval;})
		 getDetectShadows() -> ( retval::bool ) 
		 setDetectShadows
		 .method("jlopencv_cv_BackgroundSubtractorKNN_setDetectShadows",  [](cv::Ptr<BackgroundSubtractorKNN> &cobj, bool &detectShadows) { cobj->setDetectShadows(detectShadows);  ;})
		 setDetectShadows(detectShadows::bool) -> nothing
		 getShadowValue
		 .method("jlopencv_cv_BackgroundSubtractorKNN_getShadowValue",  [](cv::Ptr<BackgroundSubtractorKNN> &cobj) { auto retval = cobj->getShadowValue();  return retval;})
		 getShadowValue() -> ( retval::int ) 
		 setShadowValue
		 .method("jlopencv_cv_BackgroundSubtractorKNN_setShadowValue",  [](cv::Ptr<BackgroundSubtractorKNN> &cobj, int &value) { cobj->setShadowValue(value);  ;})
		 setShadowValue(value::int) -> nothing
		 getShadowThreshold
		 .method("jlopencv_cv_BackgroundSubtractorKNN_getShadowThreshold",  [](cv::Ptr<BackgroundSubtractorKNN> &cobj) { auto retval = cobj->getShadowThreshold();  return retval;})
		 getShadowThreshold() -> ( retval::double ) 
		 setShadowThreshold
		 .method("jlopencv_cv_BackgroundSubtractorKNN_setShadowThreshold",  [](cv::Ptr<BackgroundSubtractorKNN> &cobj, double &threshold) { cobj->setShadowThreshold(threshold);  ;})
		 setShadowThreshold(threshold::double) -> nothing
	 WIP
	 function Base.getproperty(m::BackgroundSubtractorKNN, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::BackgroundSubtractorKNN, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 BaseCascadeClassifier True
	 WIP
	 function Base.getproperty(m::BaseCascadeClassifier, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::BaseCascadeClassifier, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 CascadeClassifier False
		 empty
		 .method("jlopencv_cv_CascadeClassifier_empty",  [](CascadeClassifier &cobj) { auto retval = cobj.empty();  return retval;})
		 empty() -> ( retval::bool ) 
		 load
		 .method("jlopencv_cv_CascadeClassifier_load",  [](CascadeClassifier &cobj, String &filename) { auto retval = cobj.load(filename);  return retval;})
		 load(filename::String) -> ( retval::bool ) 
		 read
		 .method("jlopencv_cv_CascadeClassifier_read",  [](CascadeClassifier &cobj, FileNode &node) { auto retval = cobj.read(node);  return retval;})
		 read(node::FileNode) -> ( retval::bool ) 
		 detectMultiScale
		 .method("jlopencv_cv_CascadeClassifier_detectMultiScale",  [](CascadeClassifier &cobj, Mat &image, double &scaleFactor, int &minNeighbors, int &flags, Size &minSize, Size &maxSize) {vector<Rect> objects; cobj.detectMultiScale(image, objects, scaleFactor, minNeighbors, flags, minSize, maxSize);  return objects;})
		 detectMultiScale(image::Mat, scaleFactor::double, minNeighbors::int, flags::int, minSize::Size, maxSize::Size) -> ( objects::vector<Rect> ) 
		 detectMultiScale
		 .method("jlopencv_cv_CascadeClassifier_detectMultiScale",  [](CascadeClassifier &cobj, UMat &image, double &scaleFactor, int &minNeighbors, int &flags, Size &minSize, Size &maxSize) {vector<Rect> objects; cobj.detectMultiScale(image, objects, scaleFactor, minNeighbors, flags, minSize, maxSize);  return objects;})
		 detectMultiScale(image::UMat, scaleFactor::double, minNeighbors::int, flags::int, minSize::Size, maxSize::Size) -> ( objects::vector<Rect> ) 
		 detectMultiScale2
		 .method("jlopencv_cv_CascadeClassifier_detectMultiScale2",  [](CascadeClassifier &cobj, Mat &image, double &scaleFactor, int &minNeighbors, int &flags, Size &minSize, Size &maxSize) {vector<Rect> objects;vector<int> numDetections; cobj.detectMultiScale2(image, objects, numDetections, scaleFactor, minNeighbors, flags, minSize, maxSize);  return make_tuple<vector<Rect>,vector<int>>(objects,numDetections);})
		 detectMultiScale2(image::Mat, scaleFactor::double, minNeighbors::int, flags::int, minSize::Size, maxSize::Size) -> ( objects::vector<Rect>, numDetections::vector<int> ) 
		 detectMultiScale2
		 .method("jlopencv_cv_CascadeClassifier_detectMultiScale2",  [](CascadeClassifier &cobj, UMat &image, double &scaleFactor, int &minNeighbors, int &flags, Size &minSize, Size &maxSize) {vector<Rect> objects;vector<int> numDetections; cobj.detectMultiScale2(image, objects, numDetections, scaleFactor, minNeighbors, flags, minSize, maxSize);  return make_tuple<vector<Rect>,vector<int>>(objects,numDetections);})
		 detectMultiScale2(image::UMat, scaleFactor::double, minNeighbors::int, flags::int, minSize::Size, maxSize::Size) -> ( objects::vector<Rect>, numDetections::vector<int> ) 
		 detectMultiScale3
		 .method("jlopencv_cv_CascadeClassifier_detectMultiScale3",  [](CascadeClassifier &cobj, Mat &image, double &scaleFactor, int &minNeighbors, int &flags, Size &minSize, Size &maxSize, bool &outputRejectLevels) {vector<Rect> objects;vector<int> rejectLevels;vector<double> levelWeights; cobj.detectMultiScale3(image, objects, rejectLevels, levelWeights, scaleFactor, minNeighbors, flags, minSize, maxSize, outputRejectLevels);  return make_tuple<vector<Rect>,vector<int>,vector<double>>(objects,rejectLevels,levelWeights);})
		 detectMultiScale3(image::Mat, scaleFactor::double, minNeighbors::int, flags::int, minSize::Size, maxSize::Size, outputRejectLevels::bool) -> ( objects::vector<Rect>, rejectLevels::vector<int>, levelWeights::vector<double> ) 
		 detectMultiScale3
		 .method("jlopencv_cv_CascadeClassifier_detectMultiScale3",  [](CascadeClassifier &cobj, UMat &image, double &scaleFactor, int &minNeighbors, int &flags, Size &minSize, Size &maxSize, bool &outputRejectLevels) {vector<Rect> objects;vector<int> rejectLevels;vector<double> levelWeights; cobj.detectMultiScale3(image, objects, rejectLevels, levelWeights, scaleFactor, minNeighbors, flags, minSize, maxSize, outputRejectLevels);  return make_tuple<vector<Rect>,vector<int>,vector<double>>(objects,rejectLevels,levelWeights);})
		 detectMultiScale3(image::UMat, scaleFactor::double, minNeighbors::int, flags::int, minSize::Size, maxSize::Size, outputRejectLevels::bool) -> ( objects::vector<Rect>, rejectLevels::vector<int>, levelWeights::vector<double> ) 
		 isOldFormatCascade
		 .method("jlopencv_cv_CascadeClassifier_isOldFormatCascade",  [](CascadeClassifier &cobj) { auto retval = cobj.isOldFormatCascade();  return retval;})
		 isOldFormatCascade() -> ( retval::bool ) 
		 getOriginalWindowSize
		 .method("jlopencv_cv_CascadeClassifier_getOriginalWindowSize",  [](CascadeClassifier &cobj) { auto retval = cobj.getOriginalWindowSize();  return retval;})
		 getOriginalWindowSize() -> ( retval::Size ) 
		 getFeatureType
		 .method("jlopencv_cv_CascadeClassifier_getFeatureType",  [](CascadeClassifier &cobj) { auto retval = cobj.getFeatureType();  return retval;})
		 getFeatureType() -> ( retval::int ) 
		 convert
		 .method("jlopencv_cv_CascadeClassifier_convert",  [](CascadeClassifier &cobj, String &oldcascade, String &newcascade) { auto retval = cv::CascadeClassifier::convert(oldcascade, newcascade); return retval;})
		 convert(oldcascade::String, newcascade::String) -> ( retval::bool ) 
	 .add_type<cv::CascadeClassifier>("CascadeClassifier").constructor<>().constructor<const String&>()
	 function Base.getproperty(m::CascadeClassifier, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::CascadeClassifier, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 HOGDescriptor False
		 getDescriptorSize
		 .method("jlopencv_cv_HOGDescriptor_getDescriptorSize",  [](HOGDescriptor &cobj) { auto retval = cobj.getDescriptorSize();  return retval;})
		 getDescriptorSize() -> ( retval::size_t ) 
		 checkDetectorSize
		 .method("jlopencv_cv_HOGDescriptor_checkDetectorSize",  [](HOGDescriptor &cobj) { auto retval = cobj.checkDetectorSize();  return retval;})
		 checkDetectorSize() -> ( retval::bool ) 
		 getWinSigma
		 .method("jlopencv_cv_HOGDescriptor_getWinSigma",  [](HOGDescriptor &cobj) { auto retval = cobj.getWinSigma();  return retval;})
		 getWinSigma() -> ( retval::double ) 
		 setSVMDetector
		 .method("jlopencv_cv_HOGDescriptor_setSVMDetector",  [](HOGDescriptor &cobj, Mat &svmdetector) { cobj.setSVMDetector(svmdetector);  ;})
		 setSVMDetector(svmdetector::Mat) -> nothing
		 setSVMDetector
		 .method("jlopencv_cv_HOGDescriptor_setSVMDetector",  [](HOGDescriptor &cobj, UMat &svmdetector) { cobj.setSVMDetector(svmdetector);  ;})
		 setSVMDetector(svmdetector::UMat) -> nothing
		 load
		 .method("jlopencv_cv_HOGDescriptor_load",  [](HOGDescriptor &cobj, String &filename, String &objname) { auto retval = cobj.load(filename, objname);  return retval;})
		 load(filename::String, objname::String) -> ( retval::bool ) 
		 save
		 .method("jlopencv_cv_HOGDescriptor_save",  [](HOGDescriptor &cobj, String &filename, String &objname) { cobj.save(filename, objname);  ;})
		 save(filename::String, objname::String) -> nothing
		 compute
		 .method("jlopencv_cv_HOGDescriptor_compute",  [](HOGDescriptor &cobj, Mat &img, Size &winStride, Size &padding, vector<Point> &locations) {vector<float> descriptors; cobj.compute(img, descriptors, winStride, padding, locations);  return descriptors;})
		 compute(img::Mat, winStride::Size, padding::Size, locations::vector<Point>) -> ( descriptors::vector<float> ) 
		 compute
		 .method("jlopencv_cv_HOGDescriptor_compute",  [](HOGDescriptor &cobj, UMat &img, Size &winStride, Size &padding, vector<Point> &locations) {vector<float> descriptors; cobj.compute(img, descriptors, winStride, padding, locations);  return descriptors;})
		 compute(img::UMat, winStride::Size, padding::Size, locations::vector<Point>) -> ( descriptors::vector<float> ) 
		 detect
		 .method("jlopencv_cv_HOGDescriptor_detect",  [](HOGDescriptor &cobj, Mat &img, double &hitThreshold, Size &winStride, Size &padding, vector<Point> &searchLocations) {vector<Point> foundLocations;vector<double> weights; cobj.detect(img, foundLocations, weights, hitThreshold, winStride, padding, searchLocations);  return make_tuple<vector<Point>,vector<double>>(foundLocations,weights);})
		 detect(img::Mat, hitThreshold::double, winStride::Size, padding::Size, searchLocations::vector<Point>) -> ( foundLocations::vector<Point>, weights::vector<double> ) 
		 detect
		 .method("jlopencv_cv_HOGDescriptor_detect",  [](HOGDescriptor &cobj, UMat &img, double &hitThreshold, Size &winStride, Size &padding, vector<Point> &searchLocations) {vector<Point> foundLocations;vector<double> weights; cobj.detect(img, foundLocations, weights, hitThreshold, winStride, padding, searchLocations);  return make_tuple<vector<Point>,vector<double>>(foundLocations,weights);})
		 detect(img::UMat, hitThreshold::double, winStride::Size, padding::Size, searchLocations::vector<Point>) -> ( foundLocations::vector<Point>, weights::vector<double> ) 
		 detectMultiScale
		 .method("jlopencv_cv_HOGDescriptor_detectMultiScale",  [](HOGDescriptor &cobj, Mat &img, double &hitThreshold, Size &winStride, Size &padding, double &scale, double &finalThreshold, bool &useMeanshiftGrouping) {vector<Rect> foundLocations;vector<double> foundWeights; cobj.detectMultiScale(img, foundLocations, foundWeights, hitThreshold, winStride, padding, scale, finalThreshold, useMeanshiftGrouping);  return make_tuple<vector<Rect>,vector<double>>(foundLocations,foundWeights);})
		 detectMultiScale(img::Mat, hitThreshold::double, winStride::Size, padding::Size, scale::double, finalThreshold::double, useMeanshiftGrouping::bool) -> ( foundLocations::vector<Rect>, foundWeights::vector<double> ) 
		 detectMultiScale
		 .method("jlopencv_cv_HOGDescriptor_detectMultiScale",  [](HOGDescriptor &cobj, UMat &img, double &hitThreshold, Size &winStride, Size &padding, double &scale, double &finalThreshold, bool &useMeanshiftGrouping) {vector<Rect> foundLocations;vector<double> foundWeights; cobj.detectMultiScale(img, foundLocations, foundWeights, hitThreshold, winStride, padding, scale, finalThreshold, useMeanshiftGrouping);  return make_tuple<vector<Rect>,vector<double>>(foundLocations,foundWeights);})
		 detectMultiScale(img::UMat, hitThreshold::double, winStride::Size, padding::Size, scale::double, finalThreshold::double, useMeanshiftGrouping::bool) -> ( foundLocations::vector<Rect>, foundWeights::vector<double> ) 
		 computeGradient
		 .method("jlopencv_cv_HOGDescriptor_computeGradient",  [](HOGDescriptor &cobj, Mat &img, Mat &grad, Mat &angleOfs, Size &paddingTL, Size &paddingBR) { cobj.computeGradient(img, grad, angleOfs, paddingTL, paddingBR);  return make_tuple<Mat,Mat>(grad,angleOfs);})
		 computeGradient(img::Mat, grad::Mat, angleOfs::Mat, paddingTL::Size, paddingBR::Size) -> ( grad::Mat, angleOfs::Mat ) 
		 computeGradient
		 .method("jlopencv_cv_HOGDescriptor_computeGradient",  [](HOGDescriptor &cobj, UMat &img, UMat &grad, UMat &angleOfs, Size &paddingTL, Size &paddingBR) { cobj.computeGradient(img, grad, angleOfs, paddingTL, paddingBR);  return make_tuple<UMat,UMat>(grad,angleOfs);})
		 computeGradient(img::UMat, grad::UMat, angleOfs::UMat, paddingTL::Size, paddingBR::Size) -> ( grad::UMat, angleOfs::UMat ) 
		 getDefaultPeopleDetector
		 .method("jlopencv_cv_HOGDescriptor_getDefaultPeopleDetector",  [](HOGDescriptor &cobj) { auto retval = cv::HOGDescriptor::getDefaultPeopleDetector(); return retval;})
		 getDefaultPeopleDetector() -> ( retval::std::vector<float> ) 
		 getDaimlerPeopleDetector
		 .method("jlopencv_cv_HOGDescriptor_getDaimlerPeopleDetector",  [](HOGDescriptor &cobj) { auto retval = cv::HOGDescriptor::getDaimlerPeopleDetector(); return retval;})
		 getDaimlerPeopleDetector() -> ( retval::std::vector<float> ) 
	 .add_type<cv::HOGDescriptor>("HOGDescriptor").constructor<>().constructor<const Size&,const Size&,const Size&,const Size&,const int&,const int&,const double&,const HOGDescriptor_HistogramNormType&,const double&,const bool&,const int&,const bool&>().constructor<const String&>().method("jlopencv_HOGDescriptor_get_winSize", [](const cv::HOGDescriptor &cobj) {return cobj.winSize;}).method("jlopencv_HOGDescriptor_get_blockSize", [](const cv::HOGDescriptor &cobj) {return cobj.blockSize;}).method("jlopencv_HOGDescriptor_get_blockStride", [](const cv::HOGDescriptor &cobj) {return cobj.blockStride;}).method("jlopencv_HOGDescriptor_get_cellSize", [](const cv::HOGDescriptor &cobj) {return cobj.cellSize;}).method("jlopencv_HOGDescriptor_get_nbins", [](const cv::HOGDescriptor &cobj) {return cobj.nbins;}).method("jlopencv_HOGDescriptor_get_derivAperture", [](const cv::HOGDescriptor &cobj) {return cobj.derivAperture;}).method("jlopencv_HOGDescriptor_get_winSigma", [](const cv::HOGDescriptor &cobj) {return cobj.winSigma;}).method("jlopencv_HOGDescriptor_get_histogramNormType", [](const cv::HOGDescriptor &cobj) {return cobj.histogramNormType;}).method("jlopencv_HOGDescriptor_get_L2HysThreshold", [](const cv::HOGDescriptor &cobj) {return cobj.L2HysThreshold;}).method("jlopencv_HOGDescriptor_get_gammaCorrection", [](const cv::HOGDescriptor &cobj) {return cobj.gammaCorrection;}).method("jlopencv_HOGDescriptor_get_svmDetector", [](const cv::HOGDescriptor &cobj) {return cobj.svmDetector;}).method("jlopencv_HOGDescriptor_get_nlevels", [](const cv::HOGDescriptor &cobj) {return cobj.nlevels;}).method("jlopencv_HOGDescriptor_get_signedGradient", [](const cv::HOGDescriptor &cobj) {return cobj.signedGradient;})
	 function Base.getproperty(m::HOGDescriptor, s::Symbol)
    if s==:winSize
        return jlopencv_argconvert_jl(jlopencv_HOGDescriptor_get_winSize(m))
    end
    if s==:blockSize
        return jlopencv_argconvert_jl(jlopencv_HOGDescriptor_get_blockSize(m))
    end
    if s==:blockStride
        return jlopencv_argconvert_jl(jlopencv_HOGDescriptor_get_blockStride(m))
    end
    if s==:cellSize
        return jlopencv_argconvert_jl(jlopencv_HOGDescriptor_get_cellSize(m))
    end
    if s==:nbins
        return jlopencv_argconvert_jl(jlopencv_HOGDescriptor_get_nbins(m))
    end
    if s==:derivAperture
        return jlopencv_argconvert_jl(jlopencv_HOGDescriptor_get_derivAperture(m))
    end
    if s==:winSigma
        return jlopencv_argconvert_jl(jlopencv_HOGDescriptor_get_winSigma(m))
    end
    if s==:histogramNormType
        return jlopencv_argconvert_jl(jlopencv_HOGDescriptor_get_histogramNormType(m))
    end
    if s==:L2HysThreshold
        return jlopencv_argconvert_jl(jlopencv_HOGDescriptor_get_L2HysThreshold(m))
    end
    if s==:gammaCorrection
        return jlopencv_argconvert_jl(jlopencv_HOGDescriptor_get_gammaCorrection(m))
    end
    if s==:svmDetector
        return jlopencv_argconvert_jl(jlopencv_HOGDescriptor_get_svmDetector(m))
    end
    if s==:nlevels
        return jlopencv_argconvert_jl(jlopencv_HOGDescriptor_get_nlevels(m))
    end
    if s==:signedGradient
        return jlopencv_argconvert_jl(jlopencv_HOGDescriptor_get_signedGradient(m))
    end
    return Base.getfield(m, s)
end
function Base.setproperty!(m::HOGDescriptor, s::Symbol, v)
    if s==:winSize
        jlopencv_HOGDescriptor_set_winSize(m, jlopencv_argconvert_cpp(v))
    end
    if s==:blockSize
        jlopencv_HOGDescriptor_set_blockSize(m, jlopencv_argconvert_cpp(v))
    end
    if s==:blockStride
        jlopencv_HOGDescriptor_set_blockStride(m, jlopencv_argconvert_cpp(v))
    end
    if s==:cellSize
        jlopencv_HOGDescriptor_set_cellSize(m, jlopencv_argconvert_cpp(v))
    end
    if s==:nbins
        jlopencv_HOGDescriptor_set_nbins(m, jlopencv_argconvert_cpp(v))
    end
    if s==:derivAperture
        jlopencv_HOGDescriptor_set_derivAperture(m, jlopencv_argconvert_cpp(v))
    end
    if s==:winSigma
        jlopencv_HOGDescriptor_set_winSigma(m, jlopencv_argconvert_cpp(v))
    end
    if s==:histogramNormType
        jlopencv_HOGDescriptor_set_histogramNormType(m, jlopencv_argconvert_cpp(v))
    end
    if s==:L2HysThreshold
        jlopencv_HOGDescriptor_set_L2HysThreshold(m, jlopencv_argconvert_cpp(v))
    end
    if s==:gammaCorrection
        jlopencv_HOGDescriptor_set_gammaCorrection(m, jlopencv_argconvert_cpp(v))
    end
    if s==:svmDetector
        jlopencv_HOGDescriptor_set_svmDetector(m, jlopencv_argconvert_cpp(v))
    end
    if s==:nlevels
        jlopencv_HOGDescriptor_set_nlevels(m, jlopencv_argconvert_cpp(v))
    end
    if s==:signedGradient
        jlopencv_HOGDescriptor_set_signedGradient(m, jlopencv_argconvert_cpp(v))
    end
    return Base.setfield(m, s, v)
end

	 QRCodeDetector False
		 setEpsX
		 .method("jlopencv_cv_QRCodeDetector_setEpsX",  [](QRCodeDetector &cobj, double &epsX) { cobj.setEpsX(epsX);  ;})
		 setEpsX(epsX::double) -> nothing
		 setEpsY
		 .method("jlopencv_cv_QRCodeDetector_setEpsY",  [](QRCodeDetector &cobj, double &epsY) { cobj.setEpsY(epsY);  ;})
		 setEpsY(epsY::double) -> nothing
		 detect
		 .method("jlopencv_cv_QRCodeDetector_detect",  [](QRCodeDetector &cobj, Mat &img, Mat &points) { auto retval = cobj.detect(img, points);  return make_tuple<bool,Mat>(retval,points);})
		 detect(img::Mat; points::Mat) -> ( retval::bool, points::Mat ) 
		 detect
		 .method("jlopencv_cv_QRCodeDetector_detect",  [](QRCodeDetector &cobj, UMat &img, UMat &points) { auto retval = cobj.detect(img, points);  return make_tuple<bool,UMat>(retval,points);})
		 detect(img::UMat; points::UMat) -> ( retval::bool, points::UMat ) 
		 decode
		 .method("jlopencv_cv_QRCodeDetector_decode",  [](QRCodeDetector &cobj, Mat &img, Mat &points, Mat &straight_qrcode) { auto retval = cobj.decode(img, points, straight_qrcode);  return make_tuple<std::string,Mat>(retval,straight_qrcode);})
		 decode(img::Mat, points::Mat; straight_qrcode::Mat) -> ( retval::std::string, straight_qrcode::Mat ) 
		 decode
		 .method("jlopencv_cv_QRCodeDetector_decode",  [](QRCodeDetector &cobj, UMat &img, UMat &points, UMat &straight_qrcode) { auto retval = cobj.decode(img, points, straight_qrcode);  return make_tuple<std::string,UMat>(retval,straight_qrcode);})
		 decode(img::UMat, points::UMat; straight_qrcode::UMat) -> ( retval::std::string, straight_qrcode::UMat ) 
		 detectAndDecode
		 .method("jlopencv_cv_QRCodeDetector_detectAndDecode",  [](QRCodeDetector &cobj, Mat &img, Mat &points, Mat &straight_qrcode) { auto retval = cobj.detectAndDecode(img, points, straight_qrcode);  return make_tuple<std::string,Mat,Mat>(retval,points,straight_qrcode);})
		 detectAndDecode(img::Mat; points::Mat, straight_qrcode::Mat) -> ( retval::std::string, points::Mat, straight_qrcode::Mat ) 
		 detectAndDecode
		 .method("jlopencv_cv_QRCodeDetector_detectAndDecode",  [](QRCodeDetector &cobj, UMat &img, UMat &points, UMat &straight_qrcode) { auto retval = cobj.detectAndDecode(img, points, straight_qrcode);  return make_tuple<std::string,UMat,UMat>(retval,points,straight_qrcode);})
		 detectAndDecode(img::UMat; points::UMat, straight_qrcode::UMat) -> ( retval::std::string, points::UMat, straight_qrcode::UMat ) 
		 detectMulti
		 .method("jlopencv_cv_QRCodeDetector_detectMulti",  [](QRCodeDetector &cobj, Mat &img, Mat &points) { auto retval = cobj.detectMulti(img, points);  return make_tuple<bool,Mat>(retval,points);})
		 detectMulti(img::Mat; points::Mat) -> ( retval::bool, points::Mat ) 
		 detectMulti
		 .method("jlopencv_cv_QRCodeDetector_detectMulti",  [](QRCodeDetector &cobj, UMat &img, UMat &points) { auto retval = cobj.detectMulti(img, points);  return make_tuple<bool,UMat>(retval,points);})
		 detectMulti(img::UMat; points::UMat) -> ( retval::bool, points::UMat ) 
		 decodeMulti
		 .method("jlopencv_cv_QRCodeDetector_decodeMulti",  [](QRCodeDetector &cobj, Mat &img, Mat &points) {vector<string> decoded_info;vector<Mat> straight_qrcode; auto retval = cobj.decodeMulti(img, points, decoded_info, straight_qrcode);  return make_tuple<bool,vector<string>,vector<Mat>>(retval,decoded_info,straight_qrcode);})
		 decodeMulti(img::Mat, points::Mat) -> ( retval::bool, decoded_info::vector<string>, straight_qrcode::vector<Mat> ) 
		 decodeMulti
		 .method("jlopencv_cv_QRCodeDetector_decodeMulti",  [](QRCodeDetector &cobj, UMat &img, UMat &points) {vector<string> decoded_info;vector<UMat> straight_qrcode; auto retval = cobj.decodeMulti(img, points, decoded_info, straight_qrcode);  return make_tuple<bool,vector<string>,vector<UMat>>(retval,decoded_info,straight_qrcode);})
		 decodeMulti(img::UMat, points::UMat) -> ( retval::bool, decoded_info::vector<string>, straight_qrcode::vector<UMat> ) 
		 detectAndDecodeMulti
		 .method("jlopencv_cv_QRCodeDetector_detectAndDecodeMulti",  [](QRCodeDetector &cobj, Mat &img, Mat &points) {vector<string> decoded_info;vector<Mat> straight_qrcode; auto retval = cobj.detectAndDecodeMulti(img, decoded_info, points, straight_qrcode);  return make_tuple<bool,vector<string>,Mat,vector<Mat>>(retval,decoded_info,points,straight_qrcode);})
		 detectAndDecodeMulti(img::Mat; points::Mat) -> ( retval::bool, decoded_info::vector<string>, points::Mat, straight_qrcode::vector<Mat> ) 
		 detectAndDecodeMulti
		 .method("jlopencv_cv_QRCodeDetector_detectAndDecodeMulti",  [](QRCodeDetector &cobj, UMat &img, UMat &points) {vector<string> decoded_info;vector<UMat> straight_qrcode; auto retval = cobj.detectAndDecodeMulti(img, decoded_info, points, straight_qrcode);  return make_tuple<bool,vector<string>,UMat,vector<UMat>>(retval,decoded_info,points,straight_qrcode);})
		 detectAndDecodeMulti(img::UMat; points::UMat) -> ( retval::bool, decoded_info::vector<string>, points::UMat, straight_qrcode::vector<UMat> ) 
	 .add_type<cv::QRCodeDetector>("QRCodeDetector").constructor<>()
	 function Base.getproperty(m::QRCodeDetector, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::QRCodeDetector, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 VideoCapture False
		 open
		 .method("jlopencv_cv_VideoCapture_open",  [](VideoCapture &cobj, String &filename, int &apiPreference) { auto retval = cobj.open(filename, apiPreference);  return retval;})
		 open(filename::String, apiPreference::int) -> ( retval::bool ) 
		 open
		 .method("jlopencv_cv_VideoCapture_open",  [](VideoCapture &cobj, int &index, int &apiPreference) { auto retval = cobj.open(index, apiPreference);  return retval;})
		 open(index::int, apiPreference::int) -> ( retval::bool ) 
		 isOpened
		 .method("jlopencv_cv_VideoCapture_isOpened",  [](VideoCapture &cobj) { auto retval = cobj.isOpened();  return retval;})
		 isOpened() -> ( retval::bool ) 
		 release
		 .method("jlopencv_cv_VideoCapture_release",  [](VideoCapture &cobj) { cobj.release();  ;})
		 release() -> nothing
		 grab
		 .method("jlopencv_cv_VideoCapture_grab",  [](VideoCapture &cobj) { auto retval = cobj.grab();  return retval;})
		 grab() -> ( retval::bool ) 
		 retrieve
		 .method("jlopencv_cv_VideoCapture_retrieve",  [](VideoCapture &cobj, Mat &image, int &flag) { auto retval = cobj.retrieve(image, flag);  return make_tuple<bool,Mat>(retval,image);})
		 retrieve(image::Mat, flag::int) -> ( retval::bool, image::Mat ) 
		 retrieve
		 .method("jlopencv_cv_VideoCapture_retrieve",  [](VideoCapture &cobj, UMat &image, int &flag) { auto retval = cobj.retrieve(image, flag);  return make_tuple<bool,UMat>(retval,image);})
		 retrieve(image::UMat, flag::int) -> ( retval::bool, image::UMat ) 
		 read
		 .method("jlopencv_cv_VideoCapture_read",  [](VideoCapture &cobj, Mat &image) { auto retval = cobj.read(image);  return make_tuple<bool,Mat>(retval,image);})
		 read(; image::Mat) -> ( retval::bool, image::Mat ) 
		 read
		 .method("jlopencv_cv_VideoCapture_read",  [](VideoCapture &cobj, UMat &image) { auto retval = cobj.read(image);  return make_tuple<bool,UMat>(retval,image);})
		 read(; image::UMat) -> ( retval::bool, image::UMat ) 
		 set
		 .method("jlopencv_cv_VideoCapture_set",  [](VideoCapture &cobj, int &propId, double &value) { auto retval = cobj.set(propId, value);  return retval;})
		 set(propId::int, value::double) -> ( retval::bool ) 
		 get
		 .method("jlopencv_cv_VideoCapture_get",  [](VideoCapture &cobj, int &propId) { auto retval = cobj.get(propId);  return retval;})
		 get(propId::int) -> ( retval::double ) 
		 getBackendName
		 .method("jlopencv_cv_VideoCapture_getBackendName",  [](VideoCapture &cobj) { auto retval = cobj.getBackendName();  return retval;})
		 getBackendName() -> ( retval::String ) 
		 setExceptionMode
		 .method("jlopencv_cv_VideoCapture_setExceptionMode",  [](VideoCapture &cobj, bool &enable) { cobj.setExceptionMode(enable);  ;})
		 setExceptionMode(enable::bool) -> nothing
		 getExceptionMode
		 .method("jlopencv_cv_VideoCapture_getExceptionMode",  [](VideoCapture &cobj) { auto retval = cobj.getExceptionMode();  return retval;})
		 getExceptionMode() -> ( retval::bool ) 
	 .add_type<cv::VideoCapture>("VideoCapture").constructor<>().constructor<const String&,const int&>().constructor<const int&,const int&>()
	 function Base.getproperty(m::VideoCapture, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::VideoCapture, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 VideoWriter False
		 open
		 .method("jlopencv_cv_VideoWriter_open",  [](VideoWriter &cobj, String &filename, int &fourcc, double &fps, Size &frameSize, bool &isColor) { auto retval = cobj.open(filename, fourcc, fps, frameSize, isColor);  return retval;})
		 open(filename::String, fourcc::int, fps::double, frameSize::Size, isColor::bool) -> ( retval::bool ) 
		 open
		 .method("jlopencv_cv_VideoWriter_open",  [](VideoWriter &cobj, String &filename, int &apiPreference, int &fourcc, double &fps, Size &frameSize, bool &isColor) { auto retval = cobj.open(filename, apiPreference, fourcc, fps, frameSize, isColor);  return retval;})
		 open(filename::String, apiPreference::int, fourcc::int, fps::double, frameSize::Size, isColor::bool) -> ( retval::bool ) 
		 isOpened
		 .method("jlopencv_cv_VideoWriter_isOpened",  [](VideoWriter &cobj) { auto retval = cobj.isOpened();  return retval;})
		 isOpened() -> ( retval::bool ) 
		 release
		 .method("jlopencv_cv_VideoWriter_release",  [](VideoWriter &cobj) { cobj.release();  ;})
		 release() -> nothing
		 write
		 .method("jlopencv_cv_VideoWriter_write",  [](VideoWriter &cobj, Mat &image) { cobj.write(image);  ;})
		 write(image::Mat) -> nothing
		 write
		 .method("jlopencv_cv_VideoWriter_write",  [](VideoWriter &cobj, UMat &image) { cobj.write(image);  ;})
		 write(image::UMat) -> nothing
		 set
		 .method("jlopencv_cv_VideoWriter_set",  [](VideoWriter &cobj, int &propId, double &value) { auto retval = cobj.set(propId, value);  return retval;})
		 set(propId::int, value::double) -> ( retval::bool ) 
		 get
		 .method("jlopencv_cv_VideoWriter_get",  [](VideoWriter &cobj, int &propId) { auto retval = cobj.get(propId);  return retval;})
		 get(propId::int) -> ( retval::double ) 
		 fourcc
		 .method("jlopencv_cv_VideoWriter_fourcc",  [](VideoWriter &cobj, char &c1, char &c2, char &c3, char &c4) { auto retval = cv::VideoWriter::fourcc(c1, c2, c3, c4); return retval;})
		 fourcc(c1::char, c2::char, c3::char, c4::char) -> ( retval::int ) 
		 getBackendName
		 .method("jlopencv_cv_VideoWriter_getBackendName",  [](VideoWriter &cobj) { auto retval = cobj.getBackendName();  return retval;})
		 getBackendName() -> ( retval::String ) 
	 .add_type<cv::VideoWriter>("VideoWriter").constructor<>().constructor<const String&,const int&,const double&,const Size&,const bool&>().constructor<const String&,const int&,const int&,const double&,const Size&,const bool&>()
	 function Base.getproperty(m::VideoWriter, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::VideoWriter, s::Symbol, v)
    return Base.setfield(m, s, v)
end



	 borderInterpolate
	 .method("jlopencv_cv_borderInterpolate",  [](int &p, int &len, int &borderType) { auto retval = cv::borderInterpolate(p, len, borderType); return retval;})
		 borderInterpolate(p::int, len::int, borderType::int) -> ( retval::int ) 
	 copyMakeBorder
	 .method("jlopencv_cv_copyMakeBorder",  [](Mat &src, int &top, int &bottom, int &left, int &right, int &borderType, Mat &dst, Scalar &value) { cv::copyMakeBorder(src, dst, top, bottom, left, right, borderType, value); return dst;})
		 copyMakeBorder(src::Mat, top::int, bottom::int, left::int, right::int, borderType::int, dst::Mat, value::Scalar) -> ( dst::Mat ) 
	 copyMakeBorder
	 .method("jlopencv_cv_copyMakeBorder",  [](UMat &src, int &top, int &bottom, int &left, int &right, int &borderType, UMat &dst, Scalar &value) { cv::copyMakeBorder(src, dst, top, bottom, left, right, borderType, value); return dst;})
		 copyMakeBorder(src::UMat, top::int, bottom::int, left::int, right::int, borderType::int, dst::UMat, value::Scalar) -> ( dst::UMat ) 
	 add
	 .method("jlopencv_cv_add",  [](Mat &src1, Mat &src2, Mat &dst, Mat &mask, int &dtype) { cv::add(src1, src2, dst, mask, dtype); return dst;})
		 add(src1::Mat, src2::Mat, dst::Mat, mask::Mat, dtype::int) -> ( dst::Mat ) 
	 add
	 .method("jlopencv_cv_add",  [](UMat &src1, UMat &src2, UMat &dst, UMat &mask, int &dtype) { cv::add(src1, src2, dst, mask, dtype); return dst;})
		 add(src1::UMat, src2::UMat, dst::UMat, mask::UMat, dtype::int) -> ( dst::UMat ) 
	 subtract
	 .method("jlopencv_cv_subtract",  [](Mat &src1, Mat &src2, Mat &dst, Mat &mask, int &dtype) { cv::subtract(src1, src2, dst, mask, dtype); return dst;})
		 subtract(src1::Mat, src2::Mat, dst::Mat, mask::Mat, dtype::int) -> ( dst::Mat ) 
	 subtract
	 .method("jlopencv_cv_subtract",  [](UMat &src1, UMat &src2, UMat &dst, UMat &mask, int &dtype) { cv::subtract(src1, src2, dst, mask, dtype); return dst;})
		 subtract(src1::UMat, src2::UMat, dst::UMat, mask::UMat, dtype::int) -> ( dst::UMat ) 
	 multiply
	 .method("jlopencv_cv_multiply",  [](Mat &src1, Mat &src2, Mat &dst, double &scale, int &dtype) { cv::multiply(src1, src2, dst, scale, dtype); return dst;})
		 multiply(src1::Mat, src2::Mat, dst::Mat, scale::double, dtype::int) -> ( dst::Mat ) 
	 multiply
	 .method("jlopencv_cv_multiply",  [](UMat &src1, UMat &src2, UMat &dst, double &scale, int &dtype) { cv::multiply(src1, src2, dst, scale, dtype); return dst;})
		 multiply(src1::UMat, src2::UMat, dst::UMat, scale::double, dtype::int) -> ( dst::UMat ) 
	 divide
	 .method("jlopencv_cv_divide",  [](Mat &src1, Mat &src2, Mat &dst, double &scale, int &dtype) { cv::divide(src1, src2, dst, scale, dtype); return dst;})
		 divide(src1::Mat, src2::Mat, dst::Mat, scale::double, dtype::int) -> ( dst::Mat ) 
	 divide
	 .method("jlopencv_cv_divide",  [](UMat &src1, UMat &src2, UMat &dst, double &scale, int &dtype) { cv::divide(src1, src2, dst, scale, dtype); return dst;})
		 divide(src1::UMat, src2::UMat, dst::UMat, scale::double, dtype::int) -> ( dst::UMat ) 
	 divide
	 .method("jlopencv_cv_divide",  [](double &scale, Mat &src2, Mat &dst, int &dtype) { cv::divide(scale, src2, dst, dtype); return dst;})
		 divide(scale::double, src2::Mat, dst::Mat, dtype::int) -> ( dst::Mat ) 
	 divide
	 .method("jlopencv_cv_divide",  [](double &scale, UMat &src2, UMat &dst, int &dtype) { cv::divide(scale, src2, dst, dtype); return dst;})
		 divide(scale::double, src2::UMat, dst::UMat, dtype::int) -> ( dst::UMat ) 
	 scaleAdd
	 .method("jlopencv_cv_scaleAdd",  [](Mat &src1, double &alpha, Mat &src2, Mat &dst) { cv::scaleAdd(src1, alpha, src2, dst); return dst;})
		 scaleAdd(src1::Mat, alpha::double, src2::Mat; dst::Mat) -> ( dst::Mat ) 
	 scaleAdd
	 .method("jlopencv_cv_scaleAdd",  [](UMat &src1, double &alpha, UMat &src2, UMat &dst) { cv::scaleAdd(src1, alpha, src2, dst); return dst;})
		 scaleAdd(src1::UMat, alpha::double, src2::UMat; dst::UMat) -> ( dst::UMat ) 
	 addWeighted
	 .method("jlopencv_cv_addWeighted",  [](Mat &src1, double &alpha, Mat &src2, double &beta, double &gamma, Mat &dst, int &dtype) { cv::addWeighted(src1, alpha, src2, beta, gamma, dst, dtype); return dst;})
		 addWeighted(src1::Mat, alpha::double, src2::Mat, beta::double, gamma::double, dst::Mat, dtype::int) -> ( dst::Mat ) 
	 addWeighted
	 .method("jlopencv_cv_addWeighted",  [](UMat &src1, double &alpha, UMat &src2, double &beta, double &gamma, UMat &dst, int &dtype) { cv::addWeighted(src1, alpha, src2, beta, gamma, dst, dtype); return dst;})
		 addWeighted(src1::UMat, alpha::double, src2::UMat, beta::double, gamma::double, dst::UMat, dtype::int) -> ( dst::UMat ) 
	 convertScaleAbs
	 .method("jlopencv_cv_convertScaleAbs",  [](Mat &src, Mat &dst, double &alpha, double &beta) { cv::convertScaleAbs(src, dst, alpha, beta); return dst;})
		 convertScaleAbs(src::Mat, dst::Mat, alpha::double, beta::double) -> ( dst::Mat ) 
	 convertScaleAbs
	 .method("jlopencv_cv_convertScaleAbs",  [](UMat &src, UMat &dst, double &alpha, double &beta) { cv::convertScaleAbs(src, dst, alpha, beta); return dst;})
		 convertScaleAbs(src::UMat, dst::UMat, alpha::double, beta::double) -> ( dst::UMat ) 
	 convertFp16
	 .method("jlopencv_cv_convertFp16",  [](Mat &src, Mat &dst) { cv::convertFp16(src, dst); return dst;})
		 convertFp16(src::Mat; dst::Mat) -> ( dst::Mat ) 
	 convertFp16
	 .method("jlopencv_cv_convertFp16",  [](UMat &src, UMat &dst) { cv::convertFp16(src, dst); return dst;})
		 convertFp16(src::UMat; dst::UMat) -> ( dst::UMat ) 
	 LUT
	 .method("jlopencv_cv_LUT",  [](Mat &src, Mat &lut, Mat &dst) { cv::LUT(src, lut, dst); return dst;})
		 LUT(src::Mat, lut::Mat; dst::Mat) -> ( dst::Mat ) 
	 LUT
	 .method("jlopencv_cv_LUT",  [](UMat &src, UMat &lut, UMat &dst) { cv::LUT(src, lut, dst); return dst;})
		 LUT(src::UMat, lut::UMat; dst::UMat) -> ( dst::UMat ) 
	 sumElems
	 .method("jlopencv_cv_sumElems",  [](Mat &src) { auto retval = cv::sum(src); return retval;})
		 sumElems(src::Mat) -> ( retval::Scalar ) 
	 sumElems
	 .method("jlopencv_cv_sumElems",  [](UMat &src) { auto retval = cv::sum(src); return retval;})
		 sumElems(src::UMat) -> ( retval::Scalar ) 
	 countNonZero
	 .method("jlopencv_cv_countNonZero",  [](Mat &src) { auto retval = cv::countNonZero(src); return retval;})
		 countNonZero(src::Mat) -> ( retval::int ) 
	 countNonZero
	 .method("jlopencv_cv_countNonZero",  [](UMat &src) { auto retval = cv::countNonZero(src); return retval;})
		 countNonZero(src::UMat) -> ( retval::int ) 
	 findNonZero
	 .method("jlopencv_cv_findNonZero",  [](Mat &src, Mat &idx) { cv::findNonZero(src, idx); return idx;})
		 findNonZero(src::Mat; idx::Mat) -> ( idx::Mat ) 
	 findNonZero
	 .method("jlopencv_cv_findNonZero",  [](UMat &src, UMat &idx) { cv::findNonZero(src, idx); return idx;})
		 findNonZero(src::UMat; idx::UMat) -> ( idx::UMat ) 
	 mean
	 .method("jlopencv_cv_mean",  [](Mat &src, Mat &mask) { auto retval = cv::mean(src, mask); return retval;})
		 mean(src::Mat, mask::Mat) -> ( retval::Scalar ) 
	 mean
	 .method("jlopencv_cv_mean",  [](UMat &src, UMat &mask) { auto retval = cv::mean(src, mask); return retval;})
		 mean(src::UMat, mask::UMat) -> ( retval::Scalar ) 
	 meanStdDev
	 .method("jlopencv_cv_meanStdDev",  [](Mat &src, Mat &mean, Mat &stddev, Mat &mask) { cv::meanStdDev(src, mean, stddev, mask); return make_tuple<Mat,Mat>(mean,stddev);})
		 meanStdDev(src::Mat, mean::Mat, stddev::Mat, mask::Mat) -> ( mean::Mat, stddev::Mat ) 
	 meanStdDev
	 .method("jlopencv_cv_meanStdDev",  [](UMat &src, UMat &mean, UMat &stddev, UMat &mask) { cv::meanStdDev(src, mean, stddev, mask); return make_tuple<UMat,UMat>(mean,stddev);})
		 meanStdDev(src::UMat, mean::UMat, stddev::UMat, mask::UMat) -> ( mean::UMat, stddev::UMat ) 
	 norm
	 .method("jlopencv_cv_norm",  [](Mat &src1, int &normType, Mat &mask) { auto retval = cv::norm(src1, normType, mask); return retval;})
		 norm(src1::Mat, normType::int, mask::Mat) -> ( retval::double ) 
	 norm
	 .method("jlopencv_cv_norm",  [](UMat &src1, int &normType, UMat &mask) { auto retval = cv::norm(src1, normType, mask); return retval;})
		 norm(src1::UMat, normType::int, mask::UMat) -> ( retval::double ) 
	 norm
	 .method("jlopencv_cv_norm",  [](Mat &src1, Mat &src2, int &normType, Mat &mask) { auto retval = cv::norm(src1, src2, normType, mask); return retval;})
		 norm(src1::Mat, src2::Mat, normType::int, mask::Mat) -> ( retval::double ) 
	 norm
	 .method("jlopencv_cv_norm",  [](UMat &src1, UMat &src2, int &normType, UMat &mask) { auto retval = cv::norm(src1, src2, normType, mask); return retval;})
		 norm(src1::UMat, src2::UMat, normType::int, mask::UMat) -> ( retval::double ) 
	 PSNR
	 .method("jlopencv_cv_PSNR",  [](Mat &src1, Mat &src2, double &R) { auto retval = cv::PSNR(src1, src2, R); return retval;})
		 PSNR(src1::Mat, src2::Mat, R::double) -> ( retval::double ) 
	 PSNR
	 .method("jlopencv_cv_PSNR",  [](UMat &src1, UMat &src2, double &R) { auto retval = cv::PSNR(src1, src2, R); return retval;})
		 PSNR(src1::UMat, src2::UMat, R::double) -> ( retval::double ) 
	 batchDistance
	 .method("jlopencv_cv_batchDistance",  [](Mat &src1, Mat &src2, int &dtype, Mat &dist, Mat &nidx, int &normType, int &K, Mat &mask, int &update, bool &crosscheck) { cv::batchDistance(src1, src2, dist, dtype, nidx, normType, K, mask, update, crosscheck); return make_tuple<Mat,Mat>(dist,nidx);})
		 batchDistance(src1::Mat, src2::Mat, dtype::int, dist::Mat, nidx::Mat, normType::int, K::int, mask::Mat, update::int, crosscheck::bool) -> ( dist::Mat, nidx::Mat ) 
	 batchDistance
	 .method("jlopencv_cv_batchDistance",  [](UMat &src1, UMat &src2, int &dtype, UMat &dist, UMat &nidx, int &normType, int &K, UMat &mask, int &update, bool &crosscheck) { cv::batchDistance(src1, src2, dist, dtype, nidx, normType, K, mask, update, crosscheck); return make_tuple<UMat,UMat>(dist,nidx);})
		 batchDistance(src1::UMat, src2::UMat, dtype::int, dist::UMat, nidx::UMat, normType::int, K::int, mask::UMat, update::int, crosscheck::bool) -> ( dist::UMat, nidx::UMat ) 
	 normalize
	 .method("jlopencv_cv_normalize",  [](Mat &src, Mat &dst, double &alpha, double &beta, int &norm_type, int &dtype, Mat &mask) { cv::normalize(src, dst, alpha, beta, norm_type, dtype, mask); return dst;})
		 normalize(src::Mat, dst::Mat, alpha::double, beta::double, norm_type::int, dtype::int, mask::Mat) -> ( dst::Mat ) 
	 normalize
	 .method("jlopencv_cv_normalize",  [](UMat &src, UMat &dst, double &alpha, double &beta, int &norm_type, int &dtype, UMat &mask) { cv::normalize(src, dst, alpha, beta, norm_type, dtype, mask); return dst;})
		 normalize(src::UMat, dst::UMat, alpha::double, beta::double, norm_type::int, dtype::int, mask::UMat) -> ( dst::UMat ) 
	 minMaxLoc
	 .method("jlopencv_cv_minMaxLoc",  [](Mat &src, Mat &mask) {double minVal;double maxVal;Point minLoc;Point maxLoc; cv::minMaxLoc(src, minVal, maxVal, minLoc, maxLoc, mask); return make_tuple<double,double,Point,Point>(minVal,maxVal,minLoc,maxLoc);})
		 minMaxLoc(src::Mat, mask::Mat) -> ( minVal::double*, maxVal::double*, minLoc::Point*, maxLoc::Point* ) 
	 minMaxLoc
	 .method("jlopencv_cv_minMaxLoc",  [](UMat &src, UMat &mask) {double minVal;double maxVal;Point minLoc;Point maxLoc; cv::minMaxLoc(src, minVal, maxVal, minLoc, maxLoc, mask); return make_tuple<double,double,Point,Point>(minVal,maxVal,minLoc,maxLoc);})
		 minMaxLoc(src::UMat, mask::UMat) -> ( minVal::double*, maxVal::double*, minLoc::Point*, maxLoc::Point* ) 
	 reduce
	 .method("jlopencv_cv_reduce",  [](Mat &src, int &dim, int &rtype, Mat &dst, int &dtype) { cv::reduce(src, dst, dim, rtype, dtype); return dst;})
		 reduce(src::Mat, dim::int, rtype::int, dst::Mat, dtype::int) -> ( dst::Mat ) 
	 reduce
	 .method("jlopencv_cv_reduce",  [](UMat &src, int &dim, int &rtype, UMat &dst, int &dtype) { cv::reduce(src, dst, dim, rtype, dtype); return dst;})
		 reduce(src::UMat, dim::int, rtype::int, dst::UMat, dtype::int) -> ( dst::UMat ) 
	 merge
	 .method("jlopencv_cv_merge",  [](vector<Mat> &mv, Mat &dst) { cv::merge(mv, dst); return dst;})
		 merge(mv::vector<Mat>; dst::Mat) -> ( dst::Mat ) 
	 merge
	 .method("jlopencv_cv_merge",  [](vector<UMat> &mv, UMat &dst) { cv::merge(mv, dst); return dst;})
		 merge(mv::vector<UMat>; dst::UMat) -> ( dst::UMat ) 
	 split
	 .method("jlopencv_cv_split",  [](Mat &m) {vector<Mat> mv; cv::split(m, mv); return mv;})
		 split(m::Mat) -> ( mv::vector<Mat> ) 
	 split
	 .method("jlopencv_cv_split",  [](UMat &m) {vector<UMat> mv; cv::split(m, mv); return mv;})
		 split(m::UMat) -> ( mv::vector<UMat> ) 
	 mixChannels
	 .method("jlopencv_cv_mixChannels",  [](vector<Mat> &src, vector<Mat> &dst, vector<int> &fromTo) { cv::mixChannels(src, dst, fromTo); return dst;})
		 mixChannels(src::vector<Mat>, dst::vector<Mat>, fromTo::vector<int>) -> ( dst::vector<Mat> ) 
	 mixChannels
	 .method("jlopencv_cv_mixChannels",  [](vector<UMat> &src, vector<UMat> &dst, vector<int> &fromTo) { cv::mixChannels(src, dst, fromTo); return dst;})
		 mixChannels(src::vector<UMat>, dst::vector<UMat>, fromTo::vector<int>) -> ( dst::vector<UMat> ) 
	 extractChannel
	 .method("jlopencv_cv_extractChannel",  [](Mat &src, int &coi, Mat &dst) { cv::extractChannel(src, dst, coi); return dst;})
		 extractChannel(src::Mat, coi::int; dst::Mat) -> ( dst::Mat ) 
	 extractChannel
	 .method("jlopencv_cv_extractChannel",  [](UMat &src, int &coi, UMat &dst) { cv::extractChannel(src, dst, coi); return dst;})
		 extractChannel(src::UMat, coi::int; dst::UMat) -> ( dst::UMat ) 
	 insertChannel
	 .method("jlopencv_cv_insertChannel",  [](Mat &src, Mat &dst, int &coi) { cv::insertChannel(src, dst, coi); return dst;})
		 insertChannel(src::Mat, dst::Mat, coi::int) -> ( dst::Mat ) 
	 insertChannel
	 .method("jlopencv_cv_insertChannel",  [](UMat &src, UMat &dst, int &coi) { cv::insertChannel(src, dst, coi); return dst;})
		 insertChannel(src::UMat, dst::UMat, coi::int) -> ( dst::UMat ) 
	 flip
	 .method("jlopencv_cv_flip",  [](Mat &src, int &flipCode, Mat &dst) { cv::flip(src, dst, flipCode); return dst;})
		 flip(src::Mat, flipCode::int; dst::Mat) -> ( dst::Mat ) 
	 flip
	 .method("jlopencv_cv_flip",  [](UMat &src, int &flipCode, UMat &dst) { cv::flip(src, dst, flipCode); return dst;})
		 flip(src::UMat, flipCode::int; dst::UMat) -> ( dst::UMat ) 
	 rotate
	 .method("jlopencv_cv_rotate",  [](Mat &src, int &rotateCode, Mat &dst) { cv::rotate(src, dst, rotateCode); return dst;})
		 rotate(src::Mat, rotateCode::int; dst::Mat) -> ( dst::Mat ) 
	 rotate
	 .method("jlopencv_cv_rotate",  [](UMat &src, int &rotateCode, UMat &dst) { cv::rotate(src, dst, rotateCode); return dst;})
		 rotate(src::UMat, rotateCode::int; dst::UMat) -> ( dst::UMat ) 
	 repeat
	 .method("jlopencv_cv_repeat",  [](Mat &src, int &ny, int &nx, Mat &dst) { cv::repeat(src, ny, nx, dst); return dst;})
		 repeat(src::Mat, ny::int, nx::int; dst::Mat) -> ( dst::Mat ) 
	 repeat
	 .method("jlopencv_cv_repeat",  [](UMat &src, int &ny, int &nx, UMat &dst) { cv::repeat(src, ny, nx, dst); return dst;})
		 repeat(src::UMat, ny::int, nx::int; dst::UMat) -> ( dst::UMat ) 
	 hconcat
	 .method("jlopencv_cv_hconcat",  [](vector<Mat> &src, Mat &dst) { cv::hconcat(src, dst); return dst;})
		 hconcat(src::vector<Mat>; dst::Mat) -> ( dst::Mat ) 
	 hconcat
	 .method("jlopencv_cv_hconcat",  [](vector<UMat> &src, UMat &dst) { cv::hconcat(src, dst); return dst;})
		 hconcat(src::vector<UMat>; dst::UMat) -> ( dst::UMat ) 
	 vconcat
	 .method("jlopencv_cv_vconcat",  [](vector<Mat> &src, Mat &dst) { cv::vconcat(src, dst); return dst;})
		 vconcat(src::vector<Mat>; dst::Mat) -> ( dst::Mat ) 
	 vconcat
	 .method("jlopencv_cv_vconcat",  [](vector<UMat> &src, UMat &dst) { cv::vconcat(src, dst); return dst;})
		 vconcat(src::vector<UMat>; dst::UMat) -> ( dst::UMat ) 
	 bitwise_and
	 .method("jlopencv_cv_bitwise_and",  [](Mat &src1, Mat &src2, Mat &dst, Mat &mask) { cv::bitwise_and(src1, src2, dst, mask); return dst;})
		 bitwise_and(src1::Mat, src2::Mat, dst::Mat, mask::Mat) -> ( dst::Mat ) 
	 bitwise_and
	 .method("jlopencv_cv_bitwise_and",  [](UMat &src1, UMat &src2, UMat &dst, UMat &mask) { cv::bitwise_and(src1, src2, dst, mask); return dst;})
		 bitwise_and(src1::UMat, src2::UMat, dst::UMat, mask::UMat) -> ( dst::UMat ) 
	 bitwise_or
	 .method("jlopencv_cv_bitwise_or",  [](Mat &src1, Mat &src2, Mat &dst, Mat &mask) { cv::bitwise_or(src1, src2, dst, mask); return dst;})
		 bitwise_or(src1::Mat, src2::Mat, dst::Mat, mask::Mat) -> ( dst::Mat ) 
	 bitwise_or
	 .method("jlopencv_cv_bitwise_or",  [](UMat &src1, UMat &src2, UMat &dst, UMat &mask) { cv::bitwise_or(src1, src2, dst, mask); return dst;})
		 bitwise_or(src1::UMat, src2::UMat, dst::UMat, mask::UMat) -> ( dst::UMat ) 
	 bitwise_xor
	 .method("jlopencv_cv_bitwise_xor",  [](Mat &src1, Mat &src2, Mat &dst, Mat &mask) { cv::bitwise_xor(src1, src2, dst, mask); return dst;})
		 bitwise_xor(src1::Mat, src2::Mat, dst::Mat, mask::Mat) -> ( dst::Mat ) 
	 bitwise_xor
	 .method("jlopencv_cv_bitwise_xor",  [](UMat &src1, UMat &src2, UMat &dst, UMat &mask) { cv::bitwise_xor(src1, src2, dst, mask); return dst;})
		 bitwise_xor(src1::UMat, src2::UMat, dst::UMat, mask::UMat) -> ( dst::UMat ) 
	 bitwise_not
	 .method("jlopencv_cv_bitwise_not",  [](Mat &src, Mat &dst, Mat &mask) { cv::bitwise_not(src, dst, mask); return dst;})
		 bitwise_not(src::Mat, dst::Mat, mask::Mat) -> ( dst::Mat ) 
	 bitwise_not
	 .method("jlopencv_cv_bitwise_not",  [](UMat &src, UMat &dst, UMat &mask) { cv::bitwise_not(src, dst, mask); return dst;})
		 bitwise_not(src::UMat, dst::UMat, mask::UMat) -> ( dst::UMat ) 
	 absdiff
	 .method("jlopencv_cv_absdiff",  [](Mat &src1, Mat &src2, Mat &dst) { cv::absdiff(src1, src2, dst); return dst;})
		 absdiff(src1::Mat, src2::Mat; dst::Mat) -> ( dst::Mat ) 
	 absdiff
	 .method("jlopencv_cv_absdiff",  [](UMat &src1, UMat &src2, UMat &dst) { cv::absdiff(src1, src2, dst); return dst;})
		 absdiff(src1::UMat, src2::UMat; dst::UMat) -> ( dst::UMat ) 
	 copyTo
	 .method("jlopencv_cv_copyTo",  [](Mat &src, Mat &mask, Mat &dst) { cv::copyTo(src, dst, mask); return dst;})
		 copyTo(src::Mat, mask::Mat; dst::Mat) -> ( dst::Mat ) 
	 copyTo
	 .method("jlopencv_cv_copyTo",  [](UMat &src, UMat &mask, UMat &dst) { cv::copyTo(src, dst, mask); return dst;})
		 copyTo(src::UMat, mask::UMat; dst::UMat) -> ( dst::UMat ) 
	 inRange
	 .method("jlopencv_cv_inRange",  [](Mat &src, Mat &lowerb, Mat &upperb, Mat &dst) { cv::inRange(src, lowerb, upperb, dst); return dst;})
		 inRange(src::Mat, lowerb::Mat, upperb::Mat; dst::Mat) -> ( dst::Mat ) 
	 inRange
	 .method("jlopencv_cv_inRange",  [](UMat &src, UMat &lowerb, UMat &upperb, UMat &dst) { cv::inRange(src, lowerb, upperb, dst); return dst;})
		 inRange(src::UMat, lowerb::UMat, upperb::UMat; dst::UMat) -> ( dst::UMat ) 
	 compare
	 .method("jlopencv_cv_compare",  [](Mat &src1, Mat &src2, int &cmpop, Mat &dst) { cv::compare(src1, src2, dst, cmpop); return dst;})
		 compare(src1::Mat, src2::Mat, cmpop::int; dst::Mat) -> ( dst::Mat ) 
	 compare
	 .method("jlopencv_cv_compare",  [](UMat &src1, UMat &src2, int &cmpop, UMat &dst) { cv::compare(src1, src2, dst, cmpop); return dst;})
		 compare(src1::UMat, src2::UMat, cmpop::int; dst::UMat) -> ( dst::UMat ) 
	 min
	 .method("jlopencv_cv_min",  [](Mat &src1, Mat &src2, Mat &dst) { cv::min(src1, src2, dst); return dst;})
		 min(src1::Mat, src2::Mat; dst::Mat) -> ( dst::Mat ) 
	 min
	 .method("jlopencv_cv_min",  [](UMat &src1, UMat &src2, UMat &dst) { cv::min(src1, src2, dst); return dst;})
		 min(src1::UMat, src2::UMat; dst::UMat) -> ( dst::UMat ) 
	 max
	 .method("jlopencv_cv_max",  [](Mat &src1, Mat &src2, Mat &dst) { cv::max(src1, src2, dst); return dst;})
		 max(src1::Mat, src2::Mat; dst::Mat) -> ( dst::Mat ) 
	 max
	 .method("jlopencv_cv_max",  [](UMat &src1, UMat &src2, UMat &dst) { cv::max(src1, src2, dst); return dst;})
		 max(src1::UMat, src2::UMat; dst::UMat) -> ( dst::UMat ) 
	 sqrt
	 .method("jlopencv_cv_sqrt",  [](Mat &src, Mat &dst) { cv::sqrt(src, dst); return dst;})
		 sqrt(src::Mat; dst::Mat) -> ( dst::Mat ) 
	 sqrt
	 .method("jlopencv_cv_sqrt",  [](UMat &src, UMat &dst) { cv::sqrt(src, dst); return dst;})
		 sqrt(src::UMat; dst::UMat) -> ( dst::UMat ) 
	 pow
	 .method("jlopencv_cv_pow",  [](Mat &src, double &power, Mat &dst) { cv::pow(src, power, dst); return dst;})
		 pow(src::Mat, power::double; dst::Mat) -> ( dst::Mat ) 
	 pow
	 .method("jlopencv_cv_pow",  [](UMat &src, double &power, UMat &dst) { cv::pow(src, power, dst); return dst;})
		 pow(src::UMat, power::double; dst::UMat) -> ( dst::UMat ) 
	 exp
	 .method("jlopencv_cv_exp",  [](Mat &src, Mat &dst) { cv::exp(src, dst); return dst;})
		 exp(src::Mat; dst::Mat) -> ( dst::Mat ) 
	 exp
	 .method("jlopencv_cv_exp",  [](UMat &src, UMat &dst) { cv::exp(src, dst); return dst;})
		 exp(src::UMat; dst::UMat) -> ( dst::UMat ) 
	 log
	 .method("jlopencv_cv_log",  [](Mat &src, Mat &dst) { cv::log(src, dst); return dst;})
		 log(src::Mat; dst::Mat) -> ( dst::Mat ) 
	 log
	 .method("jlopencv_cv_log",  [](UMat &src, UMat &dst) { cv::log(src, dst); return dst;})
		 log(src::UMat; dst::UMat) -> ( dst::UMat ) 
	 polarToCart
	 .method("jlopencv_cv_polarToCart",  [](Mat &magnitude, Mat &angle, Mat &x, Mat &y, bool &angleInDegrees) { cv::polarToCart(magnitude, angle, x, y, angleInDegrees); return make_tuple<Mat,Mat>(x,y);})
		 polarToCart(magnitude::Mat, angle::Mat, x::Mat, y::Mat, angleInDegrees::bool) -> ( x::Mat, y::Mat ) 
	 polarToCart
	 .method("jlopencv_cv_polarToCart",  [](UMat &magnitude, UMat &angle, UMat &x, UMat &y, bool &angleInDegrees) { cv::polarToCart(magnitude, angle, x, y, angleInDegrees); return make_tuple<UMat,UMat>(x,y);})
		 polarToCart(magnitude::UMat, angle::UMat, x::UMat, y::UMat, angleInDegrees::bool) -> ( x::UMat, y::UMat ) 
	 cartToPolar
	 .method("jlopencv_cv_cartToPolar",  [](Mat &x, Mat &y, Mat &magnitude, Mat &angle, bool &angleInDegrees) { cv::cartToPolar(x, y, magnitude, angle, angleInDegrees); return make_tuple<Mat,Mat>(magnitude,angle);})
		 cartToPolar(x::Mat, y::Mat, magnitude::Mat, angle::Mat, angleInDegrees::bool) -> ( magnitude::Mat, angle::Mat ) 
	 cartToPolar
	 .method("jlopencv_cv_cartToPolar",  [](UMat &x, UMat &y, UMat &magnitude, UMat &angle, bool &angleInDegrees) { cv::cartToPolar(x, y, magnitude, angle, angleInDegrees); return make_tuple<UMat,UMat>(magnitude,angle);})
		 cartToPolar(x::UMat, y::UMat, magnitude::UMat, angle::UMat, angleInDegrees::bool) -> ( magnitude::UMat, angle::UMat ) 
	 phase
	 .method("jlopencv_cv_phase",  [](Mat &x, Mat &y, Mat &angle, bool &angleInDegrees) { cv::phase(x, y, angle, angleInDegrees); return angle;})
		 phase(x::Mat, y::Mat, angle::Mat, angleInDegrees::bool) -> ( angle::Mat ) 
	 phase
	 .method("jlopencv_cv_phase",  [](UMat &x, UMat &y, UMat &angle, bool &angleInDegrees) { cv::phase(x, y, angle, angleInDegrees); return angle;})
		 phase(x::UMat, y::UMat, angle::UMat, angleInDegrees::bool) -> ( angle::UMat ) 
	 magnitude
	 .method("jlopencv_cv_magnitude",  [](Mat &x, Mat &y, Mat &magnitude) { cv::magnitude(x, y, magnitude); return magnitude;})
		 magnitude(x::Mat, y::Mat; magnitude::Mat) -> ( magnitude::Mat ) 
	 magnitude
	 .method("jlopencv_cv_magnitude",  [](UMat &x, UMat &y, UMat &magnitude) { cv::magnitude(x, y, magnitude); return magnitude;})
		 magnitude(x::UMat, y::UMat; magnitude::UMat) -> ( magnitude::UMat ) 
	 checkRange
	 .method("jlopencv_cv_checkRange",  [](Mat &a, bool &quiet, double &minVal, double &maxVal) {Point pos; auto retval = cv::checkRange(a, quiet, pos, minVal, maxVal); return make_tuple<bool,Point>(retval,pos);})
		 checkRange(a::Mat, quiet::bool, minVal::double, maxVal::double) -> ( retval::bool, pos::Point* ) 
	 checkRange
	 .method("jlopencv_cv_checkRange",  [](UMat &a, bool &quiet, double &minVal, double &maxVal) {Point pos; auto retval = cv::checkRange(a, quiet, pos, minVal, maxVal); return make_tuple<bool,Point>(retval,pos);})
		 checkRange(a::UMat, quiet::bool, minVal::double, maxVal::double) -> ( retval::bool, pos::Point* ) 
	 patchNaNs
	 .method("jlopencv_cv_patchNaNs",  [](Mat &a, double &val) { cv::patchNaNs(a, val); return a;})
		 patchNaNs(a::Mat, val::double) -> ( a::Mat ) 
	 patchNaNs
	 .method("jlopencv_cv_patchNaNs",  [](UMat &a, double &val) { cv::patchNaNs(a, val); return a;})
		 patchNaNs(a::UMat, val::double) -> ( a::UMat ) 
	 gemm
	 .method("jlopencv_cv_gemm",  [](Mat &src1, Mat &src2, double &alpha, Mat &src3, double &beta, Mat &dst, int &flags) { cv::gemm(src1, src2, alpha, src3, beta, dst, flags); return dst;})
		 gemm(src1::Mat, src2::Mat, alpha::double, src3::Mat, beta::double, dst::Mat, flags::int) -> ( dst::Mat ) 
	 gemm
	 .method("jlopencv_cv_gemm",  [](UMat &src1, UMat &src2, double &alpha, UMat &src3, double &beta, UMat &dst, int &flags) { cv::gemm(src1, src2, alpha, src3, beta, dst, flags); return dst;})
		 gemm(src1::UMat, src2::UMat, alpha::double, src3::UMat, beta::double, dst::UMat, flags::int) -> ( dst::UMat ) 
	 mulTransposed
	 .method("jlopencv_cv_mulTransposed",  [](Mat &src, bool &aTa, Mat &dst, Mat &delta, double &scale, int &dtype) { cv::mulTransposed(src, dst, aTa, delta, scale, dtype); return dst;})
		 mulTransposed(src::Mat, aTa::bool, dst::Mat, delta::Mat, scale::double, dtype::int) -> ( dst::Mat ) 
	 mulTransposed
	 .method("jlopencv_cv_mulTransposed",  [](UMat &src, bool &aTa, UMat &dst, UMat &delta, double &scale, int &dtype) { cv::mulTransposed(src, dst, aTa, delta, scale, dtype); return dst;})
		 mulTransposed(src::UMat, aTa::bool, dst::UMat, delta::UMat, scale::double, dtype::int) -> ( dst::UMat ) 
	 transpose
	 .method("jlopencv_cv_transpose",  [](Mat &src, Mat &dst) { cv::transpose(src, dst); return dst;})
		 transpose(src::Mat; dst::Mat) -> ( dst::Mat ) 
	 transpose
	 .method("jlopencv_cv_transpose",  [](UMat &src, UMat &dst) { cv::transpose(src, dst); return dst;})
		 transpose(src::UMat; dst::UMat) -> ( dst::UMat ) 
	 transform
	 .method("jlopencv_cv_transform",  [](Mat &src, Mat &m, Mat &dst) { cv::transform(src, dst, m); return dst;})
		 transform(src::Mat, m::Mat; dst::Mat) -> ( dst::Mat ) 
	 transform
	 .method("jlopencv_cv_transform",  [](UMat &src, UMat &m, UMat &dst) { cv::transform(src, dst, m); return dst;})
		 transform(src::UMat, m::UMat; dst::UMat) -> ( dst::UMat ) 
	 perspectiveTransform
	 .method("jlopencv_cv_perspectiveTransform",  [](Mat &src, Mat &m, Mat &dst) { cv::perspectiveTransform(src, dst, m); return dst;})
		 perspectiveTransform(src::Mat, m::Mat; dst::Mat) -> ( dst::Mat ) 
	 perspectiveTransform
	 .method("jlopencv_cv_perspectiveTransform",  [](UMat &src, UMat &m, UMat &dst) { cv::perspectiveTransform(src, dst, m); return dst;})
		 perspectiveTransform(src::UMat, m::UMat; dst::UMat) -> ( dst::UMat ) 
	 completeSymm
	 .method("jlopencv_cv_completeSymm",  [](Mat &m, bool &lowerToUpper) { cv::completeSymm(m, lowerToUpper); return m;})
		 completeSymm(m::Mat, lowerToUpper::bool) -> ( m::Mat ) 
	 completeSymm
	 .method("jlopencv_cv_completeSymm",  [](UMat &m, bool &lowerToUpper) { cv::completeSymm(m, lowerToUpper); return m;})
		 completeSymm(m::UMat, lowerToUpper::bool) -> ( m::UMat ) 
	 setIdentity
	 .method("jlopencv_cv_setIdentity",  [](Mat &mtx, Scalar &s) { cv::setIdentity(mtx, s); return mtx;})
		 setIdentity(mtx::Mat, s::Scalar) -> ( mtx::Mat ) 
	 setIdentity
	 .method("jlopencv_cv_setIdentity",  [](UMat &mtx, Scalar &s) { cv::setIdentity(mtx, s); return mtx;})
		 setIdentity(mtx::UMat, s::Scalar) -> ( mtx::UMat ) 
	 determinant
	 .method("jlopencv_cv_determinant",  [](Mat &mtx) { auto retval = cv::determinant(mtx); return retval;})
		 determinant(mtx::Mat) -> ( retval::double ) 
	 determinant
	 .method("jlopencv_cv_determinant",  [](UMat &mtx) { auto retval = cv::determinant(mtx); return retval;})
		 determinant(mtx::UMat) -> ( retval::double ) 
	 trace
	 .method("jlopencv_cv_trace",  [](Mat &mtx) { auto retval = cv::trace(mtx); return retval;})
		 trace(mtx::Mat) -> ( retval::Scalar ) 
	 trace
	 .method("jlopencv_cv_trace",  [](UMat &mtx) { auto retval = cv::trace(mtx); return retval;})
		 trace(mtx::UMat) -> ( retval::Scalar ) 
	 invert
	 .method("jlopencv_cv_invert",  [](Mat &src, Mat &dst, int &flags) { auto retval = cv::invert(src, dst, flags); return make_tuple<double,Mat>(retval,dst);})
		 invert(src::Mat, dst::Mat, flags::int) -> ( retval::double, dst::Mat ) 
	 invert
	 .method("jlopencv_cv_invert",  [](UMat &src, UMat &dst, int &flags) { auto retval = cv::invert(src, dst, flags); return make_tuple<double,UMat>(retval,dst);})
		 invert(src::UMat, dst::UMat, flags::int) -> ( retval::double, dst::UMat ) 
	 solve
	 .method("jlopencv_cv_solve",  [](Mat &src1, Mat &src2, Mat &dst, int &flags) { auto retval = cv::solve(src1, src2, dst, flags); return make_tuple<bool,Mat>(retval,dst);})
		 solve(src1::Mat, src2::Mat, dst::Mat, flags::int) -> ( retval::bool, dst::Mat ) 
	 solve
	 .method("jlopencv_cv_solve",  [](UMat &src1, UMat &src2, UMat &dst, int &flags) { auto retval = cv::solve(src1, src2, dst, flags); return make_tuple<bool,UMat>(retval,dst);})
		 solve(src1::UMat, src2::UMat, dst::UMat, flags::int) -> ( retval::bool, dst::UMat ) 
	 sort
	 .method("jlopencv_cv_sort",  [](Mat &src, int &flags, Mat &dst) { cv::sort(src, dst, flags); return dst;})
		 sort(src::Mat, flags::int; dst::Mat) -> ( dst::Mat ) 
	 sort
	 .method("jlopencv_cv_sort",  [](UMat &src, int &flags, UMat &dst) { cv::sort(src, dst, flags); return dst;})
		 sort(src::UMat, flags::int; dst::UMat) -> ( dst::UMat ) 
	 sortIdx
	 .method("jlopencv_cv_sortIdx",  [](Mat &src, int &flags, Mat &dst) { cv::sortIdx(src, dst, flags); return dst;})
		 sortIdx(src::Mat, flags::int; dst::Mat) -> ( dst::Mat ) 
	 sortIdx
	 .method("jlopencv_cv_sortIdx",  [](UMat &src, int &flags, UMat &dst) { cv::sortIdx(src, dst, flags); return dst;})
		 sortIdx(src::UMat, flags::int; dst::UMat) -> ( dst::UMat ) 
	 solveCubic
	 .method("jlopencv_cv_solveCubic",  [](Mat &coeffs, Mat &roots) { auto retval = cv::solveCubic(coeffs, roots); return make_tuple<int,Mat>(retval,roots);})
		 solveCubic(coeffs::Mat; roots::Mat) -> ( retval::int, roots::Mat ) 
	 solveCubic
	 .method("jlopencv_cv_solveCubic",  [](UMat &coeffs, UMat &roots) { auto retval = cv::solveCubic(coeffs, roots); return make_tuple<int,UMat>(retval,roots);})
		 solveCubic(coeffs::UMat; roots::UMat) -> ( retval::int, roots::UMat ) 
	 solvePoly
	 .method("jlopencv_cv_solvePoly",  [](Mat &coeffs, Mat &roots, int &maxIters) { auto retval = cv::solvePoly(coeffs, roots, maxIters); return make_tuple<double,Mat>(retval,roots);})
		 solvePoly(coeffs::Mat, roots::Mat, maxIters::int) -> ( retval::double, roots::Mat ) 
	 solvePoly
	 .method("jlopencv_cv_solvePoly",  [](UMat &coeffs, UMat &roots, int &maxIters) { auto retval = cv::solvePoly(coeffs, roots, maxIters); return make_tuple<double,UMat>(retval,roots);})
		 solvePoly(coeffs::UMat, roots::UMat, maxIters::int) -> ( retval::double, roots::UMat ) 
	 eigen
	 .method("jlopencv_cv_eigen",  [](Mat &src, Mat &eigenvalues, Mat &eigenvectors) { auto retval = cv::eigen(src, eigenvalues, eigenvectors); return make_tuple<bool,Mat,Mat>(retval,eigenvalues,eigenvectors);})
		 eigen(src::Mat; eigenvalues::Mat, eigenvectors::Mat) -> ( retval::bool, eigenvalues::Mat, eigenvectors::Mat ) 
	 eigen
	 .method("jlopencv_cv_eigen",  [](UMat &src, UMat &eigenvalues, UMat &eigenvectors) { auto retval = cv::eigen(src, eigenvalues, eigenvectors); return make_tuple<bool,UMat,UMat>(retval,eigenvalues,eigenvectors);})
		 eigen(src::UMat; eigenvalues::UMat, eigenvectors::UMat) -> ( retval::bool, eigenvalues::UMat, eigenvectors::UMat ) 
	 eigenNonSymmetric
	 .method("jlopencv_cv_eigenNonSymmetric",  [](Mat &src, Mat &eigenvalues, Mat &eigenvectors) { cv::eigenNonSymmetric(src, eigenvalues, eigenvectors); return make_tuple<Mat,Mat>(eigenvalues,eigenvectors);})
		 eigenNonSymmetric(src::Mat; eigenvalues::Mat, eigenvectors::Mat) -> ( eigenvalues::Mat, eigenvectors::Mat ) 
	 eigenNonSymmetric
	 .method("jlopencv_cv_eigenNonSymmetric",  [](UMat &src, UMat &eigenvalues, UMat &eigenvectors) { cv::eigenNonSymmetric(src, eigenvalues, eigenvectors); return make_tuple<UMat,UMat>(eigenvalues,eigenvectors);})
		 eigenNonSymmetric(src::UMat; eigenvalues::UMat, eigenvectors::UMat) -> ( eigenvalues::UMat, eigenvectors::UMat ) 
	 calcCovarMatrix
	 .method("jlopencv_cv_calcCovarMatrix",  [](Mat &samples, Mat &mean, int &flags, Mat &covar, int &ctype) { cv::calcCovarMatrix(samples, covar, mean, flags, ctype); return make_tuple<Mat,Mat>(covar,mean);})
		 calcCovarMatrix(samples::Mat, mean::Mat, flags::int, covar::Mat, ctype::int) -> ( covar::Mat, mean::Mat ) 
	 calcCovarMatrix
	 .method("jlopencv_cv_calcCovarMatrix",  [](UMat &samples, UMat &mean, int &flags, UMat &covar, int &ctype) { cv::calcCovarMatrix(samples, covar, mean, flags, ctype); return make_tuple<UMat,UMat>(covar,mean);})
		 calcCovarMatrix(samples::UMat, mean::UMat, flags::int, covar::UMat, ctype::int) -> ( covar::UMat, mean::UMat ) 
	 PCACompute
	 .method("jlopencv_cv_PCACompute",  [](Mat &data, Mat &mean, Mat &eigenvectors, int &maxComponents) { cv::PCACompute(data, mean, eigenvectors, maxComponents); return make_tuple<Mat,Mat>(mean,eigenvectors);})
		 PCACompute(data::Mat, mean::Mat, eigenvectors::Mat, maxComponents::int) -> ( mean::Mat, eigenvectors::Mat ) 
	 PCACompute
	 .method("jlopencv_cv_PCACompute",  [](UMat &data, UMat &mean, UMat &eigenvectors, int &maxComponents) { cv::PCACompute(data, mean, eigenvectors, maxComponents); return make_tuple<UMat,UMat>(mean,eigenvectors);})
		 PCACompute(data::UMat, mean::UMat, eigenvectors::UMat, maxComponents::int) -> ( mean::UMat, eigenvectors::UMat ) 
	 PCACompute
	 .method("jlopencv_cv_PCACompute",  [](Mat &data, Mat &mean, double &retainedVariance, Mat &eigenvectors) { cv::PCACompute(data, mean, eigenvectors, retainedVariance); return make_tuple<Mat,Mat>(mean,eigenvectors);})
		 PCACompute(data::Mat, mean::Mat, retainedVariance::double; eigenvectors::Mat) -> ( mean::Mat, eigenvectors::Mat ) 
	 PCACompute
	 .method("jlopencv_cv_PCACompute",  [](UMat &data, UMat &mean, double &retainedVariance, UMat &eigenvectors) { cv::PCACompute(data, mean, eigenvectors, retainedVariance); return make_tuple<UMat,UMat>(mean,eigenvectors);})
		 PCACompute(data::UMat, mean::UMat, retainedVariance::double; eigenvectors::UMat) -> ( mean::UMat, eigenvectors::UMat ) 
	 PCACompute2
	 .method("jlopencv_cv_PCACompute2",  [](Mat &data, Mat &mean, Mat &eigenvectors, Mat &eigenvalues, int &maxComponents) { cv::PCACompute(data, mean, eigenvectors, eigenvalues, maxComponents); return make_tuple<Mat,Mat,Mat>(mean,eigenvectors,eigenvalues);})
		 PCACompute2(data::Mat, mean::Mat, eigenvectors::Mat, eigenvalues::Mat, maxComponents::int) -> ( mean::Mat, eigenvectors::Mat, eigenvalues::Mat ) 
	 PCACompute2
	 .method("jlopencv_cv_PCACompute2",  [](UMat &data, UMat &mean, UMat &eigenvectors, UMat &eigenvalues, int &maxComponents) { cv::PCACompute(data, mean, eigenvectors, eigenvalues, maxComponents); return make_tuple<UMat,UMat,UMat>(mean,eigenvectors,eigenvalues);})
		 PCACompute2(data::UMat, mean::UMat, eigenvectors::UMat, eigenvalues::UMat, maxComponents::int) -> ( mean::UMat, eigenvectors::UMat, eigenvalues::UMat ) 
	 PCACompute2
	 .method("jlopencv_cv_PCACompute2",  [](Mat &data, Mat &mean, double &retainedVariance, Mat &eigenvectors, Mat &eigenvalues) { cv::PCACompute(data, mean, eigenvectors, eigenvalues, retainedVariance); return make_tuple<Mat,Mat,Mat>(mean,eigenvectors,eigenvalues);})
		 PCACompute2(data::Mat, mean::Mat, retainedVariance::double; eigenvectors::Mat, eigenvalues::Mat) -> ( mean::Mat, eigenvectors::Mat, eigenvalues::Mat ) 
	 PCACompute2
	 .method("jlopencv_cv_PCACompute2",  [](UMat &data, UMat &mean, double &retainedVariance, UMat &eigenvectors, UMat &eigenvalues) { cv::PCACompute(data, mean, eigenvectors, eigenvalues, retainedVariance); return make_tuple<UMat,UMat,UMat>(mean,eigenvectors,eigenvalues);})
		 PCACompute2(data::UMat, mean::UMat, retainedVariance::double; eigenvectors::UMat, eigenvalues::UMat) -> ( mean::UMat, eigenvectors::UMat, eigenvalues::UMat ) 
	 PCAProject
	 .method("jlopencv_cv_PCAProject",  [](Mat &data, Mat &mean, Mat &eigenvectors, Mat &result) { cv::PCAProject(data, mean, eigenvectors, result); return result;})
		 PCAProject(data::Mat, mean::Mat, eigenvectors::Mat; result::Mat) -> ( result::Mat ) 
	 PCAProject
	 .method("jlopencv_cv_PCAProject",  [](UMat &data, UMat &mean, UMat &eigenvectors, UMat &result) { cv::PCAProject(data, mean, eigenvectors, result); return result;})
		 PCAProject(data::UMat, mean::UMat, eigenvectors::UMat; result::UMat) -> ( result::UMat ) 
	 PCABackProject
	 .method("jlopencv_cv_PCABackProject",  [](Mat &data, Mat &mean, Mat &eigenvectors, Mat &result) { cv::PCABackProject(data, mean, eigenvectors, result); return result;})
		 PCABackProject(data::Mat, mean::Mat, eigenvectors::Mat; result::Mat) -> ( result::Mat ) 
	 PCABackProject
	 .method("jlopencv_cv_PCABackProject",  [](UMat &data, UMat &mean, UMat &eigenvectors, UMat &result) { cv::PCABackProject(data, mean, eigenvectors, result); return result;})
		 PCABackProject(data::UMat, mean::UMat, eigenvectors::UMat; result::UMat) -> ( result::UMat ) 
	 SVDecomp
	 .method("jlopencv_cv_SVDecomp",  [](Mat &src, Mat &w, Mat &u, Mat &vt, int &flags) { cv::SVDecomp(src, w, u, vt, flags); return make_tuple<Mat,Mat,Mat>(w,u,vt);})
		 SVDecomp(src::Mat, w::Mat, u::Mat, vt::Mat, flags::int) -> ( w::Mat, u::Mat, vt::Mat ) 
	 SVDecomp
	 .method("jlopencv_cv_SVDecomp",  [](UMat &src, UMat &w, UMat &u, UMat &vt, int &flags) { cv::SVDecomp(src, w, u, vt, flags); return make_tuple<UMat,UMat,UMat>(w,u,vt);})
		 SVDecomp(src::UMat, w::UMat, u::UMat, vt::UMat, flags::int) -> ( w::UMat, u::UMat, vt::UMat ) 
	 SVBackSubst
	 .method("jlopencv_cv_SVBackSubst",  [](Mat &w, Mat &u, Mat &vt, Mat &rhs, Mat &dst) { cv::SVBackSubst(w, u, vt, rhs, dst); return dst;})
		 SVBackSubst(w::Mat, u::Mat, vt::Mat, rhs::Mat; dst::Mat) -> ( dst::Mat ) 
	 SVBackSubst
	 .method("jlopencv_cv_SVBackSubst",  [](UMat &w, UMat &u, UMat &vt, UMat &rhs, UMat &dst) { cv::SVBackSubst(w, u, vt, rhs, dst); return dst;})
		 SVBackSubst(w::UMat, u::UMat, vt::UMat, rhs::UMat; dst::UMat) -> ( dst::UMat ) 
	 Mahalanobis
	 .method("jlopencv_cv_Mahalanobis",  [](Mat &v1, Mat &v2, Mat &icovar) { auto retval = cv::Mahalanobis(v1, v2, icovar); return retval;})
		 Mahalanobis(v1::Mat, v2::Mat, icovar::Mat) -> ( retval::double ) 
	 Mahalanobis
	 .method("jlopencv_cv_Mahalanobis",  [](UMat &v1, UMat &v2, UMat &icovar) { auto retval = cv::Mahalanobis(v1, v2, icovar); return retval;})
		 Mahalanobis(v1::UMat, v2::UMat, icovar::UMat) -> ( retval::double ) 
	 dft
	 .method("jlopencv_cv_dft",  [](Mat &src, Mat &dst, int &flags, int &nonzeroRows) { cv::dft(src, dst, flags, nonzeroRows); return dst;})
		 dft(src::Mat, dst::Mat, flags::int, nonzeroRows::int) -> ( dst::Mat ) 
	 dft
	 .method("jlopencv_cv_dft",  [](UMat &src, UMat &dst, int &flags, int &nonzeroRows) { cv::dft(src, dst, flags, nonzeroRows); return dst;})
		 dft(src::UMat, dst::UMat, flags::int, nonzeroRows::int) -> ( dst::UMat ) 
	 idft
	 .method("jlopencv_cv_idft",  [](Mat &src, Mat &dst, int &flags, int &nonzeroRows) { cv::idft(src, dst, flags, nonzeroRows); return dst;})
		 idft(src::Mat, dst::Mat, flags::int, nonzeroRows::int) -> ( dst::Mat ) 
	 idft
	 .method("jlopencv_cv_idft",  [](UMat &src, UMat &dst, int &flags, int &nonzeroRows) { cv::idft(src, dst, flags, nonzeroRows); return dst;})
		 idft(src::UMat, dst::UMat, flags::int, nonzeroRows::int) -> ( dst::UMat ) 
	 dct
	 .method("jlopencv_cv_dct",  [](Mat &src, Mat &dst, int &flags) { cv::dct(src, dst, flags); return dst;})
		 dct(src::Mat, dst::Mat, flags::int) -> ( dst::Mat ) 
	 dct
	 .method("jlopencv_cv_dct",  [](UMat &src, UMat &dst, int &flags) { cv::dct(src, dst, flags); return dst;})
		 dct(src::UMat, dst::UMat, flags::int) -> ( dst::UMat ) 
	 idct
	 .method("jlopencv_cv_idct",  [](Mat &src, Mat &dst, int &flags) { cv::idct(src, dst, flags); return dst;})
		 idct(src::Mat, dst::Mat, flags::int) -> ( dst::Mat ) 
	 idct
	 .method("jlopencv_cv_idct",  [](UMat &src, UMat &dst, int &flags) { cv::idct(src, dst, flags); return dst;})
		 idct(src::UMat, dst::UMat, flags::int) -> ( dst::UMat ) 
	 mulSpectrums
	 .method("jlopencv_cv_mulSpectrums",  [](Mat &a, Mat &b, int &flags, Mat &c, bool &conjB) { cv::mulSpectrums(a, b, c, flags, conjB); return c;})
		 mulSpectrums(a::Mat, b::Mat, flags::int, c::Mat, conjB::bool) -> ( c::Mat ) 
	 mulSpectrums
	 .method("jlopencv_cv_mulSpectrums",  [](UMat &a, UMat &b, int &flags, UMat &c, bool &conjB) { cv::mulSpectrums(a, b, c, flags, conjB); return c;})
		 mulSpectrums(a::UMat, b::UMat, flags::int, c::UMat, conjB::bool) -> ( c::UMat ) 
	 getOptimalDFTSize
	 .method("jlopencv_cv_getOptimalDFTSize",  [](int &vecsize) { auto retval = cv::getOptimalDFTSize(vecsize); return retval;})
		 getOptimalDFTSize(vecsize::int) -> ( retval::int ) 
	 setRNGSeed
	 .method("jlopencv_cv_setRNGSeed",  [](int &seed) { cv::setRNGSeed(seed); ;})
		 setRNGSeed(seed::int) -> nothing
	 randu
	 .method("jlopencv_cv_randu",  [](Mat &dst, Mat &low, Mat &high) { cv::randu(dst, low, high); return dst;})
		 randu(dst::Mat, low::Mat, high::Mat) -> ( dst::Mat ) 
	 randu
	 .method("jlopencv_cv_randu",  [](UMat &dst, UMat &low, UMat &high) { cv::randu(dst, low, high); return dst;})
		 randu(dst::UMat, low::UMat, high::UMat) -> ( dst::UMat ) 
	 randn
	 .method("jlopencv_cv_randn",  [](Mat &dst, Mat &mean, Mat &stddev) { cv::randn(dst, mean, stddev); return dst;})
		 randn(dst::Mat, mean::Mat, stddev::Mat) -> ( dst::Mat ) 
	 randn
	 .method("jlopencv_cv_randn",  [](UMat &dst, UMat &mean, UMat &stddev) { cv::randn(dst, mean, stddev); return dst;})
		 randn(dst::UMat, mean::UMat, stddev::UMat) -> ( dst::UMat ) 
	 randShuffle
	 .method("jlopencv_cv_randShuffle",  [](Mat &dst, double &iterFactor) { cv::randShuffle(dst, iterFactor, rng); return dst;})
		 randShuffle(dst::Mat, iterFactor::double) -> ( dst::Mat ) 
	 randShuffle
	 .method("jlopencv_cv_randShuffle",  [](UMat &dst, double &iterFactor) { cv::randShuffle(dst, iterFactor, rng); return dst;})
		 randShuffle(dst::UMat, iterFactor::double) -> ( dst::UMat ) 
	 kmeans
	 .method("jlopencv_cv_kmeans",  [](Mat &data, int &K, Mat &bestLabels, TermCriteria &criteria, int &attempts, int &flags, Mat &centers) { auto retval = cv::kmeans(data, K, bestLabels, criteria, attempts, flags, centers); return make_tuple<double,Mat,Mat>(retval,bestLabels,centers);})
		 kmeans(data::Mat, K::int, bestLabels::Mat, criteria::TermCriteria, attempts::int, flags::int; centers::Mat) -> ( retval::double, bestLabels::Mat, centers::Mat ) 
	 kmeans
	 .method("jlopencv_cv_kmeans",  [](UMat &data, int &K, UMat &bestLabels, TermCriteria &criteria, int &attempts, int &flags, UMat &centers) { auto retval = cv::kmeans(data, K, bestLabels, criteria, attempts, flags, centers); return make_tuple<double,UMat,UMat>(retval,bestLabels,centers);})
		 kmeans(data::UMat, K::int, bestLabels::UMat, criteria::TermCriteria, attempts::int, flags::int; centers::UMat) -> ( retval::double, bestLabels::UMat, centers::UMat ) 
	 createLineSegmentDetector
	 .method("jlopencv_cv_createLineSegmentDetector",  [](int &_refine, double &_scale, double &_sigma_scale, double &_quant, double &_ang_th, double &_log_eps, double &_density_th, int &_n_bins) { auto retval = cv::createLineSegmentDetector(_refine, _scale, _sigma_scale, _quant, _ang_th, _log_eps, _density_th, _n_bins); return retval;})
		 createLineSegmentDetector(_refine::int, _scale::double, _sigma_scale::double, _quant::double, _ang_th::double, _log_eps::double, _density_th::double, _n_bins::int) -> ( retval::Ptr<LineSegmentDetector> ) 
	 getGaussianKernel
	 .method("jlopencv_cv_getGaussianKernel",  [](int &ksize, double &sigma, int &ktype) { auto retval = cv::getGaussianKernel(ksize, sigma, ktype); return retval;})
		 getGaussianKernel(ksize::int, sigma::double, ktype::int) -> ( retval::Mat ) 
	 getDerivKernels
	 .method("jlopencv_cv_getDerivKernels",  [](int &dx, int &dy, int &ksize, Mat &kx, Mat &ky, bool &normalize, int &ktype) { cv::getDerivKernels(kx, ky, dx, dy, ksize, normalize, ktype); return make_tuple<Mat,Mat>(kx,ky);})
		 getDerivKernels(dx::int, dy::int, ksize::int, kx::Mat, ky::Mat, normalize::bool, ktype::int) -> ( kx::Mat, ky::Mat ) 
	 getDerivKernels
	 .method("jlopencv_cv_getDerivKernels",  [](int &dx, int &dy, int &ksize, UMat &kx, UMat &ky, bool &normalize, int &ktype) { cv::getDerivKernels(kx, ky, dx, dy, ksize, normalize, ktype); return make_tuple<UMat,UMat>(kx,ky);})
		 getDerivKernels(dx::int, dy::int, ksize::int, kx::UMat, ky::UMat, normalize::bool, ktype::int) -> ( kx::UMat, ky::UMat ) 
	 getGaborKernel
	 .method("jlopencv_cv_getGaborKernel",  [](Size &ksize, double &sigma, double &theta, double &lambd, double &gamma, double &psi, int &ktype) { auto retval = cv::getGaborKernel(ksize, sigma, theta, lambd, gamma, psi, ktype); return retval;})
		 getGaborKernel(ksize::Size, sigma::double, theta::double, lambd::double, gamma::double, psi::double, ktype::int) -> ( retval::Mat ) 
	 getStructuringElement
	 .method("jlopencv_cv_getStructuringElement",  [](int &shape, Size &ksize, Point &anchor) { auto retval = cv::getStructuringElement(shape, ksize, anchor); return retval;})
		 getStructuringElement(shape::int, ksize::Size, anchor::Point) -> ( retval::Mat ) 
	 medianBlur
	 .method("jlopencv_cv_medianBlur",  [](Mat &src, int &ksize, Mat &dst) { cv::medianBlur(src, dst, ksize); return dst;})
		 medianBlur(src::Mat, ksize::int; dst::Mat) -> ( dst::Mat ) 
	 medianBlur
	 .method("jlopencv_cv_medianBlur",  [](UMat &src, int &ksize, UMat &dst) { cv::medianBlur(src, dst, ksize); return dst;})
		 medianBlur(src::UMat, ksize::int; dst::UMat) -> ( dst::UMat ) 
	 GaussianBlur
	 .method("jlopencv_cv_GaussianBlur",  [](Mat &src, Size &ksize, double &sigmaX, Mat &dst, double &sigmaY, int &borderType) { cv::GaussianBlur(src, dst, ksize, sigmaX, sigmaY, borderType); return dst;})
		 GaussianBlur(src::Mat, ksize::Size, sigmaX::double, dst::Mat, sigmaY::double, borderType::int) -> ( dst::Mat ) 
	 GaussianBlur
	 .method("jlopencv_cv_GaussianBlur",  [](UMat &src, Size &ksize, double &sigmaX, UMat &dst, double &sigmaY, int &borderType) { cv::GaussianBlur(src, dst, ksize, sigmaX, sigmaY, borderType); return dst;})
		 GaussianBlur(src::UMat, ksize::Size, sigmaX::double, dst::UMat, sigmaY::double, borderType::int) -> ( dst::UMat ) 
	 bilateralFilter
	 .method("jlopencv_cv_bilateralFilter",  [](Mat &src, int &d, double &sigmaColor, double &sigmaSpace, Mat &dst, int &borderType) { cv::bilateralFilter(src, dst, d, sigmaColor, sigmaSpace, borderType); return dst;})
		 bilateralFilter(src::Mat, d::int, sigmaColor::double, sigmaSpace::double, dst::Mat, borderType::int) -> ( dst::Mat ) 
	 bilateralFilter
	 .method("jlopencv_cv_bilateralFilter",  [](UMat &src, int &d, double &sigmaColor, double &sigmaSpace, UMat &dst, int &borderType) { cv::bilateralFilter(src, dst, d, sigmaColor, sigmaSpace, borderType); return dst;})
		 bilateralFilter(src::UMat, d::int, sigmaColor::double, sigmaSpace::double, dst::UMat, borderType::int) -> ( dst::UMat ) 
	 boxFilter
	 .method("jlopencv_cv_boxFilter",  [](Mat &src, int &ddepth, Size &ksize, Mat &dst, Point &anchor, bool &normalize, int &borderType) { cv::boxFilter(src, dst, ddepth, ksize, anchor, normalize, borderType); return dst;})
		 boxFilter(src::Mat, ddepth::int, ksize::Size, dst::Mat, anchor::Point, normalize::bool, borderType::int) -> ( dst::Mat ) 
	 boxFilter
	 .method("jlopencv_cv_boxFilter",  [](UMat &src, int &ddepth, Size &ksize, UMat &dst, Point &anchor, bool &normalize, int &borderType) { cv::boxFilter(src, dst, ddepth, ksize, anchor, normalize, borderType); return dst;})
		 boxFilter(src::UMat, ddepth::int, ksize::Size, dst::UMat, anchor::Point, normalize::bool, borderType::int) -> ( dst::UMat ) 
	 sqrBoxFilter
	 .method("jlopencv_cv_sqrBoxFilter",  [](Mat &src, int &ddepth, Size &ksize, Mat &dst, Point &anchor, bool &normalize, int &borderType) { cv::sqrBoxFilter(src, dst, ddepth, ksize, anchor, normalize, borderType); return dst;})
		 sqrBoxFilter(src::Mat, ddepth::int, ksize::Size, dst::Mat, anchor::Point, normalize::bool, borderType::int) -> ( dst::Mat ) 
	 sqrBoxFilter
	 .method("jlopencv_cv_sqrBoxFilter",  [](UMat &src, int &ddepth, Size &ksize, UMat &dst, Point &anchor, bool &normalize, int &borderType) { cv::sqrBoxFilter(src, dst, ddepth, ksize, anchor, normalize, borderType); return dst;})
		 sqrBoxFilter(src::UMat, ddepth::int, ksize::Size, dst::UMat, anchor::Point, normalize::bool, borderType::int) -> ( dst::UMat ) 
	 blur
	 .method("jlopencv_cv_blur",  [](Mat &src, Size &ksize, Mat &dst, Point &anchor, int &borderType) { cv::blur(src, dst, ksize, anchor, borderType); return dst;})
		 blur(src::Mat, ksize::Size, dst::Mat, anchor::Point, borderType::int) -> ( dst::Mat ) 
	 blur
	 .method("jlopencv_cv_blur",  [](UMat &src, Size &ksize, UMat &dst, Point &anchor, int &borderType) { cv::blur(src, dst, ksize, anchor, borderType); return dst;})
		 blur(src::UMat, ksize::Size, dst::UMat, anchor::Point, borderType::int) -> ( dst::UMat ) 
	 filter2D
	 .method("jlopencv_cv_filter2D",  [](Mat &src, int &ddepth, Mat &kernel, Mat &dst, Point &anchor, double &delta, int &borderType) { cv::filter2D(src, dst, ddepth, kernel, anchor, delta, borderType); return dst;})
		 filter2D(src::Mat, ddepth::int, kernel::Mat, dst::Mat, anchor::Point, delta::double, borderType::int) -> ( dst::Mat ) 
	 filter2D
	 .method("jlopencv_cv_filter2D",  [](UMat &src, int &ddepth, UMat &kernel, UMat &dst, Point &anchor, double &delta, int &borderType) { cv::filter2D(src, dst, ddepth, kernel, anchor, delta, borderType); return dst;})
		 filter2D(src::UMat, ddepth::int, kernel::UMat, dst::UMat, anchor::Point, delta::double, borderType::int) -> ( dst::UMat ) 
	 sepFilter2D
	 .method("jlopencv_cv_sepFilter2D",  [](Mat &src, int &ddepth, Mat &kernelX, Mat &kernelY, Mat &dst, Point &anchor, double &delta, int &borderType) { cv::sepFilter2D(src, dst, ddepth, kernelX, kernelY, anchor, delta, borderType); return dst;})
		 sepFilter2D(src::Mat, ddepth::int, kernelX::Mat, kernelY::Mat, dst::Mat, anchor::Point, delta::double, borderType::int) -> ( dst::Mat ) 
	 sepFilter2D
	 .method("jlopencv_cv_sepFilter2D",  [](UMat &src, int &ddepth, UMat &kernelX, UMat &kernelY, UMat &dst, Point &anchor, double &delta, int &borderType) { cv::sepFilter2D(src, dst, ddepth, kernelX, kernelY, anchor, delta, borderType); return dst;})
		 sepFilter2D(src::UMat, ddepth::int, kernelX::UMat, kernelY::UMat, dst::UMat, anchor::Point, delta::double, borderType::int) -> ( dst::UMat ) 
	 Sobel
	 .method("jlopencv_cv_Sobel",  [](Mat &src, int &ddepth, int &dx, int &dy, Mat &dst, int &ksize, double &scale, double &delta, int &borderType) { cv::Sobel(src, dst, ddepth, dx, dy, ksize, scale, delta, borderType); return dst;})
		 Sobel(src::Mat, ddepth::int, dx::int, dy::int, dst::Mat, ksize::int, scale::double, delta::double, borderType::int) -> ( dst::Mat ) 
	 Sobel
	 .method("jlopencv_cv_Sobel",  [](UMat &src, int &ddepth, int &dx, int &dy, UMat &dst, int &ksize, double &scale, double &delta, int &borderType) { cv::Sobel(src, dst, ddepth, dx, dy, ksize, scale, delta, borderType); return dst;})
		 Sobel(src::UMat, ddepth::int, dx::int, dy::int, dst::UMat, ksize::int, scale::double, delta::double, borderType::int) -> ( dst::UMat ) 
	 spatialGradient
	 .method("jlopencv_cv_spatialGradient",  [](Mat &src, Mat &dx, Mat &dy, int &ksize, int &borderType) { cv::spatialGradient(src, dx, dy, ksize, borderType); return make_tuple<Mat,Mat>(dx,dy);})
		 spatialGradient(src::Mat, dx::Mat, dy::Mat, ksize::int, borderType::int) -> ( dx::Mat, dy::Mat ) 
	 spatialGradient
	 .method("jlopencv_cv_spatialGradient",  [](UMat &src, UMat &dx, UMat &dy, int &ksize, int &borderType) { cv::spatialGradient(src, dx, dy, ksize, borderType); return make_tuple<UMat,UMat>(dx,dy);})
		 spatialGradient(src::UMat, dx::UMat, dy::UMat, ksize::int, borderType::int) -> ( dx::UMat, dy::UMat ) 
	 Scharr
	 .method("jlopencv_cv_Scharr",  [](Mat &src, int &ddepth, int &dx, int &dy, Mat &dst, double &scale, double &delta, int &borderType) { cv::Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType); return dst;})
		 Scharr(src::Mat, ddepth::int, dx::int, dy::int, dst::Mat, scale::double, delta::double, borderType::int) -> ( dst::Mat ) 
	 Scharr
	 .method("jlopencv_cv_Scharr",  [](UMat &src, int &ddepth, int &dx, int &dy, UMat &dst, double &scale, double &delta, int &borderType) { cv::Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType); return dst;})
		 Scharr(src::UMat, ddepth::int, dx::int, dy::int, dst::UMat, scale::double, delta::double, borderType::int) -> ( dst::UMat ) 
	 Laplacian
	 .method("jlopencv_cv_Laplacian",  [](Mat &src, int &ddepth, Mat &dst, int &ksize, double &scale, double &delta, int &borderType) { cv::Laplacian(src, dst, ddepth, ksize, scale, delta, borderType); return dst;})
		 Laplacian(src::Mat, ddepth::int, dst::Mat, ksize::int, scale::double, delta::double, borderType::int) -> ( dst::Mat ) 
	 Laplacian
	 .method("jlopencv_cv_Laplacian",  [](UMat &src, int &ddepth, UMat &dst, int &ksize, double &scale, double &delta, int &borderType) { cv::Laplacian(src, dst, ddepth, ksize, scale, delta, borderType); return dst;})
		 Laplacian(src::UMat, ddepth::int, dst::UMat, ksize::int, scale::double, delta::double, borderType::int) -> ( dst::UMat ) 
	 Canny
	 .method("jlopencv_cv_Canny",  [](Mat &image, double &threshold1, double &threshold2, Mat &edges, int &apertureSize, bool &L2gradient) { cv::Canny(image, edges, threshold1, threshold2, apertureSize, L2gradient); return edges;})
		 Canny(image::Mat, threshold1::double, threshold2::double, edges::Mat, apertureSize::int, L2gradient::bool) -> ( edges::Mat ) 
	 Canny
	 .method("jlopencv_cv_Canny",  [](UMat &image, double &threshold1, double &threshold2, UMat &edges, int &apertureSize, bool &L2gradient) { cv::Canny(image, edges, threshold1, threshold2, apertureSize, L2gradient); return edges;})
		 Canny(image::UMat, threshold1::double, threshold2::double, edges::UMat, apertureSize::int, L2gradient::bool) -> ( edges::UMat ) 
	 Canny
	 .method("jlopencv_cv_Canny",  [](Mat &dx, Mat &dy, double &threshold1, double &threshold2, Mat &edges, bool &L2gradient) { cv::Canny(dx, dy, edges, threshold1, threshold2, L2gradient); return edges;})
		 Canny(dx::Mat, dy::Mat, threshold1::double, threshold2::double, edges::Mat, L2gradient::bool) -> ( edges::Mat ) 
	 Canny
	 .method("jlopencv_cv_Canny",  [](UMat &dx, UMat &dy, double &threshold1, double &threshold2, UMat &edges, bool &L2gradient) { cv::Canny(dx, dy, edges, threshold1, threshold2, L2gradient); return edges;})
		 Canny(dx::UMat, dy::UMat, threshold1::double, threshold2::double, edges::UMat, L2gradient::bool) -> ( edges::UMat ) 
	 cornerMinEigenVal
	 .method("jlopencv_cv_cornerMinEigenVal",  [](Mat &src, int &blockSize, Mat &dst, int &ksize, int &borderType) { cv::cornerMinEigenVal(src, dst, blockSize, ksize, borderType); return dst;})
		 cornerMinEigenVal(src::Mat, blockSize::int, dst::Mat, ksize::int, borderType::int) -> ( dst::Mat ) 
	 cornerMinEigenVal
	 .method("jlopencv_cv_cornerMinEigenVal",  [](UMat &src, int &blockSize, UMat &dst, int &ksize, int &borderType) { cv::cornerMinEigenVal(src, dst, blockSize, ksize, borderType); return dst;})
		 cornerMinEigenVal(src::UMat, blockSize::int, dst::UMat, ksize::int, borderType::int) -> ( dst::UMat ) 
	 cornerHarris
	 .method("jlopencv_cv_cornerHarris",  [](Mat &src, int &blockSize, int &ksize, double &k, Mat &dst, int &borderType) { cv::cornerHarris(src, dst, blockSize, ksize, k, borderType); return dst;})
		 cornerHarris(src::Mat, blockSize::int, ksize::int, k::double, dst::Mat, borderType::int) -> ( dst::Mat ) 
	 cornerHarris
	 .method("jlopencv_cv_cornerHarris",  [](UMat &src, int &blockSize, int &ksize, double &k, UMat &dst, int &borderType) { cv::cornerHarris(src, dst, blockSize, ksize, k, borderType); return dst;})
		 cornerHarris(src::UMat, blockSize::int, ksize::int, k::double, dst::UMat, borderType::int) -> ( dst::UMat ) 
	 cornerEigenValsAndVecs
	 .method("jlopencv_cv_cornerEigenValsAndVecs",  [](Mat &src, int &blockSize, int &ksize, Mat &dst, int &borderType) { cv::cornerEigenValsAndVecs(src, dst, blockSize, ksize, borderType); return dst;})
		 cornerEigenValsAndVecs(src::Mat, blockSize::int, ksize::int, dst::Mat, borderType::int) -> ( dst::Mat ) 
	 cornerEigenValsAndVecs
	 .method("jlopencv_cv_cornerEigenValsAndVecs",  [](UMat &src, int &blockSize, int &ksize, UMat &dst, int &borderType) { cv::cornerEigenValsAndVecs(src, dst, blockSize, ksize, borderType); return dst;})
		 cornerEigenValsAndVecs(src::UMat, blockSize::int, ksize::int, dst::UMat, borderType::int) -> ( dst::UMat ) 
	 preCornerDetect
	 .method("jlopencv_cv_preCornerDetect",  [](Mat &src, int &ksize, Mat &dst, int &borderType) { cv::preCornerDetect(src, dst, ksize, borderType); return dst;})
		 preCornerDetect(src::Mat, ksize::int, dst::Mat, borderType::int) -> ( dst::Mat ) 
	 preCornerDetect
	 .method("jlopencv_cv_preCornerDetect",  [](UMat &src, int &ksize, UMat &dst, int &borderType) { cv::preCornerDetect(src, dst, ksize, borderType); return dst;})
		 preCornerDetect(src::UMat, ksize::int, dst::UMat, borderType::int) -> ( dst::UMat ) 
	 cornerSubPix
	 .method("jlopencv_cv_cornerSubPix",  [](Mat &image, Mat &corners, Size &winSize, Size &zeroZone, TermCriteria &criteria) { cv::cornerSubPix(image, corners, winSize, zeroZone, criteria); return corners;})
		 cornerSubPix(image::Mat, corners::Mat, winSize::Size, zeroZone::Size, criteria::TermCriteria) -> ( corners::Mat ) 
	 cornerSubPix
	 .method("jlopencv_cv_cornerSubPix",  [](UMat &image, UMat &corners, Size &winSize, Size &zeroZone, TermCriteria &criteria) { cv::cornerSubPix(image, corners, winSize, zeroZone, criteria); return corners;})
		 cornerSubPix(image::UMat, corners::UMat, winSize::Size, zeroZone::Size, criteria::TermCriteria) -> ( corners::UMat ) 
	 goodFeaturesToTrack
	 .method("jlopencv_cv_goodFeaturesToTrack",  [](Mat &image, int &maxCorners, double &qualityLevel, double &minDistance, Mat &corners, Mat &mask, int &blockSize, bool &useHarrisDetector, double &k) { cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, blockSize, useHarrisDetector, k); return corners;})
		 goodFeaturesToTrack(image::Mat, maxCorners::int, qualityLevel::double, minDistance::double, corners::Mat, mask::Mat, blockSize::int, useHarrisDetector::bool, k::double) -> ( corners::Mat ) 
	 goodFeaturesToTrack
	 .method("jlopencv_cv_goodFeaturesToTrack",  [](UMat &image, int &maxCorners, double &qualityLevel, double &minDistance, UMat &corners, UMat &mask, int &blockSize, bool &useHarrisDetector, double &k) { cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, blockSize, useHarrisDetector, k); return corners;})
		 goodFeaturesToTrack(image::UMat, maxCorners::int, qualityLevel::double, minDistance::double, corners::UMat, mask::UMat, blockSize::int, useHarrisDetector::bool, k::double) -> ( corners::UMat ) 
	 goodFeaturesToTrack
	 .method("jlopencv_cv_goodFeaturesToTrack",  [](Mat &image, int &maxCorners, double &qualityLevel, double &minDistance, Mat &mask, int &blockSize, int &gradientSize, Mat &corners, bool &useHarrisDetector, double &k) { cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, blockSize, gradientSize, useHarrisDetector, k); return corners;})
		 goodFeaturesToTrack(image::Mat, maxCorners::int, qualityLevel::double, minDistance::double, mask::Mat, blockSize::int, gradientSize::int, corners::Mat, useHarrisDetector::bool, k::double) -> ( corners::Mat ) 
	 goodFeaturesToTrack
	 .method("jlopencv_cv_goodFeaturesToTrack",  [](UMat &image, int &maxCorners, double &qualityLevel, double &minDistance, UMat &mask, int &blockSize, int &gradientSize, UMat &corners, bool &useHarrisDetector, double &k) { cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, blockSize, gradientSize, useHarrisDetector, k); return corners;})
		 goodFeaturesToTrack(image::UMat, maxCorners::int, qualityLevel::double, minDistance::double, mask::UMat, blockSize::int, gradientSize::int, corners::UMat, useHarrisDetector::bool, k::double) -> ( corners::UMat ) 
	 HoughLines
	 .method("jlopencv_cv_HoughLines",  [](Mat &image, double &rho, double &theta, int &threshold, Mat &lines, double &srn, double &stn, double &min_theta, double &max_theta) { cv::HoughLines(image, lines, rho, theta, threshold, srn, stn, min_theta, max_theta); return lines;})
		 HoughLines(image::Mat, rho::double, theta::double, threshold::int, lines::Mat, srn::double, stn::double, min_theta::double, max_theta::double) -> ( lines::Mat ) 
	 HoughLines
	 .method("jlopencv_cv_HoughLines",  [](UMat &image, double &rho, double &theta, int &threshold, UMat &lines, double &srn, double &stn, double &min_theta, double &max_theta) { cv::HoughLines(image, lines, rho, theta, threshold, srn, stn, min_theta, max_theta); return lines;})
		 HoughLines(image::UMat, rho::double, theta::double, threshold::int, lines::UMat, srn::double, stn::double, min_theta::double, max_theta::double) -> ( lines::UMat ) 
	 HoughLinesP
	 .method("jlopencv_cv_HoughLinesP",  [](Mat &image, double &rho, double &theta, int &threshold, Mat &lines, double &minLineLength, double &maxLineGap) { cv::HoughLinesP(image, lines, rho, theta, threshold, minLineLength, maxLineGap); return lines;})
		 HoughLinesP(image::Mat, rho::double, theta::double, threshold::int, lines::Mat, minLineLength::double, maxLineGap::double) -> ( lines::Mat ) 
	 HoughLinesP
	 .method("jlopencv_cv_HoughLinesP",  [](UMat &image, double &rho, double &theta, int &threshold, UMat &lines, double &minLineLength, double &maxLineGap) { cv::HoughLinesP(image, lines, rho, theta, threshold, minLineLength, maxLineGap); return lines;})
		 HoughLinesP(image::UMat, rho::double, theta::double, threshold::int, lines::UMat, minLineLength::double, maxLineGap::double) -> ( lines::UMat ) 
	 HoughLinesPointSet
	 .method("jlopencv_cv_HoughLinesPointSet",  [](Mat &_point, int &lines_max, int &threshold, double &min_rho, double &max_rho, double &rho_step, double &min_theta, double &max_theta, double &theta_step, Mat &_lines) { cv::HoughLinesPointSet(_point, _lines, lines_max, threshold, min_rho, max_rho, rho_step, min_theta, max_theta, theta_step); return _lines;})
		 HoughLinesPointSet(_point::Mat, lines_max::int, threshold::int, min_rho::double, max_rho::double, rho_step::double, min_theta::double, max_theta::double, theta_step::double; _lines::Mat) -> ( _lines::Mat ) 
	 HoughLinesPointSet
	 .method("jlopencv_cv_HoughLinesPointSet",  [](UMat &_point, int &lines_max, int &threshold, double &min_rho, double &max_rho, double &rho_step, double &min_theta, double &max_theta, double &theta_step, UMat &_lines) { cv::HoughLinesPointSet(_point, _lines, lines_max, threshold, min_rho, max_rho, rho_step, min_theta, max_theta, theta_step); return _lines;})
		 HoughLinesPointSet(_point::UMat, lines_max::int, threshold::int, min_rho::double, max_rho::double, rho_step::double, min_theta::double, max_theta::double, theta_step::double; _lines::UMat) -> ( _lines::UMat ) 
	 HoughCircles
	 .method("jlopencv_cv_HoughCircles",  [](Mat &image, int &method, double &dp, double &minDist, Mat &circles, double &param1, double &param2, int &minRadius, int &maxRadius) { cv::HoughCircles(image, circles, method, dp, minDist, param1, param2, minRadius, maxRadius); return circles;})
		 HoughCircles(image::Mat, method::int, dp::double, minDist::double, circles::Mat, param1::double, param2::double, minRadius::int, maxRadius::int) -> ( circles::Mat ) 
	 HoughCircles
	 .method("jlopencv_cv_HoughCircles",  [](UMat &image, int &method, double &dp, double &minDist, UMat &circles, double &param1, double &param2, int &minRadius, int &maxRadius) { cv::HoughCircles(image, circles, method, dp, minDist, param1, param2, minRadius, maxRadius); return circles;})
		 HoughCircles(image::UMat, method::int, dp::double, minDist::double, circles::UMat, param1::double, param2::double, minRadius::int, maxRadius::int) -> ( circles::UMat ) 
	 erode
	 .method("jlopencv_cv_erode",  [](Mat &src, Mat &kernel, Mat &dst, Point &anchor, int &iterations, int &borderType, Scalar &borderValue) { cv::erode(src, dst, kernel, anchor, iterations, borderType, borderValue); return dst;})
		 erode(src::Mat, kernel::Mat, dst::Mat, anchor::Point, iterations::int, borderType::int, borderValue::Scalar) -> ( dst::Mat ) 
	 erode
	 .method("jlopencv_cv_erode",  [](UMat &src, UMat &kernel, UMat &dst, Point &anchor, int &iterations, int &borderType, Scalar &borderValue) { cv::erode(src, dst, kernel, anchor, iterations, borderType, borderValue); return dst;})
		 erode(src::UMat, kernel::UMat, dst::UMat, anchor::Point, iterations::int, borderType::int, borderValue::Scalar) -> ( dst::UMat ) 
	 dilate
	 .method("jlopencv_cv_dilate",  [](Mat &src, Mat &kernel, Mat &dst, Point &anchor, int &iterations, int &borderType, Scalar &borderValue) { cv::dilate(src, dst, kernel, anchor, iterations, borderType, borderValue); return dst;})
		 dilate(src::Mat, kernel::Mat, dst::Mat, anchor::Point, iterations::int, borderType::int, borderValue::Scalar) -> ( dst::Mat ) 
	 dilate
	 .method("jlopencv_cv_dilate",  [](UMat &src, UMat &kernel, UMat &dst, Point &anchor, int &iterations, int &borderType, Scalar &borderValue) { cv::dilate(src, dst, kernel, anchor, iterations, borderType, borderValue); return dst;})
		 dilate(src::UMat, kernel::UMat, dst::UMat, anchor::Point, iterations::int, borderType::int, borderValue::Scalar) -> ( dst::UMat ) 
	 morphologyEx
	 .method("jlopencv_cv_morphologyEx",  [](Mat &src, int &op, Mat &kernel, Mat &dst, Point &anchor, int &iterations, int &borderType, Scalar &borderValue) { cv::morphologyEx(src, dst, op, kernel, anchor, iterations, borderType, borderValue); return dst;})
		 morphologyEx(src::Mat, op::int, kernel::Mat, dst::Mat, anchor::Point, iterations::int, borderType::int, borderValue::Scalar) -> ( dst::Mat ) 
	 morphologyEx
	 .method("jlopencv_cv_morphologyEx",  [](UMat &src, int &op, UMat &kernel, UMat &dst, Point &anchor, int &iterations, int &borderType, Scalar &borderValue) { cv::morphologyEx(src, dst, op, kernel, anchor, iterations, borderType, borderValue); return dst;})
		 morphologyEx(src::UMat, op::int, kernel::UMat, dst::UMat, anchor::Point, iterations::int, borderType::int, borderValue::Scalar) -> ( dst::UMat ) 
	 resize
	 .method("jlopencv_cv_resize",  [](Mat &src, Size &dsize, Mat &dst, double &fx, double &fy, int &interpolation) { cv::resize(src, dst, dsize, fx, fy, interpolation); return dst;})
		 resize(src::Mat, dsize::Size, dst::Mat, fx::double, fy::double, interpolation::int) -> ( dst::Mat ) 
	 resize
	 .method("jlopencv_cv_resize",  [](UMat &src, Size &dsize, UMat &dst, double &fx, double &fy, int &interpolation) { cv::resize(src, dst, dsize, fx, fy, interpolation); return dst;})
		 resize(src::UMat, dsize::Size, dst::UMat, fx::double, fy::double, interpolation::int) -> ( dst::UMat ) 
	 warpAffine
	 .method("jlopencv_cv_warpAffine",  [](Mat &src, Mat &M, Size &dsize, Mat &dst, int &flags, int &borderMode, Scalar &borderValue) { cv::warpAffine(src, dst, M, dsize, flags, borderMode, borderValue); return dst;})
		 warpAffine(src::Mat, M::Mat, dsize::Size, dst::Mat, flags::int, borderMode::int, borderValue::Scalar) -> ( dst::Mat ) 
	 warpAffine
	 .method("jlopencv_cv_warpAffine",  [](UMat &src, UMat &M, Size &dsize, UMat &dst, int &flags, int &borderMode, Scalar &borderValue) { cv::warpAffine(src, dst, M, dsize, flags, borderMode, borderValue); return dst;})
		 warpAffine(src::UMat, M::UMat, dsize::Size, dst::UMat, flags::int, borderMode::int, borderValue::Scalar) -> ( dst::UMat ) 
	 warpPerspective
	 .method("jlopencv_cv_warpPerspective",  [](Mat &src, Mat &M, Size &dsize, Mat &dst, int &flags, int &borderMode, Scalar &borderValue) { cv::warpPerspective(src, dst, M, dsize, flags, borderMode, borderValue); return dst;})
		 warpPerspective(src::Mat, M::Mat, dsize::Size, dst::Mat, flags::int, borderMode::int, borderValue::Scalar) -> ( dst::Mat ) 
	 warpPerspective
	 .method("jlopencv_cv_warpPerspective",  [](UMat &src, UMat &M, Size &dsize, UMat &dst, int &flags, int &borderMode, Scalar &borderValue) { cv::warpPerspective(src, dst, M, dsize, flags, borderMode, borderValue); return dst;})
		 warpPerspective(src::UMat, M::UMat, dsize::Size, dst::UMat, flags::int, borderMode::int, borderValue::Scalar) -> ( dst::UMat ) 
	 remap
	 .method("jlopencv_cv_remap",  [](Mat &src, Mat &map1, Mat &map2, int &interpolation, Mat &dst, int &borderMode, Scalar &borderValue) { cv::remap(src, dst, map1, map2, interpolation, borderMode, borderValue); return dst;})
		 remap(src::Mat, map1::Mat, map2::Mat, interpolation::int, dst::Mat, borderMode::int, borderValue::Scalar) -> ( dst::Mat ) 
	 remap
	 .method("jlopencv_cv_remap",  [](UMat &src, UMat &map1, UMat &map2, int &interpolation, UMat &dst, int &borderMode, Scalar &borderValue) { cv::remap(src, dst, map1, map2, interpolation, borderMode, borderValue); return dst;})
		 remap(src::UMat, map1::UMat, map2::UMat, interpolation::int, dst::UMat, borderMode::int, borderValue::Scalar) -> ( dst::UMat ) 
	 convertMaps
	 .method("jlopencv_cv_convertMaps",  [](Mat &map1, Mat &map2, int &dstmap1type, Mat &dstmap1, Mat &dstmap2, bool &nninterpolation) { cv::convertMaps(map1, map2, dstmap1, dstmap2, dstmap1type, nninterpolation); return make_tuple<Mat,Mat>(dstmap1,dstmap2);})
		 convertMaps(map1::Mat, map2::Mat, dstmap1type::int, dstmap1::Mat, dstmap2::Mat, nninterpolation::bool) -> ( dstmap1::Mat, dstmap2::Mat ) 
	 convertMaps
	 .method("jlopencv_cv_convertMaps",  [](UMat &map1, UMat &map2, int &dstmap1type, UMat &dstmap1, UMat &dstmap2, bool &nninterpolation) { cv::convertMaps(map1, map2, dstmap1, dstmap2, dstmap1type, nninterpolation); return make_tuple<UMat,UMat>(dstmap1,dstmap2);})
		 convertMaps(map1::UMat, map2::UMat, dstmap1type::int, dstmap1::UMat, dstmap2::UMat, nninterpolation::bool) -> ( dstmap1::UMat, dstmap2::UMat ) 
	 getRotationMatrix2D
	 .method("jlopencv_cv_getRotationMatrix2D",  [](Point2f &center, double &angle, double &scale) { auto retval = cv::getRotationMatrix2D(center, angle, scale); return retval;})
		 getRotationMatrix2D(center::Point2f, angle::double, scale::double) -> ( retval::Mat ) 
	 invertAffineTransform
	 .method("jlopencv_cv_invertAffineTransform",  [](Mat &M, Mat &iM) { cv::invertAffineTransform(M, iM); return iM;})
		 invertAffineTransform(M::Mat; iM::Mat) -> ( iM::Mat ) 
	 invertAffineTransform
	 .method("jlopencv_cv_invertAffineTransform",  [](UMat &M, UMat &iM) { cv::invertAffineTransform(M, iM); return iM;})
		 invertAffineTransform(M::UMat; iM::UMat) -> ( iM::UMat ) 
	 getPerspectiveTransform
	 .method("jlopencv_cv_getPerspectiveTransform",  [](Mat &src, Mat &dst, int &solveMethod) { auto retval = cv::getPerspectiveTransform(src, dst, solveMethod); return retval;})
		 getPerspectiveTransform(src::Mat, dst::Mat, solveMethod::int) -> ( retval::Mat ) 
	 getPerspectiveTransform
	 .method("jlopencv_cv_getPerspectiveTransform",  [](UMat &src, UMat &dst, int &solveMethod) { auto retval = cv::getPerspectiveTransform(src, dst, solveMethod); return retval;})
		 getPerspectiveTransform(src::UMat, dst::UMat, solveMethod::int) -> ( retval::Mat ) 
	 getAffineTransform
	 .method("jlopencv_cv_getAffineTransform",  [](Mat &src, Mat &dst) { auto retval = cv::getAffineTransform(src, dst); return retval;})
		 getAffineTransform(src::Mat, dst::Mat) -> ( retval::Mat ) 
	 getAffineTransform
	 .method("jlopencv_cv_getAffineTransform",  [](UMat &src, UMat &dst) { auto retval = cv::getAffineTransform(src, dst); return retval;})
		 getAffineTransform(src::UMat, dst::UMat) -> ( retval::Mat ) 
	 getRectSubPix
	 .method("jlopencv_cv_getRectSubPix",  [](Mat &image, Size &patchSize, Point2f &center, Mat &patch, int &patchType) { cv::getRectSubPix(image, patchSize, center, patch, patchType); return patch;})
		 getRectSubPix(image::Mat, patchSize::Size, center::Point2f, patch::Mat, patchType::int) -> ( patch::Mat ) 
	 getRectSubPix
	 .method("jlopencv_cv_getRectSubPix",  [](UMat &image, Size &patchSize, Point2f &center, UMat &patch, int &patchType) { cv::getRectSubPix(image, patchSize, center, patch, patchType); return patch;})
		 getRectSubPix(image::UMat, patchSize::Size, center::Point2f, patch::UMat, patchType::int) -> ( patch::UMat ) 
	 logPolar
	 .method("jlopencv_cv_logPolar",  [](Mat &src, Point2f &center, double &M, int &flags, Mat &dst) { cv::logPolar(src, dst, center, M, flags); return dst;})
		 logPolar(src::Mat, center::Point2f, M::double, flags::int; dst::Mat) -> ( dst::Mat ) 
	 logPolar
	 .method("jlopencv_cv_logPolar",  [](UMat &src, Point2f &center, double &M, int &flags, UMat &dst) { cv::logPolar(src, dst, center, M, flags); return dst;})
		 logPolar(src::UMat, center::Point2f, M::double, flags::int; dst::UMat) -> ( dst::UMat ) 
	 linearPolar
	 .method("jlopencv_cv_linearPolar",  [](Mat &src, Point2f &center, double &maxRadius, int &flags, Mat &dst) { cv::linearPolar(src, dst, center, maxRadius, flags); return dst;})
		 linearPolar(src::Mat, center::Point2f, maxRadius::double, flags::int; dst::Mat) -> ( dst::Mat ) 
	 linearPolar
	 .method("jlopencv_cv_linearPolar",  [](UMat &src, Point2f &center, double &maxRadius, int &flags, UMat &dst) { cv::linearPolar(src, dst, center, maxRadius, flags); return dst;})
		 linearPolar(src::UMat, center::Point2f, maxRadius::double, flags::int; dst::UMat) -> ( dst::UMat ) 
	 warpPolar
	 .method("jlopencv_cv_warpPolar",  [](Mat &src, Size &dsize, Point2f &center, double &maxRadius, int &flags, Mat &dst) { cv::warpPolar(src, dst, dsize, center, maxRadius, flags); return dst;})
		 warpPolar(src::Mat, dsize::Size, center::Point2f, maxRadius::double, flags::int; dst::Mat) -> ( dst::Mat ) 
	 warpPolar
	 .method("jlopencv_cv_warpPolar",  [](UMat &src, Size &dsize, Point2f &center, double &maxRadius, int &flags, UMat &dst) { cv::warpPolar(src, dst, dsize, center, maxRadius, flags); return dst;})
		 warpPolar(src::UMat, dsize::Size, center::Point2f, maxRadius::double, flags::int; dst::UMat) -> ( dst::UMat ) 
	 integral
	 .method("jlopencv_cv_integral",  [](Mat &src, Mat &sum, int &sdepth) { cv::integral(src, sum, sdepth); return sum;})
		 integral(src::Mat, sum::Mat, sdepth::int) -> ( sum::Mat ) 
	 integral
	 .method("jlopencv_cv_integral",  [](UMat &src, UMat &sum, int &sdepth) { cv::integral(src, sum, sdepth); return sum;})
		 integral(src::UMat, sum::UMat, sdepth::int) -> ( sum::UMat ) 
	 integral2
	 .method("jlopencv_cv_integral2",  [](Mat &src, Mat &sum, Mat &sqsum, int &sdepth, int &sqdepth) { cv::integral(src, sum, sqsum, sdepth, sqdepth); return make_tuple<Mat,Mat>(sum,sqsum);})
		 integral2(src::Mat, sum::Mat, sqsum::Mat, sdepth::int, sqdepth::int) -> ( sum::Mat, sqsum::Mat ) 
	 integral2
	 .method("jlopencv_cv_integral2",  [](UMat &src, UMat &sum, UMat &sqsum, int &sdepth, int &sqdepth) { cv::integral(src, sum, sqsum, sdepth, sqdepth); return make_tuple<UMat,UMat>(sum,sqsum);})
		 integral2(src::UMat, sum::UMat, sqsum::UMat, sdepth::int, sqdepth::int) -> ( sum::UMat, sqsum::UMat ) 
	 integral3
	 .method("jlopencv_cv_integral3",  [](Mat &src, Mat &sum, Mat &sqsum, Mat &tilted, int &sdepth, int &sqdepth) { cv::integral(src, sum, sqsum, tilted, sdepth, sqdepth); return make_tuple<Mat,Mat,Mat>(sum,sqsum,tilted);})
		 integral3(src::Mat, sum::Mat, sqsum::Mat, tilted::Mat, sdepth::int, sqdepth::int) -> ( sum::Mat, sqsum::Mat, tilted::Mat ) 
	 integral3
	 .method("jlopencv_cv_integral3",  [](UMat &src, UMat &sum, UMat &sqsum, UMat &tilted, int &sdepth, int &sqdepth) { cv::integral(src, sum, sqsum, tilted, sdepth, sqdepth); return make_tuple<UMat,UMat,UMat>(sum,sqsum,tilted);})
		 integral3(src::UMat, sum::UMat, sqsum::UMat, tilted::UMat, sdepth::int, sqdepth::int) -> ( sum::UMat, sqsum::UMat, tilted::UMat ) 
	 accumulate
	 .method("jlopencv_cv_accumulate",  [](Mat &src, Mat &dst, Mat &mask) { cv::accumulate(src, dst, mask); return dst;})
		 accumulate(src::Mat, dst::Mat, mask::Mat) -> ( dst::Mat ) 
	 accumulate
	 .method("jlopencv_cv_accumulate",  [](UMat &src, UMat &dst, UMat &mask) { cv::accumulate(src, dst, mask); return dst;})
		 accumulate(src::UMat, dst::UMat, mask::UMat) -> ( dst::UMat ) 
	 accumulateSquare
	 .method("jlopencv_cv_accumulateSquare",  [](Mat &src, Mat &dst, Mat &mask) { cv::accumulateSquare(src, dst, mask); return dst;})
		 accumulateSquare(src::Mat, dst::Mat, mask::Mat) -> ( dst::Mat ) 
	 accumulateSquare
	 .method("jlopencv_cv_accumulateSquare",  [](UMat &src, UMat &dst, UMat &mask) { cv::accumulateSquare(src, dst, mask); return dst;})
		 accumulateSquare(src::UMat, dst::UMat, mask::UMat) -> ( dst::UMat ) 
	 accumulateProduct
	 .method("jlopencv_cv_accumulateProduct",  [](Mat &src1, Mat &src2, Mat &dst, Mat &mask) { cv::accumulateProduct(src1, src2, dst, mask); return dst;})
		 accumulateProduct(src1::Mat, src2::Mat, dst::Mat, mask::Mat) -> ( dst::Mat ) 
	 accumulateProduct
	 .method("jlopencv_cv_accumulateProduct",  [](UMat &src1, UMat &src2, UMat &dst, UMat &mask) { cv::accumulateProduct(src1, src2, dst, mask); return dst;})
		 accumulateProduct(src1::UMat, src2::UMat, dst::UMat, mask::UMat) -> ( dst::UMat ) 
	 accumulateWeighted
	 .method("jlopencv_cv_accumulateWeighted",  [](Mat &src, Mat &dst, double &alpha, Mat &mask) { cv::accumulateWeighted(src, dst, alpha, mask); return dst;})
		 accumulateWeighted(src::Mat, dst::Mat, alpha::double, mask::Mat) -> ( dst::Mat ) 
	 accumulateWeighted
	 .method("jlopencv_cv_accumulateWeighted",  [](UMat &src, UMat &dst, double &alpha, UMat &mask) { cv::accumulateWeighted(src, dst, alpha, mask); return dst;})
		 accumulateWeighted(src::UMat, dst::UMat, alpha::double, mask::UMat) -> ( dst::UMat ) 
	 phaseCorrelate
	 .method("jlopencv_cv_phaseCorrelate",  [](Mat &src1, Mat &src2, Mat &window) {double response; auto retval = cv::phaseCorrelate(src1, src2, window, response); return make_tuple<Point2d,double>(retval,response);})
		 phaseCorrelate(src1::Mat, src2::Mat, window::Mat) -> ( retval::Point2d, response::double* ) 
	 phaseCorrelate
	 .method("jlopencv_cv_phaseCorrelate",  [](UMat &src1, UMat &src2, UMat &window) {double response; auto retval = cv::phaseCorrelate(src1, src2, window, response); return make_tuple<Point2d,double>(retval,response);})
		 phaseCorrelate(src1::UMat, src2::UMat, window::UMat) -> ( retval::Point2d, response::double* ) 
	 createHanningWindow
	 .method("jlopencv_cv_createHanningWindow",  [](Size &winSize, int &type, Mat &dst) { cv::createHanningWindow(dst, winSize, type); return dst;})
		 createHanningWindow(winSize::Size, type::int; dst::Mat) -> ( dst::Mat ) 
	 createHanningWindow
	 .method("jlopencv_cv_createHanningWindow",  [](Size &winSize, int &type, UMat &dst) { cv::createHanningWindow(dst, winSize, type); return dst;})
		 createHanningWindow(winSize::Size, type::int; dst::UMat) -> ( dst::UMat ) 
	 threshold
	 .method("jlopencv_cv_threshold",  [](Mat &src, double &thresh, double &maxval, int &type, Mat &dst) { auto retval = cv::threshold(src, dst, thresh, maxval, type); return make_tuple<double,Mat>(retval,dst);})
		 threshold(src::Mat, thresh::double, maxval::double, type::int; dst::Mat) -> ( retval::double, dst::Mat ) 
	 threshold
	 .method("jlopencv_cv_threshold",  [](UMat &src, double &thresh, double &maxval, int &type, UMat &dst) { auto retval = cv::threshold(src, dst, thresh, maxval, type); return make_tuple<double,UMat>(retval,dst);})
		 threshold(src::UMat, thresh::double, maxval::double, type::int; dst::UMat) -> ( retval::double, dst::UMat ) 
	 adaptiveThreshold
	 .method("jlopencv_cv_adaptiveThreshold",  [](Mat &src, double &maxValue, int &adaptiveMethod, int &thresholdType, int &blockSize, double &C, Mat &dst) { cv::adaptiveThreshold(src, dst, maxValue, adaptiveMethod, thresholdType, blockSize, C); return dst;})
		 adaptiveThreshold(src::Mat, maxValue::double, adaptiveMethod::int, thresholdType::int, blockSize::int, C::double; dst::Mat) -> ( dst::Mat ) 
	 adaptiveThreshold
	 .method("jlopencv_cv_adaptiveThreshold",  [](UMat &src, double &maxValue, int &adaptiveMethod, int &thresholdType, int &blockSize, double &C, UMat &dst) { cv::adaptiveThreshold(src, dst, maxValue, adaptiveMethod, thresholdType, blockSize, C); return dst;})
		 adaptiveThreshold(src::UMat, maxValue::double, adaptiveMethod::int, thresholdType::int, blockSize::int, C::double; dst::UMat) -> ( dst::UMat ) 
	 pyrDown
	 .method("jlopencv_cv_pyrDown",  [](Mat &src, Mat &dst, Size &dstsize, int &borderType) { cv::pyrDown(src, dst, dstsize, borderType); return dst;})
		 pyrDown(src::Mat, dst::Mat, dstsize::Size, borderType::int) -> ( dst::Mat ) 
	 pyrDown
	 .method("jlopencv_cv_pyrDown",  [](UMat &src, UMat &dst, Size &dstsize, int &borderType) { cv::pyrDown(src, dst, dstsize, borderType); return dst;})
		 pyrDown(src::UMat, dst::UMat, dstsize::Size, borderType::int) -> ( dst::UMat ) 
	 pyrUp
	 .method("jlopencv_cv_pyrUp",  [](Mat &src, Mat &dst, Size &dstsize, int &borderType) { cv::pyrUp(src, dst, dstsize, borderType); return dst;})
		 pyrUp(src::Mat, dst::Mat, dstsize::Size, borderType::int) -> ( dst::Mat ) 
	 pyrUp
	 .method("jlopencv_cv_pyrUp",  [](UMat &src, UMat &dst, Size &dstsize, int &borderType) { cv::pyrUp(src, dst, dstsize, borderType); return dst;})
		 pyrUp(src::UMat, dst::UMat, dstsize::Size, borderType::int) -> ( dst::UMat ) 
	 calcHist
	 .method("jlopencv_cv_calcHist",  [](vector<Mat> &images, vector<int> &channels, Mat &mask, vector<int> &histSize, vector<float> &ranges, Mat &hist, bool &accumulate) { cv::calcHist(images, channels, mask, hist, histSize, ranges, accumulate); return hist;})
		 calcHist(images::vector<Mat>, channels::vector<int>, mask::Mat, histSize::vector<int>, ranges::vector<float>, hist::Mat, accumulate::bool) -> ( hist::Mat ) 
	 calcHist
	 .method("jlopencv_cv_calcHist",  [](vector<UMat> &images, vector<int> &channels, UMat &mask, vector<int> &histSize, vector<float> &ranges, UMat &hist, bool &accumulate) { cv::calcHist(images, channels, mask, hist, histSize, ranges, accumulate); return hist;})
		 calcHist(images::vector<UMat>, channels::vector<int>, mask::UMat, histSize::vector<int>, ranges::vector<float>, hist::UMat, accumulate::bool) -> ( hist::UMat ) 
	 calcBackProject
	 .method("jlopencv_cv_calcBackProject",  [](vector<Mat> &images, vector<int> &channels, Mat &hist, vector<float> &ranges, double &scale, Mat &dst) { cv::calcBackProject(images, channels, hist, dst, ranges, scale); return dst;})
		 calcBackProject(images::vector<Mat>, channels::vector<int>, hist::Mat, ranges::vector<float>, scale::double; dst::Mat) -> ( dst::Mat ) 
	 calcBackProject
	 .method("jlopencv_cv_calcBackProject",  [](vector<UMat> &images, vector<int> &channels, UMat &hist, vector<float> &ranges, double &scale, UMat &dst) { cv::calcBackProject(images, channels, hist, dst, ranges, scale); return dst;})
		 calcBackProject(images::vector<UMat>, channels::vector<int>, hist::UMat, ranges::vector<float>, scale::double; dst::UMat) -> ( dst::UMat ) 
	 compareHist
	 .method("jlopencv_cv_compareHist",  [](Mat &H1, Mat &H2, int &method) { auto retval = cv::compareHist(H1, H2, method); return retval;})
		 compareHist(H1::Mat, H2::Mat, method::int) -> ( retval::double ) 
	 compareHist
	 .method("jlopencv_cv_compareHist",  [](UMat &H1, UMat &H2, int &method) { auto retval = cv::compareHist(H1, H2, method); return retval;})
		 compareHist(H1::UMat, H2::UMat, method::int) -> ( retval::double ) 
	 equalizeHist
	 .method("jlopencv_cv_equalizeHist",  [](Mat &src, Mat &dst) { cv::equalizeHist(src, dst); return dst;})
		 equalizeHist(src::Mat; dst::Mat) -> ( dst::Mat ) 
	 equalizeHist
	 .method("jlopencv_cv_equalizeHist",  [](UMat &src, UMat &dst) { cv::equalizeHist(src, dst); return dst;})
		 equalizeHist(src::UMat; dst::UMat) -> ( dst::UMat ) 
	 createCLAHE
	 .method("jlopencv_cv_createCLAHE",  [](double &clipLimit, Size &tileGridSize) { auto retval = cv::createCLAHE(clipLimit, tileGridSize); return retval;})
		 createCLAHE(clipLimit::double, tileGridSize::Size) -> ( retval::Ptr<CLAHE> ) 
	 EMD
	 .method("jlopencv_cv_EMD",  [](Mat &signature1, Mat &signature2, int &distType, Mat &cost, Ptr<float> &lowerBound, Mat &flow) { auto retval = cv::wrapperEMD(signature1, signature2, distType, cost, lowerBound, flow); return make_tuple<float,Ptr<float>,Mat>(retval,lowerBound,flow);})
		 EMD(signature1::Mat, signature2::Mat, distType::int, cost::Mat, lowerBound::Ptr<float>; flow::Mat) -> ( retval::float, lowerBound::Ptr<float>, flow::Mat ) 
	 EMD
	 .method("jlopencv_cv_EMD",  [](UMat &signature1, UMat &signature2, int &distType, UMat &cost, Ptr<float> &lowerBound, UMat &flow) { auto retval = cv::wrapperEMD(signature1, signature2, distType, cost, lowerBound, flow); return make_tuple<float,Ptr<float>,UMat>(retval,lowerBound,flow);})
		 EMD(signature1::UMat, signature2::UMat, distType::int, cost::UMat, lowerBound::Ptr<float>; flow::UMat) -> ( retval::float, lowerBound::Ptr<float>, flow::UMat ) 
	 watershed
	 .method("jlopencv_cv_watershed",  [](Mat &image, Mat &markers) { cv::watershed(image, markers); return markers;})
		 watershed(image::Mat, markers::Mat) -> ( markers::Mat ) 
	 watershed
	 .method("jlopencv_cv_watershed",  [](UMat &image, UMat &markers) { cv::watershed(image, markers); return markers;})
		 watershed(image::UMat, markers::UMat) -> ( markers::UMat ) 
	 pyrMeanShiftFiltering
	 .method("jlopencv_cv_pyrMeanShiftFiltering",  [](Mat &src, double &sp, double &sr, Mat &dst, int &maxLevel, TermCriteria &termcrit) { cv::pyrMeanShiftFiltering(src, dst, sp, sr, maxLevel, termcrit); return dst;})
		 pyrMeanShiftFiltering(src::Mat, sp::double, sr::double, dst::Mat, maxLevel::int, termcrit::TermCriteria) -> ( dst::Mat ) 
	 pyrMeanShiftFiltering
	 .method("jlopencv_cv_pyrMeanShiftFiltering",  [](UMat &src, double &sp, double &sr, UMat &dst, int &maxLevel, TermCriteria &termcrit) { cv::pyrMeanShiftFiltering(src, dst, sp, sr, maxLevel, termcrit); return dst;})
		 pyrMeanShiftFiltering(src::UMat, sp::double, sr::double, dst::UMat, maxLevel::int, termcrit::TermCriteria) -> ( dst::UMat ) 
	 grabCut
	 .method("jlopencv_cv_grabCut",  [](Mat &img, Mat &mask, Rect &rect, Mat &bgdModel, Mat &fgdModel, int &iterCount, int &mode) { cv::grabCut(img, mask, rect, bgdModel, fgdModel, iterCount, mode); return make_tuple<Mat,Mat,Mat>(mask,bgdModel,fgdModel);})
		 grabCut(img::Mat, mask::Mat, rect::Rect, bgdModel::Mat, fgdModel::Mat, iterCount::int, mode::int) -> ( mask::Mat, bgdModel::Mat, fgdModel::Mat ) 
	 grabCut
	 .method("jlopencv_cv_grabCut",  [](UMat &img, UMat &mask, Rect &rect, UMat &bgdModel, UMat &fgdModel, int &iterCount, int &mode) { cv::grabCut(img, mask, rect, bgdModel, fgdModel, iterCount, mode); return make_tuple<UMat,UMat,UMat>(mask,bgdModel,fgdModel);})
		 grabCut(img::UMat, mask::UMat, rect::Rect, bgdModel::UMat, fgdModel::UMat, iterCount::int, mode::int) -> ( mask::UMat, bgdModel::UMat, fgdModel::UMat ) 
	 distanceTransformWithLabels
	 .method("jlopencv_cv_distanceTransformWithLabels",  [](Mat &src, int &distanceType, int &maskSize, Mat &dst, Mat &labels, int &labelType) { cv::distanceTransform(src, dst, labels, distanceType, maskSize, labelType); return make_tuple<Mat,Mat>(dst,labels);})
		 distanceTransformWithLabels(src::Mat, distanceType::int, maskSize::int, dst::Mat, labels::Mat, labelType::int) -> ( dst::Mat, labels::Mat ) 
	 distanceTransformWithLabels
	 .method("jlopencv_cv_distanceTransformWithLabels",  [](UMat &src, int &distanceType, int &maskSize, UMat &dst, UMat &labels, int &labelType) { cv::distanceTransform(src, dst, labels, distanceType, maskSize, labelType); return make_tuple<UMat,UMat>(dst,labels);})
		 distanceTransformWithLabels(src::UMat, distanceType::int, maskSize::int, dst::UMat, labels::UMat, labelType::int) -> ( dst::UMat, labels::UMat ) 
	 distanceTransform
	 .method("jlopencv_cv_distanceTransform",  [](Mat &src, int &distanceType, int &maskSize, Mat &dst, int &dstType) { cv::distanceTransform(src, dst, distanceType, maskSize, dstType); return dst;})
		 distanceTransform(src::Mat, distanceType::int, maskSize::int, dst::Mat, dstType::int) -> ( dst::Mat ) 
	 distanceTransform
	 .method("jlopencv_cv_distanceTransform",  [](UMat &src, int &distanceType, int &maskSize, UMat &dst, int &dstType) { cv::distanceTransform(src, dst, distanceType, maskSize, dstType); return dst;})
		 distanceTransform(src::UMat, distanceType::int, maskSize::int, dst::UMat, dstType::int) -> ( dst::UMat ) 
	 floodFill
	 .method("jlopencv_cv_floodFill",  [](Mat &image, Mat &mask, Point &seedPoint, Scalar &newVal, Scalar &loDiff, Scalar &upDiff, int &flags) {Rect rect; auto retval = cv::floodFill(image, mask, seedPoint, newVal, rect, loDiff, upDiff, flags); return make_tuple<int,Mat,Mat,Rect>(retval,image,mask,rect);})
		 floodFill(image::Mat, mask::Mat, seedPoint::Point, newVal::Scalar, loDiff::Scalar, upDiff::Scalar, flags::int) -> ( retval::int, image::Mat, mask::Mat, rect::Rect* ) 
	 floodFill
	 .method("jlopencv_cv_floodFill",  [](UMat &image, UMat &mask, Point &seedPoint, Scalar &newVal, Scalar &loDiff, Scalar &upDiff, int &flags) {Rect rect; auto retval = cv::floodFill(image, mask, seedPoint, newVal, rect, loDiff, upDiff, flags); return make_tuple<int,UMat,UMat,Rect>(retval,image,mask,rect);})
		 floodFill(image::UMat, mask::UMat, seedPoint::Point, newVal::Scalar, loDiff::Scalar, upDiff::Scalar, flags::int) -> ( retval::int, image::UMat, mask::UMat, rect::Rect* ) 
	 cvtColor
	 .method("jlopencv_cv_cvtColor",  [](Mat &src, int &code, Mat &dst, int &dstCn) { cv::cvtColor(src, dst, code, dstCn); return dst;})
		 cvtColor(src::Mat, code::int, dst::Mat, dstCn::int) -> ( dst::Mat ) 
	 cvtColor
	 .method("jlopencv_cv_cvtColor",  [](UMat &src, int &code, UMat &dst, int &dstCn) { cv::cvtColor(src, dst, code, dstCn); return dst;})
		 cvtColor(src::UMat, code::int, dst::UMat, dstCn::int) -> ( dst::UMat ) 
	 cvtColorTwoPlane
	 .method("jlopencv_cv_cvtColorTwoPlane",  [](Mat &src1, Mat &src2, int &code, Mat &dst) { cv::cvtColorTwoPlane(src1, src2, dst, code); return dst;})
		 cvtColorTwoPlane(src1::Mat, src2::Mat, code::int; dst::Mat) -> ( dst::Mat ) 
	 cvtColorTwoPlane
	 .method("jlopencv_cv_cvtColorTwoPlane",  [](UMat &src1, UMat &src2, int &code, UMat &dst) { cv::cvtColorTwoPlane(src1, src2, dst, code); return dst;})
		 cvtColorTwoPlane(src1::UMat, src2::UMat, code::int; dst::UMat) -> ( dst::UMat ) 
	 demosaicing
	 .method("jlopencv_cv_demosaicing",  [](Mat &src, int &code, Mat &dst, int &dstCn) { cv::demosaicing(src, dst, code, dstCn); return dst;})
		 demosaicing(src::Mat, code::int, dst::Mat, dstCn::int) -> ( dst::Mat ) 
	 demosaicing
	 .method("jlopencv_cv_demosaicing",  [](UMat &src, int &code, UMat &dst, int &dstCn) { cv::demosaicing(src, dst, code, dstCn); return dst;})
		 demosaicing(src::UMat, code::int, dst::UMat, dstCn::int) -> ( dst::UMat ) 
	 moments
	 .method("jlopencv_cv_moments",  [](Mat &array, bool &binaryImage) { auto retval = cv::moments(array, binaryImage); return retval;})
		 moments(array::Mat, binaryImage::bool) -> ( retval::Moments ) 
	 moments
	 .method("jlopencv_cv_moments",  [](UMat &array, bool &binaryImage) { auto retval = cv::moments(array, binaryImage); return retval;})
		 moments(array::UMat, binaryImage::bool) -> ( retval::Moments ) 
	 HuMoments
	 .method("jlopencv_cv_HuMoments",  [](Moments &m, Mat &hu) { cv::HuMoments(m, hu); return hu;})
		 HuMoments(m::Moments; hu::Mat) -> ( hu::Mat ) 
	 HuMoments
	 .method("jlopencv_cv_HuMoments",  [](Moments &m, UMat &hu) { cv::HuMoments(m, hu); return hu;})
		 HuMoments(m::Moments; hu::UMat) -> ( hu::UMat ) 
	 matchTemplate
	 .method("jlopencv_cv_matchTemplate",  [](Mat &image, Mat &templ, int &method, Mat &result, Mat &mask) { cv::matchTemplate(image, templ, result, method, mask); return result;})
		 matchTemplate(image::Mat, templ::Mat, method::int, result::Mat, mask::Mat) -> ( result::Mat ) 
	 matchTemplate
	 .method("jlopencv_cv_matchTemplate",  [](UMat &image, UMat &templ, int &method, UMat &result, UMat &mask) { cv::matchTemplate(image, templ, result, method, mask); return result;})
		 matchTemplate(image::UMat, templ::UMat, method::int, result::UMat, mask::UMat) -> ( result::UMat ) 
	 connectedComponentsWithAlgorithm
	 .method("jlopencv_cv_connectedComponentsWithAlgorithm",  [](Mat &image, int &connectivity, int &ltype, int &ccltype, Mat &labels) { auto retval = cv::connectedComponents(image, labels, connectivity, ltype, ccltype); return make_tuple<int,Mat>(retval,labels);})
		 connectedComponentsWithAlgorithm(image::Mat, connectivity::int, ltype::int, ccltype::int; labels::Mat) -> ( retval::int, labels::Mat ) 
	 connectedComponentsWithAlgorithm
	 .method("jlopencv_cv_connectedComponentsWithAlgorithm",  [](UMat &image, int &connectivity, int &ltype, int &ccltype, UMat &labels) { auto retval = cv::connectedComponents(image, labels, connectivity, ltype, ccltype); return make_tuple<int,UMat>(retval,labels);})
		 connectedComponentsWithAlgorithm(image::UMat, connectivity::int, ltype::int, ccltype::int; labels::UMat) -> ( retval::int, labels::UMat ) 
	 connectedComponents
	 .method("jlopencv_cv_connectedComponents",  [](Mat &image, Mat &labels, int &connectivity, int &ltype) { auto retval = cv::connectedComponents(image, labels, connectivity, ltype); return make_tuple<int,Mat>(retval,labels);})
		 connectedComponents(image::Mat, labels::Mat, connectivity::int, ltype::int) -> ( retval::int, labels::Mat ) 
	 connectedComponents
	 .method("jlopencv_cv_connectedComponents",  [](UMat &image, UMat &labels, int &connectivity, int &ltype) { auto retval = cv::connectedComponents(image, labels, connectivity, ltype); return make_tuple<int,UMat>(retval,labels);})
		 connectedComponents(image::UMat, labels::UMat, connectivity::int, ltype::int) -> ( retval::int, labels::UMat ) 
	 connectedComponentsWithStatsWithAlgorithm
	 .method("jlopencv_cv_connectedComponentsWithStatsWithAlgorithm",  [](Mat &image, int &connectivity, int &ltype, int &ccltype, Mat &labels, Mat &stats, Mat &centroids) { auto retval = cv::connectedComponentsWithStats(image, labels, stats, centroids, connectivity, ltype, ccltype); return make_tuple<int,Mat,Mat,Mat>(retval,labels,stats,centroids);})
		 connectedComponentsWithStatsWithAlgorithm(image::Mat, connectivity::int, ltype::int, ccltype::int; labels::Mat, stats::Mat, centroids::Mat) -> ( retval::int, labels::Mat, stats::Mat, centroids::Mat ) 
	 connectedComponentsWithStatsWithAlgorithm
	 .method("jlopencv_cv_connectedComponentsWithStatsWithAlgorithm",  [](UMat &image, int &connectivity, int &ltype, int &ccltype, UMat &labels, UMat &stats, UMat &centroids) { auto retval = cv::connectedComponentsWithStats(image, labels, stats, centroids, connectivity, ltype, ccltype); return make_tuple<int,UMat,UMat,UMat>(retval,labels,stats,centroids);})
		 connectedComponentsWithStatsWithAlgorithm(image::UMat, connectivity::int, ltype::int, ccltype::int; labels::UMat, stats::UMat, centroids::UMat) -> ( retval::int, labels::UMat, stats::UMat, centroids::UMat ) 
	 connectedComponentsWithStats
	 .method("jlopencv_cv_connectedComponentsWithStats",  [](Mat &image, Mat &labels, Mat &stats, Mat &centroids, int &connectivity, int &ltype) { auto retval = cv::connectedComponentsWithStats(image, labels, stats, centroids, connectivity, ltype); return make_tuple<int,Mat,Mat,Mat>(retval,labels,stats,centroids);})
		 connectedComponentsWithStats(image::Mat, labels::Mat, stats::Mat, centroids::Mat, connectivity::int, ltype::int) -> ( retval::int, labels::Mat, stats::Mat, centroids::Mat ) 
	 connectedComponentsWithStats
	 .method("jlopencv_cv_connectedComponentsWithStats",  [](UMat &image, UMat &labels, UMat &stats, UMat &centroids, int &connectivity, int &ltype) { auto retval = cv::connectedComponentsWithStats(image, labels, stats, centroids, connectivity, ltype); return make_tuple<int,UMat,UMat,UMat>(retval,labels,stats,centroids);})
		 connectedComponentsWithStats(image::UMat, labels::UMat, stats::UMat, centroids::UMat, connectivity::int, ltype::int) -> ( retval::int, labels::UMat, stats::UMat, centroids::UMat ) 
	 findContours
	 .method("jlopencv_cv_findContours",  [](Mat &image, int &mode, int &method, Mat &hierarchy, Point &offset) {vector<Mat> contours; cv::findContours(image, contours, hierarchy, mode, method, offset); return make_tuple<vector<Mat>,Mat>(contours,hierarchy);})
		 findContours(image::Mat, mode::int, method::int, hierarchy::Mat, offset::Point) -> ( contours::vector<Mat>, hierarchy::Mat ) 
	 findContours
	 .method("jlopencv_cv_findContours",  [](UMat &image, int &mode, int &method, UMat &hierarchy, Point &offset) {vector<UMat> contours; cv::findContours(image, contours, hierarchy, mode, method, offset); return make_tuple<vector<UMat>,UMat>(contours,hierarchy);})
		 findContours(image::UMat, mode::int, method::int, hierarchy::UMat, offset::Point) -> ( contours::vector<UMat>, hierarchy::UMat ) 
	 approxPolyDP
	 .method("jlopencv_cv_approxPolyDP",  [](Mat &curve, double &epsilon, bool &closed, Mat &approxCurve) { cv::approxPolyDP(curve, approxCurve, epsilon, closed); return approxCurve;})
		 approxPolyDP(curve::Mat, epsilon::double, closed::bool; approxCurve::Mat) -> ( approxCurve::Mat ) 
	 approxPolyDP
	 .method("jlopencv_cv_approxPolyDP",  [](UMat &curve, double &epsilon, bool &closed, UMat &approxCurve) { cv::approxPolyDP(curve, approxCurve, epsilon, closed); return approxCurve;})
		 approxPolyDP(curve::UMat, epsilon::double, closed::bool; approxCurve::UMat) -> ( approxCurve::UMat ) 
	 arcLength
	 .method("jlopencv_cv_arcLength",  [](Mat &curve, bool &closed) { auto retval = cv::arcLength(curve, closed); return retval;})
		 arcLength(curve::Mat, closed::bool) -> ( retval::double ) 
	 arcLength
	 .method("jlopencv_cv_arcLength",  [](UMat &curve, bool &closed) { auto retval = cv::arcLength(curve, closed); return retval;})
		 arcLength(curve::UMat, closed::bool) -> ( retval::double ) 
	 boundingRect
	 .method("jlopencv_cv_boundingRect",  [](Mat &array) { auto retval = cv::boundingRect(array); return retval;})
		 boundingRect(array::Mat) -> ( retval::Rect ) 
	 boundingRect
	 .method("jlopencv_cv_boundingRect",  [](UMat &array) { auto retval = cv::boundingRect(array); return retval;})
		 boundingRect(array::UMat) -> ( retval::Rect ) 
	 contourArea
	 .method("jlopencv_cv_contourArea",  [](Mat &contour, bool &oriented) { auto retval = cv::contourArea(contour, oriented); return retval;})
		 contourArea(contour::Mat, oriented::bool) -> ( retval::double ) 
	 contourArea
	 .method("jlopencv_cv_contourArea",  [](UMat &contour, bool &oriented) { auto retval = cv::contourArea(contour, oriented); return retval;})
		 contourArea(contour::UMat, oriented::bool) -> ( retval::double ) 
	 minAreaRect
	 .method("jlopencv_cv_minAreaRect",  [](Mat &points) { auto retval = cv::minAreaRect(points); return retval;})
		 minAreaRect(points::Mat) -> ( retval::RotatedRect ) 
	 minAreaRect
	 .method("jlopencv_cv_minAreaRect",  [](UMat &points) { auto retval = cv::minAreaRect(points); return retval;})
		 minAreaRect(points::UMat) -> ( retval::RotatedRect ) 
	 boxPoints
	 .method("jlopencv_cv_boxPoints",  [](RotatedRect &box, Mat &points) { cv::boxPoints(box, points); return points;})
		 boxPoints(box::RotatedRect; points::Mat) -> ( points::Mat ) 
	 boxPoints
	 .method("jlopencv_cv_boxPoints",  [](RotatedRect &box, UMat &points) { cv::boxPoints(box, points); return points;})
		 boxPoints(box::RotatedRect; points::UMat) -> ( points::UMat ) 
	 minEnclosingCircle
	 .method("jlopencv_cv_minEnclosingCircle",  [](Mat &points) {Point2f center;float radius; cv::minEnclosingCircle(points, center, radius); return make_tuple<Point2f,float>(center,radius);})
		 minEnclosingCircle(points::Mat) -> ( center::Point2f, radius::float ) 
	 minEnclosingCircle
	 .method("jlopencv_cv_minEnclosingCircle",  [](UMat &points) {Point2f center;float radius; cv::minEnclosingCircle(points, center, radius); return make_tuple<Point2f,float>(center,radius);})
		 minEnclosingCircle(points::UMat) -> ( center::Point2f, radius::float ) 
	 minEnclosingTriangle
	 .method("jlopencv_cv_minEnclosingTriangle",  [](Mat &points, Mat &triangle) { auto retval = cv::minEnclosingTriangle(points, triangle); return make_tuple<double,Mat>(retval,triangle);})
		 minEnclosingTriangle(points::Mat; triangle::Mat) -> ( retval::double, triangle::Mat ) 
	 minEnclosingTriangle
	 .method("jlopencv_cv_minEnclosingTriangle",  [](UMat &points, UMat &triangle) { auto retval = cv::minEnclosingTriangle(points, triangle); return make_tuple<double,UMat>(retval,triangle);})
		 minEnclosingTriangle(points::UMat; triangle::UMat) -> ( retval::double, triangle::UMat ) 
	 matchShapes
	 .method("jlopencv_cv_matchShapes",  [](Mat &contour1, Mat &contour2, int &method, double &parameter) { auto retval = cv::matchShapes(contour1, contour2, method, parameter); return retval;})
		 matchShapes(contour1::Mat, contour2::Mat, method::int, parameter::double) -> ( retval::double ) 
	 matchShapes
	 .method("jlopencv_cv_matchShapes",  [](UMat &contour1, UMat &contour2, int &method, double &parameter) { auto retval = cv::matchShapes(contour1, contour2, method, parameter); return retval;})
		 matchShapes(contour1::UMat, contour2::UMat, method::int, parameter::double) -> ( retval::double ) 
	 convexHull
	 .method("jlopencv_cv_convexHull",  [](Mat &points, Mat &hull, bool &clockwise, bool &returnPoints) { cv::convexHull(points, hull, clockwise, returnPoints); return hull;})
		 convexHull(points::Mat, hull::Mat, clockwise::bool, returnPoints::bool) -> ( hull::Mat ) 
	 convexHull
	 .method("jlopencv_cv_convexHull",  [](UMat &points, UMat &hull, bool &clockwise, bool &returnPoints) { cv::convexHull(points, hull, clockwise, returnPoints); return hull;})
		 convexHull(points::UMat, hull::UMat, clockwise::bool, returnPoints::bool) -> ( hull::UMat ) 
	 convexityDefects
	 .method("jlopencv_cv_convexityDefects",  [](Mat &contour, Mat &convexhull, Mat &convexityDefects) { cv::convexityDefects(contour, convexhull, convexityDefects); return convexityDefects;})
		 convexityDefects(contour::Mat, convexhull::Mat; convexityDefects::Mat) -> ( convexityDefects::Mat ) 
	 convexityDefects
	 .method("jlopencv_cv_convexityDefects",  [](UMat &contour, UMat &convexhull, UMat &convexityDefects) { cv::convexityDefects(contour, convexhull, convexityDefects); return convexityDefects;})
		 convexityDefects(contour::UMat, convexhull::UMat; convexityDefects::UMat) -> ( convexityDefects::UMat ) 
	 isContourConvex
	 .method("jlopencv_cv_isContourConvex",  [](Mat &contour) { auto retval = cv::isContourConvex(contour); return retval;})
		 isContourConvex(contour::Mat) -> ( retval::bool ) 
	 isContourConvex
	 .method("jlopencv_cv_isContourConvex",  [](UMat &contour) { auto retval = cv::isContourConvex(contour); return retval;})
		 isContourConvex(contour::UMat) -> ( retval::bool ) 
	 intersectConvexConvex
	 .method("jlopencv_cv_intersectConvexConvex",  [](Mat &_p1, Mat &_p2, Mat &_p12, bool &handleNested) { auto retval = cv::intersectConvexConvex(_p1, _p2, _p12, handleNested); return make_tuple<float,Mat>(retval,_p12);})
		 intersectConvexConvex(_p1::Mat, _p2::Mat, _p12::Mat, handleNested::bool) -> ( retval::float, _p12::Mat ) 
	 intersectConvexConvex
	 .method("jlopencv_cv_intersectConvexConvex",  [](UMat &_p1, UMat &_p2, UMat &_p12, bool &handleNested) { auto retval = cv::intersectConvexConvex(_p1, _p2, _p12, handleNested); return make_tuple<float,UMat>(retval,_p12);})
		 intersectConvexConvex(_p1::UMat, _p2::UMat, _p12::UMat, handleNested::bool) -> ( retval::float, _p12::UMat ) 
	 fitEllipse
	 .method("jlopencv_cv_fitEllipse",  [](Mat &points) { auto retval = cv::fitEllipse(points); return retval;})
		 fitEllipse(points::Mat) -> ( retval::RotatedRect ) 
	 fitEllipse
	 .method("jlopencv_cv_fitEllipse",  [](UMat &points) { auto retval = cv::fitEllipse(points); return retval;})
		 fitEllipse(points::UMat) -> ( retval::RotatedRect ) 
	 fitEllipseAMS
	 .method("jlopencv_cv_fitEllipseAMS",  [](Mat &points) { auto retval = cv::fitEllipseAMS(points); return retval;})
		 fitEllipseAMS(points::Mat) -> ( retval::RotatedRect ) 
	 fitEllipseAMS
	 .method("jlopencv_cv_fitEllipseAMS",  [](UMat &points) { auto retval = cv::fitEllipseAMS(points); return retval;})
		 fitEllipseAMS(points::UMat) -> ( retval::RotatedRect ) 
	 fitEllipseDirect
	 .method("jlopencv_cv_fitEllipseDirect",  [](Mat &points) { auto retval = cv::fitEllipseDirect(points); return retval;})
		 fitEllipseDirect(points::Mat) -> ( retval::RotatedRect ) 
	 fitEllipseDirect
	 .method("jlopencv_cv_fitEllipseDirect",  [](UMat &points) { auto retval = cv::fitEllipseDirect(points); return retval;})
		 fitEllipseDirect(points::UMat) -> ( retval::RotatedRect ) 
	 fitLine
	 .method("jlopencv_cv_fitLine",  [](Mat &points, int &distType, double &param, double &reps, double &aeps, Mat &line) { cv::fitLine(points, line, distType, param, reps, aeps); return line;})
		 fitLine(points::Mat, distType::int, param::double, reps::double, aeps::double; line::Mat) -> ( line::Mat ) 
	 fitLine
	 .method("jlopencv_cv_fitLine",  [](UMat &points, int &distType, double &param, double &reps, double &aeps, UMat &line) { cv::fitLine(points, line, distType, param, reps, aeps); return line;})
		 fitLine(points::UMat, distType::int, param::double, reps::double, aeps::double; line::UMat) -> ( line::UMat ) 
	 pointPolygonTest
	 .method("jlopencv_cv_pointPolygonTest",  [](Mat &contour, Point2f &pt, bool &measureDist) { auto retval = cv::pointPolygonTest(contour, pt, measureDist); return retval;})
		 pointPolygonTest(contour::Mat, pt::Point2f, measureDist::bool) -> ( retval::double ) 
	 pointPolygonTest
	 .method("jlopencv_cv_pointPolygonTest",  [](UMat &contour, Point2f &pt, bool &measureDist) { auto retval = cv::pointPolygonTest(contour, pt, measureDist); return retval;})
		 pointPolygonTest(contour::UMat, pt::Point2f, measureDist::bool) -> ( retval::double ) 
	 rotatedRectangleIntersection
	 .method("jlopencv_cv_rotatedRectangleIntersection",  [](RotatedRect &rect1, RotatedRect &rect2, Mat &intersectingRegion) { auto retval = cv::rotatedRectangleIntersection(rect1, rect2, intersectingRegion); return make_tuple<int,Mat>(retval,intersectingRegion);})
		 rotatedRectangleIntersection(rect1::RotatedRect, rect2::RotatedRect; intersectingRegion::Mat) -> ( retval::int, intersectingRegion::Mat ) 
	 rotatedRectangleIntersection
	 .method("jlopencv_cv_rotatedRectangleIntersection",  [](RotatedRect &rect1, RotatedRect &rect2, UMat &intersectingRegion) { auto retval = cv::rotatedRectangleIntersection(rect1, rect2, intersectingRegion); return make_tuple<int,UMat>(retval,intersectingRegion);})
		 rotatedRectangleIntersection(rect1::RotatedRect, rect2::RotatedRect; intersectingRegion::UMat) -> ( retval::int, intersectingRegion::UMat ) 
	 createGeneralizedHoughBallard
	 .method("jlopencv_cv_createGeneralizedHoughBallard",  []() { auto retval = cv::createGeneralizedHoughBallard(); return retval;})
		 createGeneralizedHoughBallard() -> ( retval::Ptr<GeneralizedHoughBallard> ) 
	 createGeneralizedHoughGuil
	 .method("jlopencv_cv_createGeneralizedHoughGuil",  []() { auto retval = cv::createGeneralizedHoughGuil(); return retval;})
		 createGeneralizedHoughGuil() -> ( retval::Ptr<GeneralizedHoughGuil> ) 
	 applyColorMap
	 .method("jlopencv_cv_applyColorMap",  [](Mat &src, int &colormap, Mat &dst) { cv::applyColorMap(src, dst, colormap); return dst;})
		 applyColorMap(src::Mat, colormap::int; dst::Mat) -> ( dst::Mat ) 
	 applyColorMap
	 .method("jlopencv_cv_applyColorMap",  [](UMat &src, int &colormap, UMat &dst) { cv::applyColorMap(src, dst, colormap); return dst;})
		 applyColorMap(src::UMat, colormap::int; dst::UMat) -> ( dst::UMat ) 
	 applyColorMap
	 .method("jlopencv_cv_applyColorMap",  [](Mat &src, Mat &userColor, Mat &dst) { cv::applyColorMap(src, dst, userColor); return dst;})
		 applyColorMap(src::Mat, userColor::Mat; dst::Mat) -> ( dst::Mat ) 
	 applyColorMap
	 .method("jlopencv_cv_applyColorMap",  [](UMat &src, UMat &userColor, UMat &dst) { cv::applyColorMap(src, dst, userColor); return dst;})
		 applyColorMap(src::UMat, userColor::UMat; dst::UMat) -> ( dst::UMat ) 
	 line
	 .method("jlopencv_cv_line",  [](Mat &img, Point &pt1, Point &pt2, Scalar &color, int &thickness, int &lineType, int &shift) { cv::line(img, pt1, pt2, color, thickness, lineType, shift); return img;})
		 line(img::Mat, pt1::Point, pt2::Point, color::Scalar, thickness::int, lineType::int, shift::int) -> ( img::Mat ) 
	 line
	 .method("jlopencv_cv_line",  [](UMat &img, Point &pt1, Point &pt2, Scalar &color, int &thickness, int &lineType, int &shift) { cv::line(img, pt1, pt2, color, thickness, lineType, shift); return img;})
		 line(img::UMat, pt1::Point, pt2::Point, color::Scalar, thickness::int, lineType::int, shift::int) -> ( img::UMat ) 
	 arrowedLine
	 .method("jlopencv_cv_arrowedLine",  [](Mat &img, Point &pt1, Point &pt2, Scalar &color, int &thickness, int &line_type, int &shift, double &tipLength) { cv::arrowedLine(img, pt1, pt2, color, thickness, line_type, shift, tipLength); return img;})
		 arrowedLine(img::Mat, pt1::Point, pt2::Point, color::Scalar, thickness::int, line_type::int, shift::int, tipLength::double) -> ( img::Mat ) 
	 arrowedLine
	 .method("jlopencv_cv_arrowedLine",  [](UMat &img, Point &pt1, Point &pt2, Scalar &color, int &thickness, int &line_type, int &shift, double &tipLength) { cv::arrowedLine(img, pt1, pt2, color, thickness, line_type, shift, tipLength); return img;})
		 arrowedLine(img::UMat, pt1::Point, pt2::Point, color::Scalar, thickness::int, line_type::int, shift::int, tipLength::double) -> ( img::UMat ) 
	 rectangle
	 .method("jlopencv_cv_rectangle",  [](Mat &img, Point &pt1, Point &pt2, Scalar &color, int &thickness, int &lineType, int &shift) { cv::rectangle(img, pt1, pt2, color, thickness, lineType, shift); return img;})
		 rectangle(img::Mat, pt1::Point, pt2::Point, color::Scalar, thickness::int, lineType::int, shift::int) -> ( img::Mat ) 
	 rectangle
	 .method("jlopencv_cv_rectangle",  [](UMat &img, Point &pt1, Point &pt2, Scalar &color, int &thickness, int &lineType, int &shift) { cv::rectangle(img, pt1, pt2, color, thickness, lineType, shift); return img;})
		 rectangle(img::UMat, pt1::Point, pt2::Point, color::Scalar, thickness::int, lineType::int, shift::int) -> ( img::UMat ) 
	 rectangle
	 .method("jlopencv_cv_rectangle",  [](Mat &img, Rect &rec, Scalar &color, int &thickness, int &lineType, int &shift) { cv::rectangle(img, rec, color, thickness, lineType, shift); return img;})
		 rectangle(img::Mat, rec::Rect, color::Scalar, thickness::int, lineType::int, shift::int) -> ( img::Mat ) 
	 rectangle
	 .method("jlopencv_cv_rectangle",  [](UMat &img, Rect &rec, Scalar &color, int &thickness, int &lineType, int &shift) { cv::rectangle(img, rec, color, thickness, lineType, shift); return img;})
		 rectangle(img::UMat, rec::Rect, color::Scalar, thickness::int, lineType::int, shift::int) -> ( img::UMat ) 
	 circle
	 .method("jlopencv_cv_circle",  [](Mat &img, Point &center, int &radius, Scalar &color, int &thickness, int &lineType, int &shift) { cv::circle(img, center, radius, color, thickness, lineType, shift); return img;})
		 circle(img::Mat, center::Point, radius::int, color::Scalar, thickness::int, lineType::int, shift::int) -> ( img::Mat ) 
	 circle
	 .method("jlopencv_cv_circle",  [](UMat &img, Point &center, int &radius, Scalar &color, int &thickness, int &lineType, int &shift) { cv::circle(img, center, radius, color, thickness, lineType, shift); return img;})
		 circle(img::UMat, center::Point, radius::int, color::Scalar, thickness::int, lineType::int, shift::int) -> ( img::UMat ) 
	 ellipse
	 .method("jlopencv_cv_ellipse",  [](Mat &img, Point &center, Size &axes, double &angle, double &startAngle, double &endAngle, Scalar &color, int &thickness, int &lineType, int &shift) { cv::ellipse(img, center, axes, angle, startAngle, endAngle, color, thickness, lineType, shift); return img;})
		 ellipse(img::Mat, center::Point, axes::Size, angle::double, startAngle::double, endAngle::double, color::Scalar, thickness::int, lineType::int, shift::int) -> ( img::Mat ) 
	 ellipse
	 .method("jlopencv_cv_ellipse",  [](UMat &img, Point &center, Size &axes, double &angle, double &startAngle, double &endAngle, Scalar &color, int &thickness, int &lineType, int &shift) { cv::ellipse(img, center, axes, angle, startAngle, endAngle, color, thickness, lineType, shift); return img;})
		 ellipse(img::UMat, center::Point, axes::Size, angle::double, startAngle::double, endAngle::double, color::Scalar, thickness::int, lineType::int, shift::int) -> ( img::UMat ) 
	 ellipse
	 .method("jlopencv_cv_ellipse",  [](Mat &img, RotatedRect &box, Scalar &color, int &thickness, int &lineType) { cv::ellipse(img, box, color, thickness, lineType); return img;})
		 ellipse(img::Mat, box::RotatedRect, color::Scalar, thickness::int, lineType::int) -> ( img::Mat ) 
	 ellipse
	 .method("jlopencv_cv_ellipse",  [](UMat &img, RotatedRect &box, Scalar &color, int &thickness, int &lineType) { cv::ellipse(img, box, color, thickness, lineType); return img;})
		 ellipse(img::UMat, box::RotatedRect, color::Scalar, thickness::int, lineType::int) -> ( img::UMat ) 
	 drawMarker
	 .method("jlopencv_cv_drawMarker",  [](Mat &img, Point &position, Scalar &color, int &markerType, int &markerSize, int &thickness, int &line_type) { cv::drawMarker(img, position, color, markerType, markerSize, thickness, line_type); return img;})
		 drawMarker(img::Mat, position::Point, color::Scalar, markerType::int, markerSize::int, thickness::int, line_type::int) -> ( img::Mat ) 
	 drawMarker
	 .method("jlopencv_cv_drawMarker",  [](UMat &img, Point &position, Scalar &color, int &markerType, int &markerSize, int &thickness, int &line_type) { cv::drawMarker(img, position, color, markerType, markerSize, thickness, line_type); return img;})
		 drawMarker(img::UMat, position::Point, color::Scalar, markerType::int, markerSize::int, thickness::int, line_type::int) -> ( img::UMat ) 
	 fillConvexPoly
	 .method("jlopencv_cv_fillConvexPoly",  [](Mat &img, Mat &points, Scalar &color, int &lineType, int &shift) { cv::fillConvexPoly(img, points, color, lineType, shift); return img;})
		 fillConvexPoly(img::Mat, points::Mat, color::Scalar, lineType::int, shift::int) -> ( img::Mat ) 
	 fillConvexPoly
	 .method("jlopencv_cv_fillConvexPoly",  [](UMat &img, UMat &points, Scalar &color, int &lineType, int &shift) { cv::fillConvexPoly(img, points, color, lineType, shift); return img;})
		 fillConvexPoly(img::UMat, points::UMat, color::Scalar, lineType::int, shift::int) -> ( img::UMat ) 
	 fillPoly
	 .method("jlopencv_cv_fillPoly",  [](Mat &img, vector<Mat> &pts, Scalar &color, int &lineType, int &shift, Point &offset) { cv::fillPoly(img, pts, color, lineType, shift, offset); return img;})
		 fillPoly(img::Mat, pts::vector<Mat>, color::Scalar, lineType::int, shift::int, offset::Point) -> ( img::Mat ) 
	 fillPoly
	 .method("jlopencv_cv_fillPoly",  [](UMat &img, vector<UMat> &pts, Scalar &color, int &lineType, int &shift, Point &offset) { cv::fillPoly(img, pts, color, lineType, shift, offset); return img;})
		 fillPoly(img::UMat, pts::vector<UMat>, color::Scalar, lineType::int, shift::int, offset::Point) -> ( img::UMat ) 
	 polylines
	 .method("jlopencv_cv_polylines",  [](Mat &img, vector<Mat> &pts, bool &isClosed, Scalar &color, int &thickness, int &lineType, int &shift) { cv::polylines(img, pts, isClosed, color, thickness, lineType, shift); return img;})
		 polylines(img::Mat, pts::vector<Mat>, isClosed::bool, color::Scalar, thickness::int, lineType::int, shift::int) -> ( img::Mat ) 
	 polylines
	 .method("jlopencv_cv_polylines",  [](UMat &img, vector<UMat> &pts, bool &isClosed, Scalar &color, int &thickness, int &lineType, int &shift) { cv::polylines(img, pts, isClosed, color, thickness, lineType, shift); return img;})
		 polylines(img::UMat, pts::vector<UMat>, isClosed::bool, color::Scalar, thickness::int, lineType::int, shift::int) -> ( img::UMat ) 
	 drawContours
	 .method("jlopencv_cv_drawContours",  [](Mat &image, vector<Mat> &contours, int &contourIdx, Scalar &color, int &thickness, int &lineType, Mat &hierarchy, int &maxLevel, Point &offset) { cv::drawContours(image, contours, contourIdx, color, thickness, lineType, hierarchy, maxLevel, offset); return image;})
		 drawContours(image::Mat, contours::vector<Mat>, contourIdx::int, color::Scalar, thickness::int, lineType::int, hierarchy::Mat, maxLevel::int, offset::Point) -> ( image::Mat ) 
	 drawContours
	 .method("jlopencv_cv_drawContours",  [](UMat &image, vector<UMat> &contours, int &contourIdx, Scalar &color, int &thickness, int &lineType, UMat &hierarchy, int &maxLevel, Point &offset) { cv::drawContours(image, contours, contourIdx, color, thickness, lineType, hierarchy, maxLevel, offset); return image;})
		 drawContours(image::UMat, contours::vector<UMat>, contourIdx::int, color::Scalar, thickness::int, lineType::int, hierarchy::UMat, maxLevel::int, offset::Point) -> ( image::UMat ) 
	 clipLine
	 .method("jlopencv_cv_clipLine",  [](Rect &imgRect, Point &pt1, Point &pt2) { auto retval = cv::clipLine(imgRect, pt1, pt2); return make_tuple<bool,Point,Point>(retval,pt1,pt2);})
		 clipLine(imgRect::Rect, pt1::Point, pt2::Point) -> ( retval::bool, pt1::Point, pt2::Point ) 
	 ellipse2Poly
	 .method("jlopencv_cv_ellipse2Poly",  [](Point &center, Size &axes, int &angle, int &arcStart, int &arcEnd, int &delta) {vector<Point> pts; cv::ellipse2Poly(center, axes, angle, arcStart, arcEnd, delta, pts); return pts;})
		 ellipse2Poly(center::Point, axes::Size, angle::int, arcStart::int, arcEnd::int, delta::int) -> ( pts::vector<Point> ) 
	 putText
	 .method("jlopencv_cv_putText",  [](Mat &img, String &text, Point &org, int &fontFace, double &fontScale, Scalar &color, int &thickness, int &lineType, bool &bottomLeftOrigin) { cv::putText(img, text, org, fontFace, fontScale, color, thickness, lineType, bottomLeftOrigin); return img;})
		 putText(img::Mat, text::String, org::Point, fontFace::int, fontScale::double, color::Scalar, thickness::int, lineType::int, bottomLeftOrigin::bool) -> ( img::Mat ) 
	 putText
	 .method("jlopencv_cv_putText",  [](UMat &img, String &text, Point &org, int &fontFace, double &fontScale, Scalar &color, int &thickness, int &lineType, bool &bottomLeftOrigin) { cv::putText(img, text, org, fontFace, fontScale, color, thickness, lineType, bottomLeftOrigin); return img;})
		 putText(img::UMat, text::String, org::Point, fontFace::int, fontScale::double, color::Scalar, thickness::int, lineType::int, bottomLeftOrigin::bool) -> ( img::UMat ) 
	 getTextSize
	 .method("jlopencv_cv_getTextSize",  [](String &text, int &fontFace, double &fontScale, int &thickness) {int baseLine; auto retval = cv::getTextSize(text, fontFace, fontScale, thickness, baseLine); return make_tuple<Size,int>(retval,baseLine);})
		 getTextSize(text::String, fontFace::int, fontScale::double, thickness::int) -> ( retval::Size, baseLine::int* ) 
	 getFontScaleFromHeight
	 .method("jlopencv_cv_getFontScaleFromHeight",  [](int &fontFace, int &pixelHeight, int &thickness) { auto retval = cv::getFontScaleFromHeight(fontFace, pixelHeight, thickness); return retval;})
		 getFontScaleFromHeight(fontFace::int, pixelHeight::int, thickness::int) -> ( retval::double ) 
	 Rodrigues
	 .method("jlopencv_cv_Rodrigues",  [](Mat &src, Mat &dst, Mat &jacobian) { cv::Rodrigues(src, dst, jacobian); return make_tuple<Mat,Mat>(dst,jacobian);})
		 Rodrigues(src::Mat; dst::Mat, jacobian::Mat) -> ( dst::Mat, jacobian::Mat ) 
	 Rodrigues
	 .method("jlopencv_cv_Rodrigues",  [](UMat &src, UMat &dst, UMat &jacobian) { cv::Rodrigues(src, dst, jacobian); return make_tuple<UMat,UMat>(dst,jacobian);})
		 Rodrigues(src::UMat; dst::UMat, jacobian::UMat) -> ( dst::UMat, jacobian::UMat ) 
	 findHomography
	 .method("jlopencv_cv_findHomography",  [](Mat &srcPoints, Mat &dstPoints, int &method, double &ransacReprojThreshold, Mat &mask, int &maxIters, double &confidence) { auto retval = cv::findHomography(srcPoints, dstPoints, method, ransacReprojThreshold, mask, maxIters, confidence); return make_tuple<Mat,Mat>(retval,mask);})
		 findHomography(srcPoints::Mat, dstPoints::Mat, method::int, ransacReprojThreshold::double, mask::Mat, maxIters::int, confidence::double) -> ( retval::Mat, mask::Mat ) 
	 findHomography
	 .method("jlopencv_cv_findHomography",  [](UMat &srcPoints, UMat &dstPoints, int &method, double &ransacReprojThreshold, UMat &mask, int &maxIters, double &confidence) { auto retval = cv::findHomography(srcPoints, dstPoints, method, ransacReprojThreshold, mask, maxIters, confidence); return make_tuple<Mat,UMat>(retval,mask);})
		 findHomography(srcPoints::UMat, dstPoints::UMat, method::int, ransacReprojThreshold::double, mask::UMat, maxIters::int, confidence::double) -> ( retval::Mat, mask::UMat ) 
	 RQDecomp3x3
	 .method("jlopencv_cv_RQDecomp3x3",  [](Mat &src, Mat &mtxR, Mat &mtxQ, Mat &Qx, Mat &Qy, Mat &Qz) { auto retval = cv::RQDecomp3x3(src, mtxR, mtxQ, Qx, Qy, Qz); return make_tuple<Vec3d,Mat,Mat,Mat,Mat,Mat>(retval,mtxR,mtxQ,Qx,Qy,Qz);})
		 RQDecomp3x3(src::Mat; mtxR::Mat, mtxQ::Mat, Qx::Mat, Qy::Mat, Qz::Mat) -> ( retval::Vec3d, mtxR::Mat, mtxQ::Mat, Qx::Mat, Qy::Mat, Qz::Mat ) 
	 RQDecomp3x3
	 .method("jlopencv_cv_RQDecomp3x3",  [](UMat &src, UMat &mtxR, UMat &mtxQ, UMat &Qx, UMat &Qy, UMat &Qz) { auto retval = cv::RQDecomp3x3(src, mtxR, mtxQ, Qx, Qy, Qz); return make_tuple<Vec3d,UMat,UMat,UMat,UMat,UMat>(retval,mtxR,mtxQ,Qx,Qy,Qz);})
		 RQDecomp3x3(src::UMat; mtxR::UMat, mtxQ::UMat, Qx::UMat, Qy::UMat, Qz::UMat) -> ( retval::Vec3d, mtxR::UMat, mtxQ::UMat, Qx::UMat, Qy::UMat, Qz::UMat ) 
	 decomposeProjectionMatrix
	 .method("jlopencv_cv_decomposeProjectionMatrix",  [](Mat &projMatrix, Mat &cameraMatrix, Mat &rotMatrix, Mat &transVect, Mat &rotMatrixX, Mat &rotMatrixY, Mat &rotMatrixZ, Mat &eulerAngles) { cv::decomposeProjectionMatrix(projMatrix, cameraMatrix, rotMatrix, transVect, rotMatrixX, rotMatrixY, rotMatrixZ, eulerAngles); return make_tuple<Mat,Mat,Mat,Mat,Mat,Mat,Mat>(cameraMatrix,rotMatrix,transVect,rotMatrixX,rotMatrixY,rotMatrixZ,eulerAngles);})
		 decomposeProjectionMatrix(projMatrix::Mat; cameraMatrix::Mat, rotMatrix::Mat, transVect::Mat, rotMatrixX::Mat, rotMatrixY::Mat, rotMatrixZ::Mat, eulerAngles::Mat) -> ( cameraMatrix::Mat, rotMatrix::Mat, transVect::Mat, rotMatrixX::Mat, rotMatrixY::Mat, rotMatrixZ::Mat, eulerAngles::Mat ) 
	 decomposeProjectionMatrix
	 .method("jlopencv_cv_decomposeProjectionMatrix",  [](UMat &projMatrix, UMat &cameraMatrix, UMat &rotMatrix, UMat &transVect, UMat &rotMatrixX, UMat &rotMatrixY, UMat &rotMatrixZ, UMat &eulerAngles) { cv::decomposeProjectionMatrix(projMatrix, cameraMatrix, rotMatrix, transVect, rotMatrixX, rotMatrixY, rotMatrixZ, eulerAngles); return make_tuple<UMat,UMat,UMat,UMat,UMat,UMat,UMat>(cameraMatrix,rotMatrix,transVect,rotMatrixX,rotMatrixY,rotMatrixZ,eulerAngles);})
		 decomposeProjectionMatrix(projMatrix::UMat; cameraMatrix::UMat, rotMatrix::UMat, transVect::UMat, rotMatrixX::UMat, rotMatrixY::UMat, rotMatrixZ::UMat, eulerAngles::UMat) -> ( cameraMatrix::UMat, rotMatrix::UMat, transVect::UMat, rotMatrixX::UMat, rotMatrixY::UMat, rotMatrixZ::UMat, eulerAngles::UMat ) 
	 matMulDeriv
	 .method("jlopencv_cv_matMulDeriv",  [](Mat &A, Mat &B, Mat &dABdA, Mat &dABdB) { cv::matMulDeriv(A, B, dABdA, dABdB); return make_tuple<Mat,Mat>(dABdA,dABdB);})
		 matMulDeriv(A::Mat, B::Mat; dABdA::Mat, dABdB::Mat) -> ( dABdA::Mat, dABdB::Mat ) 
	 matMulDeriv
	 .method("jlopencv_cv_matMulDeriv",  [](UMat &A, UMat &B, UMat &dABdA, UMat &dABdB) { cv::matMulDeriv(A, B, dABdA, dABdB); return make_tuple<UMat,UMat>(dABdA,dABdB);})
		 matMulDeriv(A::UMat, B::UMat; dABdA::UMat, dABdB::UMat) -> ( dABdA::UMat, dABdB::UMat ) 
	 composeRT
	 .method("jlopencv_cv_composeRT",  [](Mat &rvec1, Mat &tvec1, Mat &rvec2, Mat &tvec2, Mat &rvec3, Mat &tvec3, Mat &dr3dr1, Mat &dr3dt1, Mat &dr3dr2, Mat &dr3dt2, Mat &dt3dr1, Mat &dt3dt1, Mat &dt3dr2, Mat &dt3dt2) { cv::composeRT(rvec1, tvec1, rvec2, tvec2, rvec3, tvec3, dr3dr1, dr3dt1, dr3dr2, dr3dt2, dt3dr1, dt3dt1, dt3dr2, dt3dt2); return make_tuple<Mat,Mat,Mat,Mat,Mat,Mat,Mat,Mat,Mat,Mat>(rvec3,tvec3,dr3dr1,dr3dt1,dr3dr2,dr3dt2,dt3dr1,dt3dt1,dt3dr2,dt3dt2);})
		 composeRT(rvec1::Mat, tvec1::Mat, rvec2::Mat, tvec2::Mat; rvec3::Mat, tvec3::Mat, dr3dr1::Mat, dr3dt1::Mat, dr3dr2::Mat, dr3dt2::Mat, dt3dr1::Mat, dt3dt1::Mat, dt3dr2::Mat, dt3dt2::Mat) -> ( rvec3::Mat, tvec3::Mat, dr3dr1::Mat, dr3dt1::Mat, dr3dr2::Mat, dr3dt2::Mat, dt3dr1::Mat, dt3dt1::Mat, dt3dr2::Mat, dt3dt2::Mat ) 
	 composeRT
	 .method("jlopencv_cv_composeRT",  [](UMat &rvec1, UMat &tvec1, UMat &rvec2, UMat &tvec2, UMat &rvec3, UMat &tvec3, UMat &dr3dr1, UMat &dr3dt1, UMat &dr3dr2, UMat &dr3dt2, UMat &dt3dr1, UMat &dt3dt1, UMat &dt3dr2, UMat &dt3dt2) { cv::composeRT(rvec1, tvec1, rvec2, tvec2, rvec3, tvec3, dr3dr1, dr3dt1, dr3dr2, dr3dt2, dt3dr1, dt3dt1, dt3dr2, dt3dt2); return make_tuple<UMat,UMat,UMat,UMat,UMat,UMat,UMat,UMat,UMat,UMat>(rvec3,tvec3,dr3dr1,dr3dt1,dr3dr2,dr3dt2,dt3dr1,dt3dt1,dt3dr2,dt3dt2);})
		 composeRT(rvec1::UMat, tvec1::UMat, rvec2::UMat, tvec2::UMat; rvec3::UMat, tvec3::UMat, dr3dr1::UMat, dr3dt1::UMat, dr3dr2::UMat, dr3dt2::UMat, dt3dr1::UMat, dt3dt1::UMat, dt3dr2::UMat, dt3dt2::UMat) -> ( rvec3::UMat, tvec3::UMat, dr3dr1::UMat, dr3dt1::UMat, dr3dr2::UMat, dr3dt2::UMat, dt3dr1::UMat, dt3dt1::UMat, dt3dr2::UMat, dt3dt2::UMat ) 
	 projectPoints
	 .method("jlopencv_cv_projectPoints",  [](Mat &objectPoints, Mat &rvec, Mat &tvec, Mat &cameraMatrix, Mat &distCoeffs, Mat &imagePoints, Mat &jacobian, double &aspectRatio) { cv::projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs, imagePoints, jacobian, aspectRatio); return make_tuple<Mat,Mat>(imagePoints,jacobian);})
		 projectPoints(objectPoints::Mat, rvec::Mat, tvec::Mat, cameraMatrix::Mat, distCoeffs::Mat, imagePoints::Mat, jacobian::Mat, aspectRatio::double) -> ( imagePoints::Mat, jacobian::Mat ) 
	 projectPoints
	 .method("jlopencv_cv_projectPoints",  [](UMat &objectPoints, UMat &rvec, UMat &tvec, UMat &cameraMatrix, UMat &distCoeffs, UMat &imagePoints, UMat &jacobian, double &aspectRatio) { cv::projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs, imagePoints, jacobian, aspectRatio); return make_tuple<UMat,UMat>(imagePoints,jacobian);})
		 projectPoints(objectPoints::UMat, rvec::UMat, tvec::UMat, cameraMatrix::UMat, distCoeffs::UMat, imagePoints::UMat, jacobian::UMat, aspectRatio::double) -> ( imagePoints::UMat, jacobian::UMat ) 
	 solvePnP
	 .method("jlopencv_cv_solvePnP",  [](Mat &objectPoints, Mat &imagePoints, Mat &cameraMatrix, Mat &distCoeffs, Mat &rvec, Mat &tvec, bool &useExtrinsicGuess, int &flags) { auto retval = cv::solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess, flags); return make_tuple<bool,Mat,Mat>(retval,rvec,tvec);})
		 solvePnP(objectPoints::Mat, imagePoints::Mat, cameraMatrix::Mat, distCoeffs::Mat, rvec::Mat, tvec::Mat, useExtrinsicGuess::bool, flags::int) -> ( retval::bool, rvec::Mat, tvec::Mat ) 
	 solvePnP
	 .method("jlopencv_cv_solvePnP",  [](UMat &objectPoints, UMat &imagePoints, UMat &cameraMatrix, UMat &distCoeffs, UMat &rvec, UMat &tvec, bool &useExtrinsicGuess, int &flags) { auto retval = cv::solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess, flags); return make_tuple<bool,UMat,UMat>(retval,rvec,tvec);})
		 solvePnP(objectPoints::UMat, imagePoints::UMat, cameraMatrix::UMat, distCoeffs::UMat, rvec::UMat, tvec::UMat, useExtrinsicGuess::bool, flags::int) -> ( retval::bool, rvec::UMat, tvec::UMat ) 
	 solvePnPRansac
	 .method("jlopencv_cv_solvePnPRansac",  [](Mat &objectPoints, Mat &imagePoints, Mat &cameraMatrix, Mat &distCoeffs, Mat &rvec, Mat &tvec, bool &useExtrinsicGuess, int &iterationsCount, float &reprojectionError, double &confidence, Mat &inliers, int &flags) { auto retval = cv::solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess, iterationsCount, reprojectionError, confidence, inliers, flags); return make_tuple<bool,Mat,Mat,Mat>(retval,rvec,tvec,inliers);})
		 solvePnPRansac(objectPoints::Mat, imagePoints::Mat, cameraMatrix::Mat, distCoeffs::Mat, rvec::Mat, tvec::Mat, useExtrinsicGuess::bool, iterationsCount::int, reprojectionError::float, confidence::double, inliers::Mat, flags::int) -> ( retval::bool, rvec::Mat, tvec::Mat, inliers::Mat ) 
	 solvePnPRansac
	 .method("jlopencv_cv_solvePnPRansac",  [](UMat &objectPoints, UMat &imagePoints, UMat &cameraMatrix, UMat &distCoeffs, UMat &rvec, UMat &tvec, bool &useExtrinsicGuess, int &iterationsCount, float &reprojectionError, double &confidence, UMat &inliers, int &flags) { auto retval = cv::solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess, iterationsCount, reprojectionError, confidence, inliers, flags); return make_tuple<bool,UMat,UMat,UMat>(retval,rvec,tvec,inliers);})
		 solvePnPRansac(objectPoints::UMat, imagePoints::UMat, cameraMatrix::UMat, distCoeffs::UMat, rvec::UMat, tvec::UMat, useExtrinsicGuess::bool, iterationsCount::int, reprojectionError::float, confidence::double, inliers::UMat, flags::int) -> ( retval::bool, rvec::UMat, tvec::UMat, inliers::UMat ) 
	 solveP3P
	 .method("jlopencv_cv_solveP3P",  [](Mat &objectPoints, Mat &imagePoints, Mat &cameraMatrix, Mat &distCoeffs, int &flags) {vector<Mat> rvecs;vector<Mat> tvecs; auto retval = cv::solveP3P(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvecs, tvecs, flags); return make_tuple<int,vector<Mat>,vector<Mat>>(retval,rvecs,tvecs);})
		 solveP3P(objectPoints::Mat, imagePoints::Mat, cameraMatrix::Mat, distCoeffs::Mat, flags::int) -> ( retval::int, rvecs::vector<Mat>, tvecs::vector<Mat> ) 
	 solveP3P
	 .method("jlopencv_cv_solveP3P",  [](UMat &objectPoints, UMat &imagePoints, UMat &cameraMatrix, UMat &distCoeffs, int &flags) {vector<UMat> rvecs;vector<UMat> tvecs; auto retval = cv::solveP3P(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvecs, tvecs, flags); return make_tuple<int,vector<UMat>,vector<UMat>>(retval,rvecs,tvecs);})
		 solveP3P(objectPoints::UMat, imagePoints::UMat, cameraMatrix::UMat, distCoeffs::UMat, flags::int) -> ( retval::int, rvecs::vector<UMat>, tvecs::vector<UMat> ) 
	 solvePnPRefineLM
	 .method("jlopencv_cv_solvePnPRefineLM",  [](Mat &objectPoints, Mat &imagePoints, Mat &cameraMatrix, Mat &distCoeffs, Mat &rvec, Mat &tvec, TermCriteria &criteria) { cv::solvePnPRefineLM(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, criteria); return make_tuple<Mat,Mat>(rvec,tvec);})
		 solvePnPRefineLM(objectPoints::Mat, imagePoints::Mat, cameraMatrix::Mat, distCoeffs::Mat, rvec::Mat, tvec::Mat, criteria::TermCriteria) -> ( rvec::Mat, tvec::Mat ) 
	 solvePnPRefineLM
	 .method("jlopencv_cv_solvePnPRefineLM",  [](UMat &objectPoints, UMat &imagePoints, UMat &cameraMatrix, UMat &distCoeffs, UMat &rvec, UMat &tvec, TermCriteria &criteria) { cv::solvePnPRefineLM(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, criteria); return make_tuple<UMat,UMat>(rvec,tvec);})
		 solvePnPRefineLM(objectPoints::UMat, imagePoints::UMat, cameraMatrix::UMat, distCoeffs::UMat, rvec::UMat, tvec::UMat, criteria::TermCriteria) -> ( rvec::UMat, tvec::UMat ) 
	 solvePnPRefineVVS
	 .method("jlopencv_cv_solvePnPRefineVVS",  [](Mat &objectPoints, Mat &imagePoints, Mat &cameraMatrix, Mat &distCoeffs, Mat &rvec, Mat &tvec, TermCriteria &criteria, double &VVSlambda) { cv::solvePnPRefineVVS(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, criteria, VVSlambda); return make_tuple<Mat,Mat>(rvec,tvec);})
		 solvePnPRefineVVS(objectPoints::Mat, imagePoints::Mat, cameraMatrix::Mat, distCoeffs::Mat, rvec::Mat, tvec::Mat, criteria::TermCriteria, VVSlambda::double) -> ( rvec::Mat, tvec::Mat ) 
	 solvePnPRefineVVS
	 .method("jlopencv_cv_solvePnPRefineVVS",  [](UMat &objectPoints, UMat &imagePoints, UMat &cameraMatrix, UMat &distCoeffs, UMat &rvec, UMat &tvec, TermCriteria &criteria, double &VVSlambda) { cv::solvePnPRefineVVS(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, criteria, VVSlambda); return make_tuple<UMat,UMat>(rvec,tvec);})
		 solvePnPRefineVVS(objectPoints::UMat, imagePoints::UMat, cameraMatrix::UMat, distCoeffs::UMat, rvec::UMat, tvec::UMat, criteria::TermCriteria, VVSlambda::double) -> ( rvec::UMat, tvec::UMat ) 
	 solvePnPGeneric
	 .method("jlopencv_cv_solvePnPGeneric",  [](Mat &objectPoints, Mat &imagePoints, Mat &cameraMatrix, Mat &distCoeffs, bool &useExtrinsicGuess, SolvePnPMethod &flags, Mat &rvec, Mat &tvec, Mat &reprojectionError) {vector<Mat> rvecs;vector<Mat> tvecs; auto retval = cv::solvePnPGeneric(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvecs, tvecs, useExtrinsicGuess, flags, rvec, tvec, reprojectionError); return make_tuple<int,vector<Mat>,vector<Mat>,Mat>(retval,rvecs,tvecs,reprojectionError);})
		 solvePnPGeneric(objectPoints::Mat, imagePoints::Mat, cameraMatrix::Mat, distCoeffs::Mat, useExtrinsicGuess::bool, flags::SolvePnPMethod, rvec::Mat, tvec::Mat; reprojectionError::Mat) -> ( retval::int, rvecs::vector<Mat>, tvecs::vector<Mat>, reprojectionError::Mat ) 
	 solvePnPGeneric
	 .method("jlopencv_cv_solvePnPGeneric",  [](UMat &objectPoints, UMat &imagePoints, UMat &cameraMatrix, UMat &distCoeffs, bool &useExtrinsicGuess, SolvePnPMethod &flags, UMat &rvec, UMat &tvec, UMat &reprojectionError) {vector<UMat> rvecs;vector<UMat> tvecs; auto retval = cv::solvePnPGeneric(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvecs, tvecs, useExtrinsicGuess, flags, rvec, tvec, reprojectionError); return make_tuple<int,vector<UMat>,vector<UMat>,UMat>(retval,rvecs,tvecs,reprojectionError);})
		 solvePnPGeneric(objectPoints::UMat, imagePoints::UMat, cameraMatrix::UMat, distCoeffs::UMat, useExtrinsicGuess::bool, flags::SolvePnPMethod, rvec::UMat, tvec::UMat; reprojectionError::UMat) -> ( retval::int, rvecs::vector<UMat>, tvecs::vector<UMat>, reprojectionError::UMat ) 
	 initCameraMatrix2D
	 .method("jlopencv_cv_initCameraMatrix2D",  [](vector<Mat> &objectPoints, vector<Mat> &imagePoints, Size &imageSize, double &aspectRatio) { auto retval = cv::initCameraMatrix2D(objectPoints, imagePoints, imageSize, aspectRatio); return retval;})
		 initCameraMatrix2D(objectPoints::vector<Mat>, imagePoints::vector<Mat>, imageSize::Size, aspectRatio::double) -> ( retval::Mat ) 
	 initCameraMatrix2D
	 .method("jlopencv_cv_initCameraMatrix2D",  [](vector<UMat> &objectPoints, vector<UMat> &imagePoints, Size &imageSize, double &aspectRatio) { auto retval = cv::initCameraMatrix2D(objectPoints, imagePoints, imageSize, aspectRatio); return retval;})
		 initCameraMatrix2D(objectPoints::vector<UMat>, imagePoints::vector<UMat>, imageSize::Size, aspectRatio::double) -> ( retval::Mat ) 
	 findChessboardCorners
	 .method("jlopencv_cv_findChessboardCorners",  [](Mat &image, Size &patternSize, Mat &corners, int &flags) { auto retval = cv::findChessboardCorners(image, patternSize, corners, flags); return make_tuple<bool,Mat>(retval,corners);})
		 findChessboardCorners(image::Mat, patternSize::Size, corners::Mat, flags::int) -> ( retval::bool, corners::Mat ) 
	 findChessboardCorners
	 .method("jlopencv_cv_findChessboardCorners",  [](UMat &image, Size &patternSize, UMat &corners, int &flags) { auto retval = cv::findChessboardCorners(image, patternSize, corners, flags); return make_tuple<bool,UMat>(retval,corners);})
		 findChessboardCorners(image::UMat, patternSize::Size, corners::UMat, flags::int) -> ( retval::bool, corners::UMat ) 
	 checkChessboard
	 .method("jlopencv_cv_checkChessboard",  [](Mat &img, Size &size) { auto retval = cv::checkChessboard(img, size); return retval;})
		 checkChessboard(img::Mat, size::Size) -> ( retval::bool ) 
	 checkChessboard
	 .method("jlopencv_cv_checkChessboard",  [](UMat &img, Size &size) { auto retval = cv::checkChessboard(img, size); return retval;})
		 checkChessboard(img::UMat, size::Size) -> ( retval::bool ) 
	 findChessboardCornersSB
	 .method("jlopencv_cv_findChessboardCornersSB",  [](Mat &image, Size &patternSize, Mat &corners, int &flags) { auto retval = cv::findChessboardCornersSB(image, patternSize, corners, flags); return make_tuple<bool,Mat>(retval,corners);})
		 findChessboardCornersSB(image::Mat, patternSize::Size, corners::Mat, flags::int) -> ( retval::bool, corners::Mat ) 
	 findChessboardCornersSB
	 .method("jlopencv_cv_findChessboardCornersSB",  [](UMat &image, Size &patternSize, UMat &corners, int &flags) { auto retval = cv::findChessboardCornersSB(image, patternSize, corners, flags); return make_tuple<bool,UMat>(retval,corners);})
		 findChessboardCornersSB(image::UMat, patternSize::Size, corners::UMat, flags::int) -> ( retval::bool, corners::UMat ) 
	 find4QuadCornerSubpix
	 .method("jlopencv_cv_find4QuadCornerSubpix",  [](Mat &img, Mat &corners, Size &region_size) { auto retval = cv::find4QuadCornerSubpix(img, corners, region_size); return make_tuple<bool,Mat>(retval,corners);})
		 find4QuadCornerSubpix(img::Mat, corners::Mat, region_size::Size) -> ( retval::bool, corners::Mat ) 
	 find4QuadCornerSubpix
	 .method("jlopencv_cv_find4QuadCornerSubpix",  [](UMat &img, UMat &corners, Size &region_size) { auto retval = cv::find4QuadCornerSubpix(img, corners, region_size); return make_tuple<bool,UMat>(retval,corners);})
		 find4QuadCornerSubpix(img::UMat, corners::UMat, region_size::Size) -> ( retval::bool, corners::UMat ) 
	 drawChessboardCorners
	 .method("jlopencv_cv_drawChessboardCorners",  [](Mat &image, Size &patternSize, Mat &corners, bool &patternWasFound) { cv::drawChessboardCorners(image, patternSize, corners, patternWasFound); return image;})
		 drawChessboardCorners(image::Mat, patternSize::Size, corners::Mat, patternWasFound::bool) -> ( image::Mat ) 
	 drawChessboardCorners
	 .method("jlopencv_cv_drawChessboardCorners",  [](UMat &image, Size &patternSize, UMat &corners, bool &patternWasFound) { cv::drawChessboardCorners(image, patternSize, corners, patternWasFound); return image;})
		 drawChessboardCorners(image::UMat, patternSize::Size, corners::UMat, patternWasFound::bool) -> ( image::UMat ) 
	 drawFrameAxes
	 .method("jlopencv_cv_drawFrameAxes",  [](Mat &image, Mat &cameraMatrix, Mat &distCoeffs, Mat &rvec, Mat &tvec, float &length, int &thickness) { cv::drawFrameAxes(image, cameraMatrix, distCoeffs, rvec, tvec, length, thickness); return image;})
		 drawFrameAxes(image::Mat, cameraMatrix::Mat, distCoeffs::Mat, rvec::Mat, tvec::Mat, length::float, thickness::int) -> ( image::Mat ) 
	 drawFrameAxes
	 .method("jlopencv_cv_drawFrameAxes",  [](UMat &image, UMat &cameraMatrix, UMat &distCoeffs, UMat &rvec, UMat &tvec, float &length, int &thickness) { cv::drawFrameAxes(image, cameraMatrix, distCoeffs, rvec, tvec, length, thickness); return image;})
		 drawFrameAxes(image::UMat, cameraMatrix::UMat, distCoeffs::UMat, rvec::UMat, tvec::UMat, length::float, thickness::int) -> ( image::UMat ) 
	 findCirclesGrid
	 .method("jlopencv_cv_findCirclesGrid",  [](Mat &image, Size &patternSize, int &flags, Ptr<FeatureDetector> &blobDetector, CirclesGridFinderParameters &parameters, Mat &centers) { auto retval = cv::findCirclesGrid(image, patternSize, centers, flags, blobDetector, parameters); return make_tuple<bool,Mat>(retval,centers);})
		 findCirclesGrid(image::Mat, patternSize::Size, flags::int, blobDetector::Ptr<FeatureDetector>, parameters::CirclesGridFinderParameters; centers::Mat) -> ( retval::bool, centers::Mat ) 
	 findCirclesGrid
	 .method("jlopencv_cv_findCirclesGrid",  [](UMat &image, Size &patternSize, int &flags, Ptr<FeatureDetector> &blobDetector, CirclesGridFinderParameters &parameters, UMat &centers) { auto retval = cv::findCirclesGrid(image, patternSize, centers, flags, blobDetector, parameters); return make_tuple<bool,UMat>(retval,centers);})
		 findCirclesGrid(image::UMat, patternSize::Size, flags::int, blobDetector::Ptr<FeatureDetector>, parameters::CirclesGridFinderParameters; centers::UMat) -> ( retval::bool, centers::UMat ) 
	 findCirclesGrid
	 .method("jlopencv_cv_findCirclesGrid",  [](Mat &image, Size &patternSize, Mat &centers, int &flags, Ptr<FeatureDetector> &blobDetector) { auto retval = cv::findCirclesGrid(image, patternSize, centers, flags, blobDetector); return make_tuple<bool,Mat>(retval,centers);})
		 findCirclesGrid(image::Mat, patternSize::Size, centers::Mat, flags::int, blobDetector::Ptr<FeatureDetector>) -> ( retval::bool, centers::Mat ) 
	 findCirclesGrid
	 .method("jlopencv_cv_findCirclesGrid",  [](UMat &image, Size &patternSize, UMat &centers, int &flags, Ptr<FeatureDetector> &blobDetector) { auto retval = cv::findCirclesGrid(image, patternSize, centers, flags, blobDetector); return make_tuple<bool,UMat>(retval,centers);})
		 findCirclesGrid(image::UMat, patternSize::Size, centers::UMat, flags::int, blobDetector::Ptr<FeatureDetector>) -> ( retval::bool, centers::UMat ) 
	 calibrateCameraExtended
	 .method("jlopencv_cv_calibrateCameraExtended",  [](vector<Mat> &objectPoints, vector<Mat> &imagePoints, Size &imageSize, Mat &cameraMatrix, Mat &distCoeffs, Mat &stdDeviationsIntrinsics, Mat &stdDeviationsExtrinsics, Mat &perViewErrors, int &flags, TermCriteria &criteria) {vector<Mat> rvecs;vector<Mat> tvecs; auto retval = cv::calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors, flags, criteria); return make_tuple<double,Mat,Mat,vector<Mat>,vector<Mat>,Mat,Mat,Mat>(retval,cameraMatrix,distCoeffs,rvecs,tvecs,stdDeviationsIntrinsics,stdDeviationsExtrinsics,perViewErrors);})
		 calibrateCameraExtended(objectPoints::vector<Mat>, imagePoints::vector<Mat>, imageSize::Size, cameraMatrix::Mat, distCoeffs::Mat, stdDeviationsIntrinsics::Mat, stdDeviationsExtrinsics::Mat, perViewErrors::Mat, flags::int, criteria::TermCriteria) -> ( retval::double, cameraMatrix::Mat, distCoeffs::Mat, rvecs::vector<Mat>, tvecs::vector<Mat>, stdDeviationsIntrinsics::Mat, stdDeviationsExtrinsics::Mat, perViewErrors::Mat ) 
	 calibrateCameraExtended
	 .method("jlopencv_cv_calibrateCameraExtended",  [](vector<UMat> &objectPoints, vector<UMat> &imagePoints, Size &imageSize, UMat &cameraMatrix, UMat &distCoeffs, UMat &stdDeviationsIntrinsics, UMat &stdDeviationsExtrinsics, UMat &perViewErrors, int &flags, TermCriteria &criteria) {vector<UMat> rvecs;vector<UMat> tvecs; auto retval = cv::calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors, flags, criteria); return make_tuple<double,UMat,UMat,vector<UMat>,vector<UMat>,UMat,UMat,UMat>(retval,cameraMatrix,distCoeffs,rvecs,tvecs,stdDeviationsIntrinsics,stdDeviationsExtrinsics,perViewErrors);})
		 calibrateCameraExtended(objectPoints::vector<UMat>, imagePoints::vector<UMat>, imageSize::Size, cameraMatrix::UMat, distCoeffs::UMat, stdDeviationsIntrinsics::UMat, stdDeviationsExtrinsics::UMat, perViewErrors::UMat, flags::int, criteria::TermCriteria) -> ( retval::double, cameraMatrix::UMat, distCoeffs::UMat, rvecs::vector<UMat>, tvecs::vector<UMat>, stdDeviationsIntrinsics::UMat, stdDeviationsExtrinsics::UMat, perViewErrors::UMat ) 
	 calibrateCamera
	 .method("jlopencv_cv_calibrateCamera",  [](vector<Mat> &objectPoints, vector<Mat> &imagePoints, Size &imageSize, Mat &cameraMatrix, Mat &distCoeffs, int &flags, TermCriteria &criteria) {vector<Mat> rvecs;vector<Mat> tvecs; auto retval = cv::calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, flags, criteria); return make_tuple<double,Mat,Mat,vector<Mat>,vector<Mat>>(retval,cameraMatrix,distCoeffs,rvecs,tvecs);})
		 calibrateCamera(objectPoints::vector<Mat>, imagePoints::vector<Mat>, imageSize::Size, cameraMatrix::Mat, distCoeffs::Mat, flags::int, criteria::TermCriteria) -> ( retval::double, cameraMatrix::Mat, distCoeffs::Mat, rvecs::vector<Mat>, tvecs::vector<Mat> ) 
	 calibrateCamera
	 .method("jlopencv_cv_calibrateCamera",  [](vector<UMat> &objectPoints, vector<UMat> &imagePoints, Size &imageSize, UMat &cameraMatrix, UMat &distCoeffs, int &flags, TermCriteria &criteria) {vector<UMat> rvecs;vector<UMat> tvecs; auto retval = cv::calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, flags, criteria); return make_tuple<double,UMat,UMat,vector<UMat>,vector<UMat>>(retval,cameraMatrix,distCoeffs,rvecs,tvecs);})
		 calibrateCamera(objectPoints::vector<UMat>, imagePoints::vector<UMat>, imageSize::Size, cameraMatrix::UMat, distCoeffs::UMat, flags::int, criteria::TermCriteria) -> ( retval::double, cameraMatrix::UMat, distCoeffs::UMat, rvecs::vector<UMat>, tvecs::vector<UMat> ) 
	 calibrateCameraROExtended
	 .method("jlopencv_cv_calibrateCameraROExtended",  [](vector<Mat> &objectPoints, vector<Mat> &imagePoints, Size &imageSize, int &iFixedPoint, Mat &cameraMatrix, Mat &distCoeffs, Mat &newObjPoints, Mat &stdDeviationsIntrinsics, Mat &stdDeviationsExtrinsics, Mat &stdDeviationsObjPoints, Mat &perViewErrors, int &flags, TermCriteria &criteria) {vector<Mat> rvecs;vector<Mat> tvecs; auto retval = cv::calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, stdDeviationsIntrinsics, stdDeviationsExtrinsics, stdDeviationsObjPoints, perViewErrors, flags, criteria); return make_tuple<double,Mat,Mat,vector<Mat>,vector<Mat>,Mat,Mat,Mat,Mat,Mat>(retval,cameraMatrix,distCoeffs,rvecs,tvecs,newObjPoints,stdDeviationsIntrinsics,stdDeviationsExtrinsics,stdDeviationsObjPoints,perViewErrors);})
		 calibrateCameraROExtended(objectPoints::vector<Mat>, imagePoints::vector<Mat>, imageSize::Size, iFixedPoint::int, cameraMatrix::Mat, distCoeffs::Mat, newObjPoints::Mat, stdDeviationsIntrinsics::Mat, stdDeviationsExtrinsics::Mat, stdDeviationsObjPoints::Mat, perViewErrors::Mat, flags::int, criteria::TermCriteria) -> ( retval::double, cameraMatrix::Mat, distCoeffs::Mat, rvecs::vector<Mat>, tvecs::vector<Mat>, newObjPoints::Mat, stdDeviationsIntrinsics::Mat, stdDeviationsExtrinsics::Mat, stdDeviationsObjPoints::Mat, perViewErrors::Mat ) 
	 calibrateCameraROExtended
	 .method("jlopencv_cv_calibrateCameraROExtended",  [](vector<UMat> &objectPoints, vector<UMat> &imagePoints, Size &imageSize, int &iFixedPoint, UMat &cameraMatrix, UMat &distCoeffs, UMat &newObjPoints, UMat &stdDeviationsIntrinsics, UMat &stdDeviationsExtrinsics, UMat &stdDeviationsObjPoints, UMat &perViewErrors, int &flags, TermCriteria &criteria) {vector<UMat> rvecs;vector<UMat> tvecs; auto retval = cv::calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, stdDeviationsIntrinsics, stdDeviationsExtrinsics, stdDeviationsObjPoints, perViewErrors, flags, criteria); return make_tuple<double,UMat,UMat,vector<UMat>,vector<UMat>,UMat,UMat,UMat,UMat,UMat>(retval,cameraMatrix,distCoeffs,rvecs,tvecs,newObjPoints,stdDeviationsIntrinsics,stdDeviationsExtrinsics,stdDeviationsObjPoints,perViewErrors);})
		 calibrateCameraROExtended(objectPoints::vector<UMat>, imagePoints::vector<UMat>, imageSize::Size, iFixedPoint::int, cameraMatrix::UMat, distCoeffs::UMat, newObjPoints::UMat, stdDeviationsIntrinsics::UMat, stdDeviationsExtrinsics::UMat, stdDeviationsObjPoints::UMat, perViewErrors::UMat, flags::int, criteria::TermCriteria) -> ( retval::double, cameraMatrix::UMat, distCoeffs::UMat, rvecs::vector<UMat>, tvecs::vector<UMat>, newObjPoints::UMat, stdDeviationsIntrinsics::UMat, stdDeviationsExtrinsics::UMat, stdDeviationsObjPoints::UMat, perViewErrors::UMat ) 
	 calibrateCameraRO
	 .method("jlopencv_cv_calibrateCameraRO",  [](vector<Mat> &objectPoints, vector<Mat> &imagePoints, Size &imageSize, int &iFixedPoint, Mat &cameraMatrix, Mat &distCoeffs, Mat &newObjPoints, int &flags, TermCriteria &criteria) {vector<Mat> rvecs;vector<Mat> tvecs; auto retval = cv::calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, flags, criteria); return make_tuple<double,Mat,Mat,vector<Mat>,vector<Mat>,Mat>(retval,cameraMatrix,distCoeffs,rvecs,tvecs,newObjPoints);})
		 calibrateCameraRO(objectPoints::vector<Mat>, imagePoints::vector<Mat>, imageSize::Size, iFixedPoint::int, cameraMatrix::Mat, distCoeffs::Mat, newObjPoints::Mat, flags::int, criteria::TermCriteria) -> ( retval::double, cameraMatrix::Mat, distCoeffs::Mat, rvecs::vector<Mat>, tvecs::vector<Mat>, newObjPoints::Mat ) 
	 calibrateCameraRO
	 .method("jlopencv_cv_calibrateCameraRO",  [](vector<UMat> &objectPoints, vector<UMat> &imagePoints, Size &imageSize, int &iFixedPoint, UMat &cameraMatrix, UMat &distCoeffs, UMat &newObjPoints, int &flags, TermCriteria &criteria) {vector<UMat> rvecs;vector<UMat> tvecs; auto retval = cv::calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, flags, criteria); return make_tuple<double,UMat,UMat,vector<UMat>,vector<UMat>,UMat>(retval,cameraMatrix,distCoeffs,rvecs,tvecs,newObjPoints);})
		 calibrateCameraRO(objectPoints::vector<UMat>, imagePoints::vector<UMat>, imageSize::Size, iFixedPoint::int, cameraMatrix::UMat, distCoeffs::UMat, newObjPoints::UMat, flags::int, criteria::TermCriteria) -> ( retval::double, cameraMatrix::UMat, distCoeffs::UMat, rvecs::vector<UMat>, tvecs::vector<UMat>, newObjPoints::UMat ) 
	 calibrationMatrixValues
	 .method("jlopencv_cv_calibrationMatrixValues",  [](Mat &cameraMatrix, Size &imageSize, double &apertureWidth, double &apertureHeight) {double fovx;double fovy;double focalLength;Point2d principalPoint;double aspectRatio; cv::calibrationMatrixValues(cameraMatrix, imageSize, apertureWidth, apertureHeight, fovx, fovy, focalLength, principalPoint, aspectRatio); return make_tuple<double,double,double,Point2d,double>(fovx,fovy,focalLength,principalPoint,aspectRatio);})
		 calibrationMatrixValues(cameraMatrix::Mat, imageSize::Size, apertureWidth::double, apertureHeight::double) -> ( fovx::double, fovy::double, focalLength::double, principalPoint::Point2d, aspectRatio::double ) 
	 calibrationMatrixValues
	 .method("jlopencv_cv_calibrationMatrixValues",  [](UMat &cameraMatrix, Size &imageSize, double &apertureWidth, double &apertureHeight) {double fovx;double fovy;double focalLength;Point2d principalPoint;double aspectRatio; cv::calibrationMatrixValues(cameraMatrix, imageSize, apertureWidth, apertureHeight, fovx, fovy, focalLength, principalPoint, aspectRatio); return make_tuple<double,double,double,Point2d,double>(fovx,fovy,focalLength,principalPoint,aspectRatio);})
		 calibrationMatrixValues(cameraMatrix::UMat, imageSize::Size, apertureWidth::double, apertureHeight::double) -> ( fovx::double, fovy::double, focalLength::double, principalPoint::Point2d, aspectRatio::double ) 
	 stereoCalibrateExtended
	 .method("jlopencv_cv_stereoCalibrateExtended",  [](vector<Mat> &objectPoints, vector<Mat> &imagePoints1, vector<Mat> &imagePoints2, Mat &cameraMatrix1, Mat &distCoeffs1, Mat &cameraMatrix2, Mat &distCoeffs2, Size &imageSize, Mat &R, Mat &T, Mat &E, Mat &F, Mat &perViewErrors, int &flags, TermCriteria &criteria) { auto retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, perViewErrors, flags, criteria); return make_tuple<double,Mat,Mat,Mat,Mat,Mat,Mat,Mat,Mat,Mat>(retval,cameraMatrix1,distCoeffs1,cameraMatrix2,distCoeffs2,R,T,E,F,perViewErrors);})
		 stereoCalibrateExtended(objectPoints::vector<Mat>, imagePoints1::vector<Mat>, imagePoints2::vector<Mat>, cameraMatrix1::Mat, distCoeffs1::Mat, cameraMatrix2::Mat, distCoeffs2::Mat, imageSize::Size, R::Mat, T::Mat, E::Mat, F::Mat, perViewErrors::Mat, flags::int, criteria::TermCriteria) -> ( retval::double, cameraMatrix1::Mat, distCoeffs1::Mat, cameraMatrix2::Mat, distCoeffs2::Mat, R::Mat, T::Mat, E::Mat, F::Mat, perViewErrors::Mat ) 
	 stereoCalibrateExtended
	 .method("jlopencv_cv_stereoCalibrateExtended",  [](vector<UMat> &objectPoints, vector<UMat> &imagePoints1, vector<UMat> &imagePoints2, UMat &cameraMatrix1, UMat &distCoeffs1, UMat &cameraMatrix2, UMat &distCoeffs2, Size &imageSize, UMat &R, UMat &T, UMat &E, UMat &F, UMat &perViewErrors, int &flags, TermCriteria &criteria) { auto retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, perViewErrors, flags, criteria); return make_tuple<double,UMat,UMat,UMat,UMat,UMat,UMat,UMat,UMat,UMat>(retval,cameraMatrix1,distCoeffs1,cameraMatrix2,distCoeffs2,R,T,E,F,perViewErrors);})
		 stereoCalibrateExtended(objectPoints::vector<UMat>, imagePoints1::vector<UMat>, imagePoints2::vector<UMat>, cameraMatrix1::UMat, distCoeffs1::UMat, cameraMatrix2::UMat, distCoeffs2::UMat, imageSize::Size, R::UMat, T::UMat, E::UMat, F::UMat, perViewErrors::UMat, flags::int, criteria::TermCriteria) -> ( retval::double, cameraMatrix1::UMat, distCoeffs1::UMat, cameraMatrix2::UMat, distCoeffs2::UMat, R::UMat, T::UMat, E::UMat, F::UMat, perViewErrors::UMat ) 
	 stereoCalibrate
	 .method("jlopencv_cv_stereoCalibrate",  [](vector<Mat> &objectPoints, vector<Mat> &imagePoints1, vector<Mat> &imagePoints2, Mat &cameraMatrix1, Mat &distCoeffs1, Mat &cameraMatrix2, Mat &distCoeffs2, Size &imageSize, Mat &R, Mat &T, Mat &E, Mat &F, int &flags, TermCriteria &criteria) { auto retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, flags, criteria); return make_tuple<double,Mat,Mat,Mat,Mat,Mat,Mat,Mat,Mat>(retval,cameraMatrix1,distCoeffs1,cameraMatrix2,distCoeffs2,R,T,E,F);})
		 stereoCalibrate(objectPoints::vector<Mat>, imagePoints1::vector<Mat>, imagePoints2::vector<Mat>, cameraMatrix1::Mat, distCoeffs1::Mat, cameraMatrix2::Mat, distCoeffs2::Mat, imageSize::Size, R::Mat, T::Mat, E::Mat, F::Mat, flags::int, criteria::TermCriteria) -> ( retval::double, cameraMatrix1::Mat, distCoeffs1::Mat, cameraMatrix2::Mat, distCoeffs2::Mat, R::Mat, T::Mat, E::Mat, F::Mat ) 
	 stereoCalibrate
	 .method("jlopencv_cv_stereoCalibrate",  [](vector<UMat> &objectPoints, vector<UMat> &imagePoints1, vector<UMat> &imagePoints2, UMat &cameraMatrix1, UMat &distCoeffs1, UMat &cameraMatrix2, UMat &distCoeffs2, Size &imageSize, UMat &R, UMat &T, UMat &E, UMat &F, int &flags, TermCriteria &criteria) { auto retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, flags, criteria); return make_tuple<double,UMat,UMat,UMat,UMat,UMat,UMat,UMat,UMat>(retval,cameraMatrix1,distCoeffs1,cameraMatrix2,distCoeffs2,R,T,E,F);})
		 stereoCalibrate(objectPoints::vector<UMat>, imagePoints1::vector<UMat>, imagePoints2::vector<UMat>, cameraMatrix1::UMat, distCoeffs1::UMat, cameraMatrix2::UMat, distCoeffs2::UMat, imageSize::Size, R::UMat, T::UMat, E::UMat, F::UMat, flags::int, criteria::TermCriteria) -> ( retval::double, cameraMatrix1::UMat, distCoeffs1::UMat, cameraMatrix2::UMat, distCoeffs2::UMat, R::UMat, T::UMat, E::UMat, F::UMat ) 
	 stereoRectify
	 .method("jlopencv_cv_stereoRectify",  [](Mat &cameraMatrix1, Mat &distCoeffs1, Mat &cameraMatrix2, Mat &distCoeffs2, Size &imageSize, Mat &R, Mat &T, Mat &R1, Mat &R2, Mat &P1, Mat &P2, Mat &Q, int &flags, double &alpha, Size &newImageSize) {Rect validPixROI1;Rect validPixROI2; cv::stereoRectify(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, R1, R2, P1, P2, Q, flags, alpha, newImageSize, validPixROI1, validPixROI2); return make_tuple<Mat,Mat,Mat,Mat,Mat,Rect,Rect>(R1,R2,P1,P2,Q,validPixROI1,validPixROI2);})
		 stereoRectify(cameraMatrix1::Mat, distCoeffs1::Mat, cameraMatrix2::Mat, distCoeffs2::Mat, imageSize::Size, R::Mat, T::Mat, R1::Mat, R2::Mat, P1::Mat, P2::Mat, Q::Mat, flags::int, alpha::double, newImageSize::Size) -> ( R1::Mat, R2::Mat, P1::Mat, P2::Mat, Q::Mat, validPixROI1::Rect*, validPixROI2::Rect* ) 
	 stereoRectify
	 .method("jlopencv_cv_stereoRectify",  [](UMat &cameraMatrix1, UMat &distCoeffs1, UMat &cameraMatrix2, UMat &distCoeffs2, Size &imageSize, UMat &R, UMat &T, UMat &R1, UMat &R2, UMat &P1, UMat &P2, UMat &Q, int &flags, double &alpha, Size &newImageSize) {Rect validPixROI1;Rect validPixROI2; cv::stereoRectify(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, R1, R2, P1, P2, Q, flags, alpha, newImageSize, validPixROI1, validPixROI2); return make_tuple<UMat,UMat,UMat,UMat,UMat,Rect,Rect>(R1,R2,P1,P2,Q,validPixROI1,validPixROI2);})
		 stereoRectify(cameraMatrix1::UMat, distCoeffs1::UMat, cameraMatrix2::UMat, distCoeffs2::UMat, imageSize::Size, R::UMat, T::UMat, R1::UMat, R2::UMat, P1::UMat, P2::UMat, Q::UMat, flags::int, alpha::double, newImageSize::Size) -> ( R1::UMat, R2::UMat, P1::UMat, P2::UMat, Q::UMat, validPixROI1::Rect*, validPixROI2::Rect* ) 
	 stereoRectifyUncalibrated
	 .method("jlopencv_cv_stereoRectifyUncalibrated",  [](Mat &points1, Mat &points2, Mat &F, Size &imgSize, Mat &H1, Mat &H2, double &threshold) { auto retval = cv::stereoRectifyUncalibrated(points1, points2, F, imgSize, H1, H2, threshold); return make_tuple<bool,Mat,Mat>(retval,H1,H2);})
		 stereoRectifyUncalibrated(points1::Mat, points2::Mat, F::Mat, imgSize::Size, H1::Mat, H2::Mat, threshold::double) -> ( retval::bool, H1::Mat, H2::Mat ) 
	 stereoRectifyUncalibrated
	 .method("jlopencv_cv_stereoRectifyUncalibrated",  [](UMat &points1, UMat &points2, UMat &F, Size &imgSize, UMat &H1, UMat &H2, double &threshold) { auto retval = cv::stereoRectifyUncalibrated(points1, points2, F, imgSize, H1, H2, threshold); return make_tuple<bool,UMat,UMat>(retval,H1,H2);})
		 stereoRectifyUncalibrated(points1::UMat, points2::UMat, F::UMat, imgSize::Size, H1::UMat, H2::UMat, threshold::double) -> ( retval::bool, H1::UMat, H2::UMat ) 
	 rectify3Collinear
	 .method("jlopencv_cv_rectify3Collinear",  [](Mat &cameraMatrix1, Mat &distCoeffs1, Mat &cameraMatrix2, Mat &distCoeffs2, Mat &cameraMatrix3, Mat &distCoeffs3, vector<Mat> &imgpt1, vector<Mat> &imgpt3, Size &imageSize, Mat &R12, Mat &T12, Mat &R13, Mat &T13, double &alpha, Size &newImgSize, int &flags, Mat &R1, Mat &R2, Mat &R3, Mat &P1, Mat &P2, Mat &P3, Mat &Q) {Rect roi1;Rect roi2; auto retval = cv::rectify3Collinear(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, cameraMatrix3, distCoeffs3, imgpt1, imgpt3, imageSize, R12, T12, R13, T13, R1, R2, R3, P1, P2, P3, Q, alpha, newImgSize, roi1, roi2, flags); return make_tuple<float,Mat,Mat,Mat,Mat,Mat,Mat,Mat,Rect,Rect>(retval,R1,R2,R3,P1,P2,P3,Q,roi1,roi2);})
		 rectify3Collinear(cameraMatrix1::Mat, distCoeffs1::Mat, cameraMatrix2::Mat, distCoeffs2::Mat, cameraMatrix3::Mat, distCoeffs3::Mat, imgpt1::vector<Mat>, imgpt3::vector<Mat>, imageSize::Size, R12::Mat, T12::Mat, R13::Mat, T13::Mat, alpha::double, newImgSize::Size, flags::int; R1::Mat, R2::Mat, R3::Mat, P1::Mat, P2::Mat, P3::Mat, Q::Mat) -> ( retval::float, R1::Mat, R2::Mat, R3::Mat, P1::Mat, P2::Mat, P3::Mat, Q::Mat, roi1::Rect*, roi2::Rect* ) 
	 rectify3Collinear
	 .method("jlopencv_cv_rectify3Collinear",  [](UMat &cameraMatrix1, UMat &distCoeffs1, UMat &cameraMatrix2, UMat &distCoeffs2, UMat &cameraMatrix3, UMat &distCoeffs3, vector<UMat> &imgpt1, vector<UMat> &imgpt3, Size &imageSize, UMat &R12, UMat &T12, UMat &R13, UMat &T13, double &alpha, Size &newImgSize, int &flags, UMat &R1, UMat &R2, UMat &R3, UMat &P1, UMat &P2, UMat &P3, UMat &Q) {Rect roi1;Rect roi2; auto retval = cv::rectify3Collinear(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, cameraMatrix3, distCoeffs3, imgpt1, imgpt3, imageSize, R12, T12, R13, T13, R1, R2, R3, P1, P2, P3, Q, alpha, newImgSize, roi1, roi2, flags); return make_tuple<float,UMat,UMat,UMat,UMat,UMat,UMat,UMat,Rect,Rect>(retval,R1,R2,R3,P1,P2,P3,Q,roi1,roi2);})
		 rectify3Collinear(cameraMatrix1::UMat, distCoeffs1::UMat, cameraMatrix2::UMat, distCoeffs2::UMat, cameraMatrix3::UMat, distCoeffs3::UMat, imgpt1::vector<UMat>, imgpt3::vector<UMat>, imageSize::Size, R12::UMat, T12::UMat, R13::UMat, T13::UMat, alpha::double, newImgSize::Size, flags::int; R1::UMat, R2::UMat, R3::UMat, P1::UMat, P2::UMat, P3::UMat, Q::UMat) -> ( retval::float, R1::UMat, R2::UMat, R3::UMat, P1::UMat, P2::UMat, P3::UMat, Q::UMat, roi1::Rect*, roi2::Rect* ) 
	 getOptimalNewCameraMatrix
	 .method("jlopencv_cv_getOptimalNewCameraMatrix",  [](Mat &cameraMatrix, Mat &distCoeffs, Size &imageSize, double &alpha, Size &newImgSize, bool &centerPrincipalPoint) {Rect validPixROI; auto retval = cv::getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, alpha, newImgSize, validPixROI, centerPrincipalPoint); return make_tuple<Mat,Rect>(retval,validPixROI);})
		 getOptimalNewCameraMatrix(cameraMatrix::Mat, distCoeffs::Mat, imageSize::Size, alpha::double, newImgSize::Size, centerPrincipalPoint::bool) -> ( retval::Mat, validPixROI::Rect* ) 
	 getOptimalNewCameraMatrix
	 .method("jlopencv_cv_getOptimalNewCameraMatrix",  [](UMat &cameraMatrix, UMat &distCoeffs, Size &imageSize, double &alpha, Size &newImgSize, bool &centerPrincipalPoint) {Rect validPixROI; auto retval = cv::getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, alpha, newImgSize, validPixROI, centerPrincipalPoint); return make_tuple<Mat,Rect>(retval,validPixROI);})
		 getOptimalNewCameraMatrix(cameraMatrix::UMat, distCoeffs::UMat, imageSize::Size, alpha::double, newImgSize::Size, centerPrincipalPoint::bool) -> ( retval::Mat, validPixROI::Rect* ) 
	 calibrateHandEye
	 .method("jlopencv_cv_calibrateHandEye",  [](vector<Mat> &R_gripper2base, vector<Mat> &t_gripper2base, vector<Mat> &R_target2cam, vector<Mat> &t_target2cam, Mat &R_cam2gripper, Mat &t_cam2gripper, HandEyeCalibrationMethod &method) { cv::calibrateHandEye(R_gripper2base, t_gripper2base, R_target2cam, t_target2cam, R_cam2gripper, t_cam2gripper, method); return make_tuple<Mat,Mat>(R_cam2gripper,t_cam2gripper);})
		 calibrateHandEye(R_gripper2base::vector<Mat>, t_gripper2base::vector<Mat>, R_target2cam::vector<Mat>, t_target2cam::vector<Mat>, R_cam2gripper::Mat, t_cam2gripper::Mat, method::HandEyeCalibrationMethod) -> ( R_cam2gripper::Mat, t_cam2gripper::Mat ) 
	 calibrateHandEye
	 .method("jlopencv_cv_calibrateHandEye",  [](vector<UMat> &R_gripper2base, vector<UMat> &t_gripper2base, vector<UMat> &R_target2cam, vector<UMat> &t_target2cam, UMat &R_cam2gripper, UMat &t_cam2gripper, HandEyeCalibrationMethod &method) { cv::calibrateHandEye(R_gripper2base, t_gripper2base, R_target2cam, t_target2cam, R_cam2gripper, t_cam2gripper, method); return make_tuple<UMat,UMat>(R_cam2gripper,t_cam2gripper);})
		 calibrateHandEye(R_gripper2base::vector<UMat>, t_gripper2base::vector<UMat>, R_target2cam::vector<UMat>, t_target2cam::vector<UMat>, R_cam2gripper::UMat, t_cam2gripper::UMat, method::HandEyeCalibrationMethod) -> ( R_cam2gripper::UMat, t_cam2gripper::UMat ) 
	 convertPointsToHomogeneous
	 .method("jlopencv_cv_convertPointsToHomogeneous",  [](Mat &src, Mat &dst) { cv::convertPointsToHomogeneous(src, dst); return dst;})
		 convertPointsToHomogeneous(src::Mat; dst::Mat) -> ( dst::Mat ) 
	 convertPointsToHomogeneous
	 .method("jlopencv_cv_convertPointsToHomogeneous",  [](UMat &src, UMat &dst) { cv::convertPointsToHomogeneous(src, dst); return dst;})
		 convertPointsToHomogeneous(src::UMat; dst::UMat) -> ( dst::UMat ) 
	 convertPointsFromHomogeneous
	 .method("jlopencv_cv_convertPointsFromHomogeneous",  [](Mat &src, Mat &dst) { cv::convertPointsFromHomogeneous(src, dst); return dst;})
		 convertPointsFromHomogeneous(src::Mat; dst::Mat) -> ( dst::Mat ) 
	 convertPointsFromHomogeneous
	 .method("jlopencv_cv_convertPointsFromHomogeneous",  [](UMat &src, UMat &dst) { cv::convertPointsFromHomogeneous(src, dst); return dst;})
		 convertPointsFromHomogeneous(src::UMat; dst::UMat) -> ( dst::UMat ) 
	 findFundamentalMat
	 .method("jlopencv_cv_findFundamentalMat",  [](Mat &points1, Mat &points2, int &method, double &ransacReprojThreshold, double &confidence, Mat &mask) { auto retval = cv::findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, mask); return make_tuple<Mat,Mat>(retval,mask);})
		 findFundamentalMat(points1::Mat, points2::Mat, method::int, ransacReprojThreshold::double, confidence::double; mask::Mat) -> ( retval::Mat, mask::Mat ) 
	 findFundamentalMat
	 .method("jlopencv_cv_findFundamentalMat",  [](UMat &points1, UMat &points2, int &method, double &ransacReprojThreshold, double &confidence, UMat &mask) { auto retval = cv::findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, mask); return make_tuple<Mat,UMat>(retval,mask);})
		 findFundamentalMat(points1::UMat, points2::UMat, method::int, ransacReprojThreshold::double, confidence::double; mask::UMat) -> ( retval::Mat, mask::UMat ) 
	 findEssentialMat
	 .method("jlopencv_cv_findEssentialMat",  [](Mat &points1, Mat &points2, Mat &cameraMatrix, int &method, double &prob, double &threshold, Mat &mask) { auto retval = cv::findEssentialMat(points1, points2, cameraMatrix, method, prob, threshold, mask); return make_tuple<Mat,Mat>(retval,mask);})
		 findEssentialMat(points1::Mat, points2::Mat, cameraMatrix::Mat, method::int, prob::double, threshold::double; mask::Mat) -> ( retval::Mat, mask::Mat ) 
	 findEssentialMat
	 .method("jlopencv_cv_findEssentialMat",  [](UMat &points1, UMat &points2, UMat &cameraMatrix, int &method, double &prob, double &threshold, UMat &mask) { auto retval = cv::findEssentialMat(points1, points2, cameraMatrix, method, prob, threshold, mask); return make_tuple<Mat,UMat>(retval,mask);})
		 findEssentialMat(points1::UMat, points2::UMat, cameraMatrix::UMat, method::int, prob::double, threshold::double; mask::UMat) -> ( retval::Mat, mask::UMat ) 
	 findEssentialMat
	 .method("jlopencv_cv_findEssentialMat",  [](Mat &points1, Mat &points2, double &focal, Point2d &pp, int &method, double &prob, double &threshold, Mat &mask) { auto retval = cv::findEssentialMat(points1, points2, focal, pp, method, prob, threshold, mask); return make_tuple<Mat,Mat>(retval,mask);})
		 findEssentialMat(points1::Mat, points2::Mat, focal::double, pp::Point2d, method::int, prob::double, threshold::double; mask::Mat) -> ( retval::Mat, mask::Mat ) 
	 findEssentialMat
	 .method("jlopencv_cv_findEssentialMat",  [](UMat &points1, UMat &points2, double &focal, Point2d &pp, int &method, double &prob, double &threshold, UMat &mask) { auto retval = cv::findEssentialMat(points1, points2, focal, pp, method, prob, threshold, mask); return make_tuple<Mat,UMat>(retval,mask);})
		 findEssentialMat(points1::UMat, points2::UMat, focal::double, pp::Point2d, method::int, prob::double, threshold::double; mask::UMat) -> ( retval::Mat, mask::UMat ) 
	 decomposeEssentialMat
	 .method("jlopencv_cv_decomposeEssentialMat",  [](Mat &E, Mat &R1, Mat &R2, Mat &t) { cv::decomposeEssentialMat(E, R1, R2, t); return make_tuple<Mat,Mat,Mat>(R1,R2,t);})
		 decomposeEssentialMat(E::Mat; R1::Mat, R2::Mat, t::Mat) -> ( R1::Mat, R2::Mat, t::Mat ) 
	 decomposeEssentialMat
	 .method("jlopencv_cv_decomposeEssentialMat",  [](UMat &E, UMat &R1, UMat &R2, UMat &t) { cv::decomposeEssentialMat(E, R1, R2, t); return make_tuple<UMat,UMat,UMat>(R1,R2,t);})
		 decomposeEssentialMat(E::UMat; R1::UMat, R2::UMat, t::UMat) -> ( R1::UMat, R2::UMat, t::UMat ) 
	 recoverPose
	 .method("jlopencv_cv_recoverPose",  [](Mat &E, Mat &points1, Mat &points2, Mat &cameraMatrix, Mat &R, Mat &t, Mat &mask) { auto retval = cv::recoverPose(E, points1, points2, cameraMatrix, R, t, mask); return make_tuple<int,Mat,Mat,Mat>(retval,R,t,mask);})
		 recoverPose(E::Mat, points1::Mat, points2::Mat, cameraMatrix::Mat, R::Mat, t::Mat, mask::Mat) -> ( retval::int, R::Mat, t::Mat, mask::Mat ) 
	 recoverPose
	 .method("jlopencv_cv_recoverPose",  [](UMat &E, UMat &points1, UMat &points2, UMat &cameraMatrix, UMat &R, UMat &t, UMat &mask) { auto retval = cv::recoverPose(E, points1, points2, cameraMatrix, R, t, mask); return make_tuple<int,UMat,UMat,UMat>(retval,R,t,mask);})
		 recoverPose(E::UMat, points1::UMat, points2::UMat, cameraMatrix::UMat, R::UMat, t::UMat, mask::UMat) -> ( retval::int, R::UMat, t::UMat, mask::UMat ) 
	 recoverPose
	 .method("jlopencv_cv_recoverPose",  [](Mat &E, Mat &points1, Mat &points2, Mat &R, Mat &t, double &focal, Point2d &pp, Mat &mask) { auto retval = cv::recoverPose(E, points1, points2, R, t, focal, pp, mask); return make_tuple<int,Mat,Mat,Mat>(retval,R,t,mask);})
		 recoverPose(E::Mat, points1::Mat, points2::Mat, R::Mat, t::Mat, focal::double, pp::Point2d, mask::Mat) -> ( retval::int, R::Mat, t::Mat, mask::Mat ) 
	 recoverPose
	 .method("jlopencv_cv_recoverPose",  [](UMat &E, UMat &points1, UMat &points2, UMat &R, UMat &t, double &focal, Point2d &pp, UMat &mask) { auto retval = cv::recoverPose(E, points1, points2, R, t, focal, pp, mask); return make_tuple<int,UMat,UMat,UMat>(retval,R,t,mask);})
		 recoverPose(E::UMat, points1::UMat, points2::UMat, R::UMat, t::UMat, focal::double, pp::Point2d, mask::UMat) -> ( retval::int, R::UMat, t::UMat, mask::UMat ) 
	 recoverPose
	 .method("jlopencv_cv_recoverPose",  [](Mat &E, Mat &points1, Mat &points2, Mat &cameraMatrix, double &distanceThresh, Mat &R, Mat &t, Mat &mask, Mat &triangulatedPoints) { auto retval = cv::recoverPose(E, points1, points2, cameraMatrix, R, t, distanceThresh, mask, triangulatedPoints); return make_tuple<int,Mat,Mat,Mat,Mat>(retval,R,t,mask,triangulatedPoints);})
		 recoverPose(E::Mat, points1::Mat, points2::Mat, cameraMatrix::Mat, distanceThresh::double, R::Mat, t::Mat, mask::Mat; triangulatedPoints::Mat) -> ( retval::int, R::Mat, t::Mat, mask::Mat, triangulatedPoints::Mat ) 
	 recoverPose
	 .method("jlopencv_cv_recoverPose",  [](UMat &E, UMat &points1, UMat &points2, UMat &cameraMatrix, double &distanceThresh, UMat &R, UMat &t, UMat &mask, UMat &triangulatedPoints) { auto retval = cv::recoverPose(E, points1, points2, cameraMatrix, R, t, distanceThresh, mask, triangulatedPoints); return make_tuple<int,UMat,UMat,UMat,UMat>(retval,R,t,mask,triangulatedPoints);})
		 recoverPose(E::UMat, points1::UMat, points2::UMat, cameraMatrix::UMat, distanceThresh::double, R::UMat, t::UMat, mask::UMat; triangulatedPoints::UMat) -> ( retval::int, R::UMat, t::UMat, mask::UMat, triangulatedPoints::UMat ) 
	 computeCorrespondEpilines
	 .method("jlopencv_cv_computeCorrespondEpilines",  [](Mat &points, int &whichImage, Mat &F, Mat &lines) { cv::computeCorrespondEpilines(points, whichImage, F, lines); return lines;})
		 computeCorrespondEpilines(points::Mat, whichImage::int, F::Mat; lines::Mat) -> ( lines::Mat ) 
	 computeCorrespondEpilines
	 .method("jlopencv_cv_computeCorrespondEpilines",  [](UMat &points, int &whichImage, UMat &F, UMat &lines) { cv::computeCorrespondEpilines(points, whichImage, F, lines); return lines;})
		 computeCorrespondEpilines(points::UMat, whichImage::int, F::UMat; lines::UMat) -> ( lines::UMat ) 
	 triangulatePoints
	 .method("jlopencv_cv_triangulatePoints",  [](Mat &projMatr1, Mat &projMatr2, Mat &projPoints1, Mat &projPoints2, Mat &points4D) { cv::triangulatePoints(projMatr1, projMatr2, projPoints1, projPoints2, points4D); return points4D;})
		 triangulatePoints(projMatr1::Mat, projMatr2::Mat, projPoints1::Mat, projPoints2::Mat; points4D::Mat) -> ( points4D::Mat ) 
	 triangulatePoints
	 .method("jlopencv_cv_triangulatePoints",  [](UMat &projMatr1, UMat &projMatr2, UMat &projPoints1, UMat &projPoints2, UMat &points4D) { cv::triangulatePoints(projMatr1, projMatr2, projPoints1, projPoints2, points4D); return points4D;})
		 triangulatePoints(projMatr1::UMat, projMatr2::UMat, projPoints1::UMat, projPoints2::UMat; points4D::UMat) -> ( points4D::UMat ) 
	 correctMatches
	 .method("jlopencv_cv_correctMatches",  [](Mat &F, Mat &points1, Mat &points2, Mat &newPoints1, Mat &newPoints2) { cv::correctMatches(F, points1, points2, newPoints1, newPoints2); return make_tuple<Mat,Mat>(newPoints1,newPoints2);})
		 correctMatches(F::Mat, points1::Mat, points2::Mat; newPoints1::Mat, newPoints2::Mat) -> ( newPoints1::Mat, newPoints2::Mat ) 
	 correctMatches
	 .method("jlopencv_cv_correctMatches",  [](UMat &F, UMat &points1, UMat &points2, UMat &newPoints1, UMat &newPoints2) { cv::correctMatches(F, points1, points2, newPoints1, newPoints2); return make_tuple<UMat,UMat>(newPoints1,newPoints2);})
		 correctMatches(F::UMat, points1::UMat, points2::UMat; newPoints1::UMat, newPoints2::UMat) -> ( newPoints1::UMat, newPoints2::UMat ) 
	 filterSpeckles
	 .method("jlopencv_cv_filterSpeckles",  [](Mat &img, double &newVal, int &maxSpeckleSize, double &maxDiff, Mat &buf) { cv::filterSpeckles(img, newVal, maxSpeckleSize, maxDiff, buf); return make_tuple<Mat,Mat>(img,buf);})
		 filterSpeckles(img::Mat, newVal::double, maxSpeckleSize::int, maxDiff::double, buf::Mat) -> ( img::Mat, buf::Mat ) 
	 filterSpeckles
	 .method("jlopencv_cv_filterSpeckles",  [](UMat &img, double &newVal, int &maxSpeckleSize, double &maxDiff, UMat &buf) { cv::filterSpeckles(img, newVal, maxSpeckleSize, maxDiff, buf); return make_tuple<UMat,UMat>(img,buf);})
		 filterSpeckles(img::UMat, newVal::double, maxSpeckleSize::int, maxDiff::double, buf::UMat) -> ( img::UMat, buf::UMat ) 
	 getValidDisparityROI
	 .method("jlopencv_cv_getValidDisparityROI",  [](Rect &roi1, Rect &roi2, int &minDisparity, int &numberOfDisparities, int &blockSize) { auto retval = cv::getValidDisparityROI(roi1, roi2, minDisparity, numberOfDisparities, blockSize); return retval;})
		 getValidDisparityROI(roi1::Rect, roi2::Rect, minDisparity::int, numberOfDisparities::int, blockSize::int) -> ( retval::Rect ) 
	 validateDisparity
	 .method("jlopencv_cv_validateDisparity",  [](Mat &disparity, Mat &cost, int &minDisparity, int &numberOfDisparities, int &disp12MaxDisp) { cv::validateDisparity(disparity, cost, minDisparity, numberOfDisparities, disp12MaxDisp); return disparity;})
		 validateDisparity(disparity::Mat, cost::Mat, minDisparity::int, numberOfDisparities::int, disp12MaxDisp::int) -> ( disparity::Mat ) 
	 validateDisparity
	 .method("jlopencv_cv_validateDisparity",  [](UMat &disparity, UMat &cost, int &minDisparity, int &numberOfDisparities, int &disp12MaxDisp) { cv::validateDisparity(disparity, cost, minDisparity, numberOfDisparities, disp12MaxDisp); return disparity;})
		 validateDisparity(disparity::UMat, cost::UMat, minDisparity::int, numberOfDisparities::int, disp12MaxDisp::int) -> ( disparity::UMat ) 
	 reprojectImageTo3D
	 .method("jlopencv_cv_reprojectImageTo3D",  [](Mat &disparity, Mat &Q, Mat &_3dImage, bool &handleMissingValues, int &ddepth) { cv::reprojectImageTo3D(disparity, _3dImage, Q, handleMissingValues, ddepth); return _3dImage;})
		 reprojectImageTo3D(disparity::Mat, Q::Mat, _3dImage::Mat, handleMissingValues::bool, ddepth::int) -> ( _3dImage::Mat ) 
	 reprojectImageTo3D
	 .method("jlopencv_cv_reprojectImageTo3D",  [](UMat &disparity, UMat &Q, UMat &_3dImage, bool &handleMissingValues, int &ddepth) { cv::reprojectImageTo3D(disparity, _3dImage, Q, handleMissingValues, ddepth); return _3dImage;})
		 reprojectImageTo3D(disparity::UMat, Q::UMat, _3dImage::UMat, handleMissingValues::bool, ddepth::int) -> ( _3dImage::UMat ) 
	 sampsonDistance
	 .method("jlopencv_cv_sampsonDistance",  [](Mat &pt1, Mat &pt2, Mat &F) { auto retval = cv::sampsonDistance(pt1, pt2, F); return retval;})
		 sampsonDistance(pt1::Mat, pt2::Mat, F::Mat) -> ( retval::double ) 
	 sampsonDistance
	 .method("jlopencv_cv_sampsonDistance",  [](UMat &pt1, UMat &pt2, UMat &F) { auto retval = cv::sampsonDistance(pt1, pt2, F); return retval;})
		 sampsonDistance(pt1::UMat, pt2::UMat, F::UMat) -> ( retval::double ) 
	 estimateAffine3D
	 .method("jlopencv_cv_estimateAffine3D",  [](Mat &src, Mat &dst, Mat &out, Mat &inliers, double &ransacThreshold, double &confidence) { auto retval = cv::estimateAffine3D(src, dst, out, inliers, ransacThreshold, confidence); return make_tuple<int,Mat,Mat>(retval,out,inliers);})
		 estimateAffine3D(src::Mat, dst::Mat, out::Mat, inliers::Mat, ransacThreshold::double, confidence::double) -> ( retval::int, out::Mat, inliers::Mat ) 
	 estimateAffine3D
	 .method("jlopencv_cv_estimateAffine3D",  [](UMat &src, UMat &dst, UMat &out, UMat &inliers, double &ransacThreshold, double &confidence) { auto retval = cv::estimateAffine3D(src, dst, out, inliers, ransacThreshold, confidence); return make_tuple<int,UMat,UMat>(retval,out,inliers);})
		 estimateAffine3D(src::UMat, dst::UMat, out::UMat, inliers::UMat, ransacThreshold::double, confidence::double) -> ( retval::int, out::UMat, inliers::UMat ) 
	 estimateAffine2D
	 .method("jlopencv_cv_estimateAffine2D",  [](Mat &from, Mat &to, Mat &inliers, int &method, double &ransacReprojThreshold, size_t &maxIters, double &confidence, size_t &refineIters) { auto retval = cv::estimateAffine2D(from, to, inliers, method, ransacReprojThreshold, maxIters, confidence, refineIters); return make_tuple<cv::Mat,Mat>(retval,inliers);})
		 estimateAffine2D(from::Mat, to::Mat, inliers::Mat, method::int, ransacReprojThreshold::double, maxIters::size_t, confidence::double, refineIters::size_t) -> ( retval::cv::Mat, inliers::Mat ) 
	 estimateAffine2D
	 .method("jlopencv_cv_estimateAffine2D",  [](UMat &from, UMat &to, UMat &inliers, int &method, double &ransacReprojThreshold, size_t &maxIters, double &confidence, size_t &refineIters) { auto retval = cv::estimateAffine2D(from, to, inliers, method, ransacReprojThreshold, maxIters, confidence, refineIters); return make_tuple<cv::Mat,UMat>(retval,inliers);})
		 estimateAffine2D(from::UMat, to::UMat, inliers::UMat, method::int, ransacReprojThreshold::double, maxIters::size_t, confidence::double, refineIters::size_t) -> ( retval::cv::Mat, inliers::UMat ) 
	 estimateAffinePartial2D
	 .method("jlopencv_cv_estimateAffinePartial2D",  [](Mat &from, Mat &to, Mat &inliers, int &method, double &ransacReprojThreshold, size_t &maxIters, double &confidence, size_t &refineIters) { auto retval = cv::estimateAffinePartial2D(from, to, inliers, method, ransacReprojThreshold, maxIters, confidence, refineIters); return make_tuple<cv::Mat,Mat>(retval,inliers);})
		 estimateAffinePartial2D(from::Mat, to::Mat, inliers::Mat, method::int, ransacReprojThreshold::double, maxIters::size_t, confidence::double, refineIters::size_t) -> ( retval::cv::Mat, inliers::Mat ) 
	 estimateAffinePartial2D
	 .method("jlopencv_cv_estimateAffinePartial2D",  [](UMat &from, UMat &to, UMat &inliers, int &method, double &ransacReprojThreshold, size_t &maxIters, double &confidence, size_t &refineIters) { auto retval = cv::estimateAffinePartial2D(from, to, inliers, method, ransacReprojThreshold, maxIters, confidence, refineIters); return make_tuple<cv::Mat,UMat>(retval,inliers);})
		 estimateAffinePartial2D(from::UMat, to::UMat, inliers::UMat, method::int, ransacReprojThreshold::double, maxIters::size_t, confidence::double, refineIters::size_t) -> ( retval::cv::Mat, inliers::UMat ) 
	 decomposeHomographyMat
	 .method("jlopencv_cv_decomposeHomographyMat",  [](Mat &H, Mat &K) {vector<Mat> rotations;vector<Mat> translations;vector<Mat> normals; auto retval = cv::decomposeHomographyMat(H, K, rotations, translations, normals); return make_tuple<int,vector<Mat>,vector<Mat>,vector<Mat>>(retval,rotations,translations,normals);})
		 decomposeHomographyMat(H::Mat, K::Mat) -> ( retval::int, rotations::vector<Mat>, translations::vector<Mat>, normals::vector<Mat> ) 
	 decomposeHomographyMat
	 .method("jlopencv_cv_decomposeHomographyMat",  [](UMat &H, UMat &K) {vector<UMat> rotations;vector<UMat> translations;vector<UMat> normals; auto retval = cv::decomposeHomographyMat(H, K, rotations, translations, normals); return make_tuple<int,vector<UMat>,vector<UMat>,vector<UMat>>(retval,rotations,translations,normals);})
		 decomposeHomographyMat(H::UMat, K::UMat) -> ( retval::int, rotations::vector<UMat>, translations::vector<UMat>, normals::vector<UMat> ) 
	 filterHomographyDecompByVisibleRefpoints
	 .method("jlopencv_cv_filterHomographyDecompByVisibleRefpoints",  [](vector<Mat> &rotations, vector<Mat> &normals, Mat &beforePoints, Mat &afterPoints, Mat &possibleSolutions, Mat &pointsMask) { cv::filterHomographyDecompByVisibleRefpoints(rotations, normals, beforePoints, afterPoints, possibleSolutions, pointsMask); return possibleSolutions;})
		 filterHomographyDecompByVisibleRefpoints(rotations::vector<Mat>, normals::vector<Mat>, beforePoints::Mat, afterPoints::Mat, possibleSolutions::Mat, pointsMask::Mat) -> ( possibleSolutions::Mat ) 
	 filterHomographyDecompByVisibleRefpoints
	 .method("jlopencv_cv_filterHomographyDecompByVisibleRefpoints",  [](vector<UMat> &rotations, vector<UMat> &normals, UMat &beforePoints, UMat &afterPoints, UMat &possibleSolutions, UMat &pointsMask) { cv::filterHomographyDecompByVisibleRefpoints(rotations, normals, beforePoints, afterPoints, possibleSolutions, pointsMask); return possibleSolutions;})
		 filterHomographyDecompByVisibleRefpoints(rotations::vector<UMat>, normals::vector<UMat>, beforePoints::UMat, afterPoints::UMat, possibleSolutions::UMat, pointsMask::UMat) -> ( possibleSolutions::UMat ) 
	 StereoBM_create
	 .method("jlopencv_cv_StereoBM_create",  [](int &numDisparities, int &blockSize) { auto retval = cv::StereoBM::create(numDisparities, blockSize); return retval;})
		 StereoBM_create(numDisparities::int, blockSize::int) -> ( retval::Ptr<StereoBM> ) 
	 StereoSGBM_create
	 .method("jlopencv_cv_StereoSGBM_create",  [](int &minDisparity, int &numDisparities, int &blockSize, int &P1, int &P2, int &disp12MaxDiff, int &preFilterCap, int &uniquenessRatio, int &speckleWindowSize, int &speckleRange, int &mode) { auto retval = cv::StereoSGBM::create(minDisparity, numDisparities, blockSize, P1, P2, disp12MaxDiff, preFilterCap, uniquenessRatio, speckleWindowSize, speckleRange, mode); return retval;})
		 StereoSGBM_create(minDisparity::int, numDisparities::int, blockSize::int, P1::int, P2::int, disp12MaxDiff::int, preFilterCap::int, uniquenessRatio::int, speckleWindowSize::int, speckleRange::int, mode::int) -> ( retval::Ptr<StereoSGBM> ) 
	 BRISK_create
	 .method("jlopencv_cv_BRISK_create",  [](int &thresh, int &octaves, float &patternScale) { auto retval = cv::BRISK::create(thresh, octaves, patternScale); return retval;})
		 BRISK_create(thresh::int, octaves::int, patternScale::float) -> ( retval::Ptr<BRISK> ) 
	 BRISK_create
	 .method("jlopencv_cv_BRISK_create",  [](vector<float> &radiusList, vector<int> &numberList, float &dMax, float &dMin, vector<int> &indexChange) { auto retval = cv::BRISK::create(radiusList, numberList, dMax, dMin, indexChange); return retval;})
		 BRISK_create(radiusList::vector<float>, numberList::vector<int>, dMax::float, dMin::float, indexChange::vector<int>) -> ( retval::Ptr<BRISK> ) 
	 BRISK_create
	 .method("jlopencv_cv_BRISK_create",  [](int &thresh, int &octaves, vector<float> &radiusList, vector<int> &numberList, float &dMax, float &dMin, vector<int> &indexChange) { auto retval = cv::BRISK::create(thresh, octaves, radiusList, numberList, dMax, dMin, indexChange); return retval;})
		 BRISK_create(thresh::int, octaves::int, radiusList::vector<float>, numberList::vector<int>, dMax::float, dMin::float, indexChange::vector<int>) -> ( retval::Ptr<BRISK> ) 
	 ORB_create
	 .method("jlopencv_cv_ORB_create",  [](int &nfeatures, float &scaleFactor, int &nlevels, int &edgeThreshold, int &firstLevel, int &WTA_K, ORB_ScoreType &scoreType, int &patchSize, int &fastThreshold) { auto retval = cv::ORB::create(nfeatures, scaleFactor, nlevels, edgeThreshold, firstLevel, WTA_K, scoreType, patchSize, fastThreshold); return retval;})
		 ORB_create(nfeatures::int, scaleFactor::float, nlevels::int, edgeThreshold::int, firstLevel::int, WTA_K::int, scoreType::ORB_ScoreType, patchSize::int, fastThreshold::int) -> ( retval::Ptr<ORB> ) 
	 MSER_create
	 .method("jlopencv_cv_MSER_create",  [](int &_delta, int &_min_area, int &_max_area, double &_max_variation, double &_min_diversity, int &_max_evolution, double &_area_threshold, double &_min_margin, int &_edge_blur_size) { auto retval = cv::MSER::create(_delta, _min_area, _max_area, _max_variation, _min_diversity, _max_evolution, _area_threshold, _min_margin, _edge_blur_size); return retval;})
		 MSER_create(_delta::int, _min_area::int, _max_area::int, _max_variation::double, _min_diversity::double, _max_evolution::int, _area_threshold::double, _min_margin::double, _edge_blur_size::int) -> ( retval::Ptr<MSER> ) 
	 FastFeatureDetector_create
	 .method("jlopencv_cv_FastFeatureDetector_create",  [](int &threshold, bool &nonmaxSuppression, FastFeatureDetector_DetectorType &type) { auto retval = cv::FastFeatureDetector::create(threshold, nonmaxSuppression, type); return retval;})
		 FastFeatureDetector_create(threshold::int, nonmaxSuppression::bool, type::FastFeatureDetector_DetectorType) -> ( retval::Ptr<FastFeatureDetector> ) 
	 AgastFeatureDetector_create
	 .method("jlopencv_cv_AgastFeatureDetector_create",  [](int &threshold, bool &nonmaxSuppression, AgastFeatureDetector_DetectorType &type) { auto retval = cv::AgastFeatureDetector::create(threshold, nonmaxSuppression, type); return retval;})
		 AgastFeatureDetector_create(threshold::int, nonmaxSuppression::bool, type::AgastFeatureDetector_DetectorType) -> ( retval::Ptr<AgastFeatureDetector> ) 
	 GFTTDetector_create
	 .method("jlopencv_cv_GFTTDetector_create",  [](int &maxCorners, double &qualityLevel, double &minDistance, int &blockSize, bool &useHarrisDetector, double &k) { auto retval = cv::GFTTDetector::create(maxCorners, qualityLevel, minDistance, blockSize, useHarrisDetector, k); return retval;})
		 GFTTDetector_create(maxCorners::int, qualityLevel::double, minDistance::double, blockSize::int, useHarrisDetector::bool, k::double) -> ( retval::Ptr<GFTTDetector> ) 
	 GFTTDetector_create
	 .method("jlopencv_cv_GFTTDetector_create",  [](int &maxCorners, double &qualityLevel, double &minDistance, int &blockSize, int &gradiantSize, bool &useHarrisDetector, double &k) { auto retval = cv::GFTTDetector::create(maxCorners, qualityLevel, minDistance, blockSize, gradiantSize, useHarrisDetector, k); return retval;})
		 GFTTDetector_create(maxCorners::int, qualityLevel::double, minDistance::double, blockSize::int, gradiantSize::int, useHarrisDetector::bool, k::double) -> ( retval::Ptr<GFTTDetector> ) 
	 SimpleBlobDetector_create
	 .method("jlopencv_cv_SimpleBlobDetector_create",  [](SimpleBlobDetector_Params &parameters) { auto retval = cv::SimpleBlobDetector::create(parameters); return retval;})
		 SimpleBlobDetector_create(parameters::SimpleBlobDetector_Params) -> ( retval::Ptr<SimpleBlobDetector> ) 
	 KAZE_create
	 .method("jlopencv_cv_KAZE_create",  [](bool &extended, bool &upright, float &threshold, int &nOctaves, int &nOctaveLayers, KAZE_DiffusivityType &diffusivity) { auto retval = cv::KAZE::create(extended, upright, threshold, nOctaves, nOctaveLayers, diffusivity); return retval;})
		 KAZE_create(extended::bool, upright::bool, threshold::float, nOctaves::int, nOctaveLayers::int, diffusivity::KAZE_DiffusivityType) -> ( retval::Ptr<KAZE> ) 
	 AKAZE_create
	 .method("jlopencv_cv_AKAZE_create",  [](AKAZE_DescriptorType &descriptor_type, int &descriptor_size, int &descriptor_channels, float &threshold, int &nOctaves, int &nOctaveLayers, KAZE_DiffusivityType &diffusivity) { auto retval = cv::AKAZE::create(descriptor_type, descriptor_size, descriptor_channels, threshold, nOctaves, nOctaveLayers, diffusivity); return retval;})
		 AKAZE_create(descriptor_type::AKAZE_DescriptorType, descriptor_size::int, descriptor_channels::int, threshold::float, nOctaves::int, nOctaveLayers::int, diffusivity::KAZE_DiffusivityType) -> ( retval::Ptr<AKAZE> ) 
	 DescriptorMatcher_create
	 .method("jlopencv_cv_DescriptorMatcher_create",  [](String &descriptorMatcherType) { auto retval = cv::DescriptorMatcher::create(descriptorMatcherType); return retval;})
		 DescriptorMatcher_create(descriptorMatcherType::String) -> ( retval::Ptr<DescriptorMatcher> ) 
	 DescriptorMatcher_create
	 .method("jlopencv_cv_DescriptorMatcher_create",  [](DescriptorMatcher_MatcherType &matcherType) { auto retval = cv::DescriptorMatcher::create(matcherType); return retval;})
		 DescriptorMatcher_create(matcherType::DescriptorMatcher_MatcherType) -> ( retval::Ptr<DescriptorMatcher> ) 
	 BFMatcher_create
	 .method("jlopencv_cv_BFMatcher_create",  [](int &normType, bool &crossCheck) { auto retval = cv::BFMatcher::create(normType, crossCheck); return retval;})
		 BFMatcher_create(normType::int, crossCheck::bool) -> ( retval::Ptr<BFMatcher> ) 
	 FlannBasedMatcher_create
	 .method("jlopencv_cv_FlannBasedMatcher_create",  []() { auto retval = cv::FlannBasedMatcher::create(); return retval;})
		 FlannBasedMatcher_create() -> ( retval::Ptr<FlannBasedMatcher> ) 
	 FarnebackOpticalFlow_create
	 .method("jlopencv_cv_FarnebackOpticalFlow_create",  [](int &numLevels, double &pyrScale, bool &fastPyramids, int &winSize, int &numIters, int &polyN, double &polySigma, int &flags) { auto retval = cv::FarnebackOpticalFlow::create(numLevels, pyrScale, fastPyramids, winSize, numIters, polyN, polySigma, flags); return retval;})
		 FarnebackOpticalFlow_create(numLevels::int, pyrScale::double, fastPyramids::bool, winSize::int, numIters::int, polyN::int, polySigma::double, flags::int) -> ( retval::Ptr<FarnebackOpticalFlow> ) 
	 VariationalRefinement_create
	 .method("jlopencv_cv_VariationalRefinement_create",  []() { auto retval = cv::VariationalRefinement::create(); return retval;})
		 VariationalRefinement_create() -> ( retval::Ptr<VariationalRefinement> ) 
	 DISOpticalFlow_create
	 .method("jlopencv_cv_DISOpticalFlow_create",  [](int &preset) { auto retval = cv::DISOpticalFlow::create(preset); return retval;})
		 DISOpticalFlow_create(preset::int) -> ( retval::Ptr<DISOpticalFlow> ) 
	 SparsePyrLKOpticalFlow_create
	 .method("jlopencv_cv_SparsePyrLKOpticalFlow_create",  [](Size &winSize, int &maxLevel, TermCriteria &crit, int &flags, double &minEigThreshold) { auto retval = cv::SparsePyrLKOpticalFlow::create(winSize, maxLevel, crit, flags, minEigThreshold); return retval;})
		 SparsePyrLKOpticalFlow_create(winSize::Size, maxLevel::int, crit::TermCriteria, flags::int, minEigThreshold::double) -> ( retval::Ptr<SparsePyrLKOpticalFlow> ) 
	 undistort
	 .method("jlopencv_cv_undistort",  [](Mat &src, Mat &cameraMatrix, Mat &distCoeffs, Mat &dst, Mat &newCameraMatrix) { cv::undistort(src, dst, cameraMatrix, distCoeffs, newCameraMatrix); return dst;})
		 undistort(src::Mat, cameraMatrix::Mat, distCoeffs::Mat, dst::Mat, newCameraMatrix::Mat) -> ( dst::Mat ) 
	 undistort
	 .method("jlopencv_cv_undistort",  [](UMat &src, UMat &cameraMatrix, UMat &distCoeffs, UMat &dst, UMat &newCameraMatrix) { cv::undistort(src, dst, cameraMatrix, distCoeffs, newCameraMatrix); return dst;})
		 undistort(src::UMat, cameraMatrix::UMat, distCoeffs::UMat, dst::UMat, newCameraMatrix::UMat) -> ( dst::UMat ) 
	 initUndistortRectifyMap
	 .method("jlopencv_cv_initUndistortRectifyMap",  [](Mat &cameraMatrix, Mat &distCoeffs, Mat &R, Mat &newCameraMatrix, Size &size, int &m1type, Mat &map1, Mat &map2) { cv::initUndistortRectifyMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type, map1, map2); return make_tuple<Mat,Mat>(map1,map2);})
		 initUndistortRectifyMap(cameraMatrix::Mat, distCoeffs::Mat, R::Mat, newCameraMatrix::Mat, size::Size, m1type::int; map1::Mat, map2::Mat) -> ( map1::Mat, map2::Mat ) 
	 initUndistortRectifyMap
	 .method("jlopencv_cv_initUndistortRectifyMap",  [](UMat &cameraMatrix, UMat &distCoeffs, UMat &R, UMat &newCameraMatrix, Size &size, int &m1type, UMat &map1, UMat &map2) { cv::initUndistortRectifyMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type, map1, map2); return make_tuple<UMat,UMat>(map1,map2);})
		 initUndistortRectifyMap(cameraMatrix::UMat, distCoeffs::UMat, R::UMat, newCameraMatrix::UMat, size::Size, m1type::int; map1::UMat, map2::UMat) -> ( map1::UMat, map2::UMat ) 
	 getDefaultNewCameraMatrix
	 .method("jlopencv_cv_getDefaultNewCameraMatrix",  [](Mat &cameraMatrix, Size &imgsize, bool &centerPrincipalPoint) { auto retval = cv::getDefaultNewCameraMatrix(cameraMatrix, imgsize, centerPrincipalPoint); return retval;})
		 getDefaultNewCameraMatrix(cameraMatrix::Mat, imgsize::Size, centerPrincipalPoint::bool) -> ( retval::Mat ) 
	 getDefaultNewCameraMatrix
	 .method("jlopencv_cv_getDefaultNewCameraMatrix",  [](UMat &cameraMatrix, Size &imgsize, bool &centerPrincipalPoint) { auto retval = cv::getDefaultNewCameraMatrix(cameraMatrix, imgsize, centerPrincipalPoint); return retval;})
		 getDefaultNewCameraMatrix(cameraMatrix::UMat, imgsize::Size, centerPrincipalPoint::bool) -> ( retval::Mat ) 
	 undistortPoints
	 .method("jlopencv_cv_undistortPoints",  [](Mat &src, Mat &cameraMatrix, Mat &distCoeffs, Mat &dst, Mat &R, Mat &P) { cv::undistortPoints(src, dst, cameraMatrix, distCoeffs, R, P); return dst;})
		 undistortPoints(src::Mat, cameraMatrix::Mat, distCoeffs::Mat, dst::Mat, R::Mat, P::Mat) -> ( dst::Mat ) 
	 undistortPoints
	 .method("jlopencv_cv_undistortPoints",  [](UMat &src, UMat &cameraMatrix, UMat &distCoeffs, UMat &dst, UMat &R, UMat &P) { cv::undistortPoints(src, dst, cameraMatrix, distCoeffs, R, P); return dst;})
		 undistortPoints(src::UMat, cameraMatrix::UMat, distCoeffs::UMat, dst::UMat, R::UMat, P::UMat) -> ( dst::UMat ) 
	 undistortPointsIter
	 .method("jlopencv_cv_undistortPointsIter",  [](Mat &src, Mat &cameraMatrix, Mat &distCoeffs, Mat &R, Mat &P, TermCriteria &criteria, Mat &dst) { cv::undistortPoints(src, dst, cameraMatrix, distCoeffs, R, P, criteria); return dst;})
		 undistortPointsIter(src::Mat, cameraMatrix::Mat, distCoeffs::Mat, R::Mat, P::Mat, criteria::TermCriteria; dst::Mat) -> ( dst::Mat ) 
	 undistortPointsIter
	 .method("jlopencv_cv_undistortPointsIter",  [](UMat &src, UMat &cameraMatrix, UMat &distCoeffs, UMat &R, UMat &P, TermCriteria &criteria, UMat &dst) { cv::undistortPoints(src, dst, cameraMatrix, distCoeffs, R, P, criteria); return dst;})
		 undistortPointsIter(src::UMat, cameraMatrix::UMat, distCoeffs::UMat, R::UMat, P::UMat, criteria::TermCriteria; dst::UMat) -> ( dst::UMat ) 
	 drawKeypoints
	 .method("jlopencv_cv_drawKeypoints",  [](Mat &image, vector<KeyPoint> &keypoints, Mat &outImage, Scalar &color, DrawMatchesFlags &flags) { cv::drawKeypoints(image, keypoints, outImage, color, flags); return outImage;})
		 drawKeypoints(image::Mat, keypoints::vector<KeyPoint>, outImage::Mat, color::Scalar, flags::DrawMatchesFlags) -> ( outImage::Mat ) 
	 drawKeypoints
	 .method("jlopencv_cv_drawKeypoints",  [](UMat &image, vector<KeyPoint> &keypoints, UMat &outImage, Scalar &color, DrawMatchesFlags &flags) { cv::drawKeypoints(image, keypoints, outImage, color, flags); return outImage;})
		 drawKeypoints(image::UMat, keypoints::vector<KeyPoint>, outImage::UMat, color::Scalar, flags::DrawMatchesFlags) -> ( outImage::UMat ) 
	 drawMatches
	 .method("jlopencv_cv_drawMatches",  [](Mat &img1, vector<KeyPoint> &keypoints1, Mat &img2, vector<KeyPoint> &keypoints2, vector<DMatch> &matches1to2, Mat &outImg, Scalar &matchColor, Scalar &singlePointColor, vector<char> &matchesMask, DrawMatchesFlags &flags) { cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchColor, singlePointColor, matchesMask, flags); return outImg;})
		 drawMatches(img1::Mat, keypoints1::vector<KeyPoint>, img2::Mat, keypoints2::vector<KeyPoint>, matches1to2::vector<DMatch>, outImg::Mat, matchColor::Scalar, singlePointColor::Scalar, matchesMask::vector<char>, flags::DrawMatchesFlags) -> ( outImg::Mat ) 
	 drawMatches
	 .method("jlopencv_cv_drawMatches",  [](UMat &img1, vector<KeyPoint> &keypoints1, UMat &img2, vector<KeyPoint> &keypoints2, vector<DMatch> &matches1to2, UMat &outImg, Scalar &matchColor, Scalar &singlePointColor, vector<char> &matchesMask, DrawMatchesFlags &flags) { cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchColor, singlePointColor, matchesMask, flags); return outImg;})
		 drawMatches(img1::UMat, keypoints1::vector<KeyPoint>, img2::UMat, keypoints2::vector<KeyPoint>, matches1to2::vector<DMatch>, outImg::UMat, matchColor::Scalar, singlePointColor::Scalar, matchesMask::vector<char>, flags::DrawMatchesFlags) -> ( outImg::UMat ) 
	 drawMatchesKnn
	 .method("jlopencv_cv_drawMatchesKnn",  [](Mat &img1, vector<KeyPoint> &keypoints1, Mat &img2, vector<KeyPoint> &keypoints2, vector<vector<DMatch>> &matches1to2, Mat &outImg, Scalar &matchColor, Scalar &singlePointColor, vector<vector<char>> &matchesMask, DrawMatchesFlags &flags) { cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchColor, singlePointColor, matchesMask, flags); return outImg;})
		 drawMatchesKnn(img1::Mat, keypoints1::vector<KeyPoint>, img2::Mat, keypoints2::vector<KeyPoint>, matches1to2::vector<vector<DMatch>>, outImg::Mat, matchColor::Scalar, singlePointColor::Scalar, matchesMask::vector<vector<char>>, flags::DrawMatchesFlags) -> ( outImg::Mat ) 
	 drawMatchesKnn
	 .method("jlopencv_cv_drawMatchesKnn",  [](UMat &img1, vector<KeyPoint> &keypoints1, UMat &img2, vector<KeyPoint> &keypoints2, vector<vector<DMatch>> &matches1to2, UMat &outImg, Scalar &matchColor, Scalar &singlePointColor, vector<vector<char>> &matchesMask, DrawMatchesFlags &flags) { cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchColor, singlePointColor, matchesMask, flags); return outImg;})
		 drawMatchesKnn(img1::UMat, keypoints1::vector<KeyPoint>, img2::UMat, keypoints2::vector<KeyPoint>, matches1to2::vector<vector<DMatch>>, outImg::UMat, matchColor::Scalar, singlePointColor::Scalar, matchesMask::vector<vector<char>>, flags::DrawMatchesFlags) -> ( outImg::UMat ) 
	 CamShift
	 .method("jlopencv_cv_CamShift",  [](Mat &probImage, Rect &window, TermCriteria &criteria) { auto retval = cv::CamShift(probImage, window, criteria); return make_tuple<RotatedRect,Rect>(retval,window);})
		 CamShift(probImage::Mat, window::Rect, criteria::TermCriteria) -> ( retval::RotatedRect, window::Rect ) 
	 CamShift
	 .method("jlopencv_cv_CamShift",  [](UMat &probImage, Rect &window, TermCriteria &criteria) { auto retval = cv::CamShift(probImage, window, criteria); return make_tuple<RotatedRect,Rect>(retval,window);})
		 CamShift(probImage::UMat, window::Rect, criteria::TermCriteria) -> ( retval::RotatedRect, window::Rect ) 
	 meanShift
	 .method("jlopencv_cv_meanShift",  [](Mat &probImage, Rect &window, TermCriteria &criteria) { auto retval = cv::meanShift(probImage, window, criteria); return make_tuple<int,Rect>(retval,window);})
		 meanShift(probImage::Mat, window::Rect, criteria::TermCriteria) -> ( retval::int, window::Rect ) 
	 meanShift
	 .method("jlopencv_cv_meanShift",  [](UMat &probImage, Rect &window, TermCriteria &criteria) { auto retval = cv::meanShift(probImage, window, criteria); return make_tuple<int,Rect>(retval,window);})
		 meanShift(probImage::UMat, window::Rect, criteria::TermCriteria) -> ( retval::int, window::Rect ) 
	 buildOpticalFlowPyramid
	 .method("jlopencv_cv_buildOpticalFlowPyramid",  [](Mat &img, Size &winSize, int &maxLevel, bool &withDerivatives, int &pyrBorder, int &derivBorder, bool &tryReuseInputImage) {vector<Mat> pyramid; auto retval = cv::buildOpticalFlowPyramid(img, pyramid, winSize, maxLevel, withDerivatives, pyrBorder, derivBorder, tryReuseInputImage); return make_tuple<int,vector<Mat>>(retval,pyramid);})
		 buildOpticalFlowPyramid(img::Mat, winSize::Size, maxLevel::int, withDerivatives::bool, pyrBorder::int, derivBorder::int, tryReuseInputImage::bool) -> ( retval::int, pyramid::vector<Mat> ) 
	 buildOpticalFlowPyramid
	 .method("jlopencv_cv_buildOpticalFlowPyramid",  [](UMat &img, Size &winSize, int &maxLevel, bool &withDerivatives, int &pyrBorder, int &derivBorder, bool &tryReuseInputImage) {vector<UMat> pyramid; auto retval = cv::buildOpticalFlowPyramid(img, pyramid, winSize, maxLevel, withDerivatives, pyrBorder, derivBorder, tryReuseInputImage); return make_tuple<int,vector<UMat>>(retval,pyramid);})
		 buildOpticalFlowPyramid(img::UMat, winSize::Size, maxLevel::int, withDerivatives::bool, pyrBorder::int, derivBorder::int, tryReuseInputImage::bool) -> ( retval::int, pyramid::vector<UMat> ) 
	 calcOpticalFlowPyrLK
	 .method("jlopencv_cv_calcOpticalFlowPyrLK",  [](Mat &prevImg, Mat &nextImg, Mat &prevPts, Mat &nextPts, Mat &status, Mat &err, Size &winSize, int &maxLevel, TermCriteria &criteria, int &flags, double &minEigThreshold) { cv::calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, nextPts, status, err, winSize, maxLevel, criteria, flags, minEigThreshold); return make_tuple<Mat,Mat,Mat>(nextPts,status,err);})
		 calcOpticalFlowPyrLK(prevImg::Mat, nextImg::Mat, prevPts::Mat, nextPts::Mat, status::Mat, err::Mat, winSize::Size, maxLevel::int, criteria::TermCriteria, flags::int, minEigThreshold::double) -> ( nextPts::Mat, status::Mat, err::Mat ) 
	 calcOpticalFlowPyrLK
	 .method("jlopencv_cv_calcOpticalFlowPyrLK",  [](UMat &prevImg, UMat &nextImg, UMat &prevPts, UMat &nextPts, UMat &status, UMat &err, Size &winSize, int &maxLevel, TermCriteria &criteria, int &flags, double &minEigThreshold) { cv::calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, nextPts, status, err, winSize, maxLevel, criteria, flags, minEigThreshold); return make_tuple<UMat,UMat,UMat>(nextPts,status,err);})
		 calcOpticalFlowPyrLK(prevImg::UMat, nextImg::UMat, prevPts::UMat, nextPts::UMat, status::UMat, err::UMat, winSize::Size, maxLevel::int, criteria::TermCriteria, flags::int, minEigThreshold::double) -> ( nextPts::UMat, status::UMat, err::UMat ) 
	 calcOpticalFlowFarneback
	 .method("jlopencv_cv_calcOpticalFlowFarneback",  [](Mat &prev, Mat &next, Mat &flow, double &pyr_scale, int &levels, int &winsize, int &iterations, int &poly_n, double &poly_sigma, int &flags) { cv::calcOpticalFlowFarneback(prev, next, flow, pyr_scale, levels, winsize, iterations, poly_n, poly_sigma, flags); return flow;})
		 calcOpticalFlowFarneback(prev::Mat, next::Mat, flow::Mat, pyr_scale::double, levels::int, winsize::int, iterations::int, poly_n::int, poly_sigma::double, flags::int) -> ( flow::Mat ) 
	 calcOpticalFlowFarneback
	 .method("jlopencv_cv_calcOpticalFlowFarneback",  [](UMat &prev, UMat &next, UMat &flow, double &pyr_scale, int &levels, int &winsize, int &iterations, int &poly_n, double &poly_sigma, int &flags) { cv::calcOpticalFlowFarneback(prev, next, flow, pyr_scale, levels, winsize, iterations, poly_n, poly_sigma, flags); return flow;})
		 calcOpticalFlowFarneback(prev::UMat, next::UMat, flow::UMat, pyr_scale::double, levels::int, winsize::int, iterations::int, poly_n::int, poly_sigma::double, flags::int) -> ( flow::UMat ) 
	 computeECC
	 .method("jlopencv_cv_computeECC",  [](Mat &templateImage, Mat &inputImage, Mat &inputMask) { auto retval = cv::computeECC(templateImage, inputImage, inputMask); return retval;})
		 computeECC(templateImage::Mat, inputImage::Mat, inputMask::Mat) -> ( retval::double ) 
	 computeECC
	 .method("jlopencv_cv_computeECC",  [](UMat &templateImage, UMat &inputImage, UMat &inputMask) { auto retval = cv::computeECC(templateImage, inputImage, inputMask); return retval;})
		 computeECC(templateImage::UMat, inputImage::UMat, inputMask::UMat) -> ( retval::double ) 
	 findTransformECC
	 .method("jlopencv_cv_findTransformECC",  [](Mat &templateImage, Mat &inputImage, Mat &warpMatrix, int &motionType, TermCriteria &criteria, Mat &inputMask, int &gaussFiltSize) { auto retval = cv::findTransformECC(templateImage, inputImage, warpMatrix, motionType, criteria, inputMask, gaussFiltSize); return make_tuple<double,Mat>(retval,warpMatrix);})
		 findTransformECC(templateImage::Mat, inputImage::Mat, warpMatrix::Mat, motionType::int, criteria::TermCriteria, inputMask::Mat, gaussFiltSize::int) -> ( retval::double, warpMatrix::Mat ) 
	 findTransformECC
	 .method("jlopencv_cv_findTransformECC",  [](UMat &templateImage, UMat &inputImage, UMat &warpMatrix, int &motionType, TermCriteria &criteria, UMat &inputMask, int &gaussFiltSize) { auto retval = cv::findTransformECC(templateImage, inputImage, warpMatrix, motionType, criteria, inputMask, gaussFiltSize); return make_tuple<double,UMat>(retval,warpMatrix);})
		 findTransformECC(templateImage::UMat, inputImage::UMat, warpMatrix::UMat, motionType::int, criteria::TermCriteria, inputMask::UMat, gaussFiltSize::int) -> ( retval::double, warpMatrix::UMat ) 
	 readOpticalFlow
	 .method("jlopencv_cv_readOpticalFlow",  [](String &path) { auto retval = cv::readOpticalFlow(path); return retval;})
		 readOpticalFlow(path::String) -> ( retval::Mat ) 
	 writeOpticalFlow
	 .method("jlopencv_cv_writeOpticalFlow",  [](String &path, Mat &flow) { auto retval = cv::writeOpticalFlow(path, flow); return retval;})
		 writeOpticalFlow(path::String, flow::Mat) -> ( retval::bool ) 
	 writeOpticalFlow
	 .method("jlopencv_cv_writeOpticalFlow",  [](String &path, UMat &flow) { auto retval = cv::writeOpticalFlow(path, flow); return retval;})
		 writeOpticalFlow(path::String, flow::UMat) -> ( retval::bool ) 
	 createBackgroundSubtractorMOG2
	 .method("jlopencv_cv_createBackgroundSubtractorMOG2",  [](int &history, double &varThreshold, bool &detectShadows) { auto retval = cv::createBackgroundSubtractorMOG2(history, varThreshold, detectShadows); return retval;})
		 createBackgroundSubtractorMOG2(history::int, varThreshold::double, detectShadows::bool) -> ( retval::Ptr<BackgroundSubtractorMOG2> ) 
	 createBackgroundSubtractorKNN
	 .method("jlopencv_cv_createBackgroundSubtractorKNN",  [](int &history, double &dist2Threshold, bool &detectShadows) { auto retval = cv::createBackgroundSubtractorKNN(history, dist2Threshold, detectShadows); return retval;})
		 createBackgroundSubtractorKNN(history::int, dist2Threshold::double, detectShadows::bool) -> ( retval::Ptr<BackgroundSubtractorKNN> ) 
	 groupRectangles
	 .method("jlopencv_cv_groupRectangles",  [](vector<Rect> &rectList, int &groupThreshold, double &eps) {vector<int> weights; cv::groupRectangles(rectList, weights, groupThreshold, eps); return make_tuple<vector<Rect>,vector<int>>(rectList,weights);})
		 groupRectangles(rectList::vector<Rect>, groupThreshold::int, eps::double) -> ( rectList::vector<Rect>, weights::vector<int> ) 
	 CascadeClassifier_convert
	 .method("jlopencv_cv_CascadeClassifier_convert",  [](String &oldcascade, String &newcascade) { auto retval = cv::CascadeClassifier::convert(oldcascade, newcascade); return retval;})
		 CascadeClassifier_convert(oldcascade::String, newcascade::String) -> ( retval::bool ) 
	 HOGDescriptor_getDefaultPeopleDetector
	 .method("jlopencv_cv_HOGDescriptor_getDefaultPeopleDetector",  []() { auto retval = cv::HOGDescriptor::getDefaultPeopleDetector(); return retval;})
		 HOGDescriptor_getDefaultPeopleDetector() -> ( retval::std::vector<float> ) 
	 HOGDescriptor_getDaimlerPeopleDetector
	 .method("jlopencv_cv_HOGDescriptor_getDaimlerPeopleDetector",  []() { auto retval = cv::HOGDescriptor::getDaimlerPeopleDetector(); return retval;})
		 HOGDescriptor_getDaimlerPeopleDetector() -> ( retval::std::vector<float> ) 
	 imread
	 .method("jlopencv_cv_imread",  [](String &filename, int &flags) { auto retval = cv::imread(filename, flags); return retval;})
		 imread(filename::String, flags::int) -> ( retval::Mat ) 
	 imreadmulti
	 .method("jlopencv_cv_imreadmulti",  [](String &filename, int &flags) {vector<Mat> mats; auto retval = cv::imreadmulti(filename, mats, flags); return make_tuple<bool,vector<Mat>>(retval,mats);})
		 imreadmulti(filename::String, flags::int) -> ( retval::bool, mats::vector<Mat> ) 
	 imreadmulti
	 .method("jlopencv_cv_imreadmulti",  [](String &filename, int &flags) {vector<Mat> mats; auto retval = cv::imreadmulti(filename, mats, flags); return make_tuple<bool,vector<Mat>>(retval,mats);})
		 imreadmulti(filename::String, flags::int) -> ( retval::bool, mats::vector<Mat> ) 
	 imwrite
	 .method("jlopencv_cv_imwrite",  [](String &filename, Mat &img, vector<int> &params) { auto retval = cv::imwrite(filename, img, params); return retval;})
		 imwrite(filename::String, img::Mat, params::vector<int>) -> ( retval::bool ) 
	 imwrite
	 .method("jlopencv_cv_imwrite",  [](String &filename, UMat &img, vector<int> &params) { auto retval = cv::imwrite(filename, img, params); return retval;})
		 imwrite(filename::String, img::UMat, params::vector<int>) -> ( retval::bool ) 
	 imdecode
	 .method("jlopencv_cv_imdecode",  [](Mat &buf, int &flags) { auto retval = cv::imdecode(buf, flags); return retval;})
		 imdecode(buf::Mat, flags::int) -> ( retval::Mat ) 
	 imdecode
	 .method("jlopencv_cv_imdecode",  [](UMat &buf, int &flags) { auto retval = cv::imdecode(buf, flags); return retval;})
		 imdecode(buf::UMat, flags::int) -> ( retval::Mat ) 
	 imencode
	 .method("jlopencv_cv_imencode",  [](String &ext, Mat &img, vector<int> &params) {vector<uchar> buf; auto retval = cv::imencode(ext, img, buf, params); return make_tuple<bool,vector<uchar>>(retval,buf);})
		 imencode(ext::String, img::Mat, params::vector<int>) -> ( retval::bool, buf::vector<uchar> ) 
	 imencode
	 .method("jlopencv_cv_imencode",  [](String &ext, UMat &img, vector<int> &params) {vector<uchar> buf; auto retval = cv::imencode(ext, img, buf, params); return make_tuple<bool,vector<uchar>>(retval,buf);})
		 imencode(ext::String, img::UMat, params::vector<int>) -> ( retval::bool, buf::vector<uchar> ) 
	 haveImageReader
	 .method("jlopencv_cv_haveImageReader",  [](String &filename) { auto retval = cv::haveImageReader(filename); return retval;})
		 haveImageReader(filename::String) -> ( retval::bool ) 
	 haveImageWriter
	 .method("jlopencv_cv_haveImageWriter",  [](String &filename) { auto retval = cv::haveImageWriter(filename); return retval;})
		 haveImageWriter(filename::String) -> ( retval::bool ) 
	 VideoWriter_fourcc
	 .method("jlopencv_cv_VideoWriter_fourcc",  [](char &c1, char &c2, char &c3, char &c4) { auto retval = cv::VideoWriter::fourcc(c1, c2, c3, c4); return retval;})
		 VideoWriter_fourcc(c1::char, c2::char, c3::char, c4::char) -> ( retval::int ) 
	 namedWindow
	 .method("jlopencv_cv_namedWindow",  [](String &winname, int &flags) { cv::namedWindow(winname, flags); ;})
		 namedWindow(winname::String, flags::int) -> nothing
	 destroyWindow
	 .method("jlopencv_cv_destroyWindow",  [](String &winname) { cv::destroyWindow(winname); ;})
		 destroyWindow(winname::String) -> nothing
	 destroyAllWindows
	 .method("jlopencv_cv_destroyAllWindows",  []() { cv::destroyAllWindows(); ;})
		 destroyAllWindows() -> nothing
	 startWindowThread
	 .method("jlopencv_cv_startWindowThread",  []() { auto retval = cv::startWindowThread(); return retval;})
		 startWindowThread() -> ( retval::int ) 
	 waitKeyEx
	 .method("jlopencv_cv_waitKeyEx",  [](int &delay) { auto retval = cv::waitKeyEx(delay); return retval;})
		 waitKeyEx(delay::int) -> ( retval::int ) 
	 waitKey
	 .method("jlopencv_cv_waitKey",  [](int &delay) { auto retval = cv::waitKey(delay); return retval;})
		 waitKey(delay::int) -> ( retval::int ) 
	 imshow
	 .method("jlopencv_cv_imshow",  [](String &winname, Mat &mat) { cv::imshow(winname, mat); ;})
		 imshow(winname::String, mat::Mat) -> nothing
	 imshow
	 .method("jlopencv_cv_imshow",  [](String &winname, UMat &mat) { cv::imshow(winname, mat); ;})
		 imshow(winname::String, mat::UMat) -> nothing
	 resizeWindow
	 .method("jlopencv_cv_resizeWindow",  [](String &winname, int &width, int &height) { cv::resizeWindow(winname, width, height); ;})
		 resizeWindow(winname::String, width::int, height::int) -> nothing
	 resizeWindow
	 .method("jlopencv_cv_resizeWindow",  [](String &winname, Size &size) { cv::resizeWindow(winname, size); ;})
		 resizeWindow(winname::String, size::Size) -> nothing
	 moveWindow
	 .method("jlopencv_cv_moveWindow",  [](String &winname, int &x, int &y) { cv::moveWindow(winname, x, y); ;})
		 moveWindow(winname::String, x::int, y::int) -> nothing
	 setWindowProperty
	 .method("jlopencv_cv_setWindowProperty",  [](String &winname, int &prop_id, double &prop_value) { cv::setWindowProperty(winname, prop_id, prop_value); ;})
		 setWindowProperty(winname::String, prop_id::int, prop_value::double) -> nothing
	 setWindowTitle
	 .method("jlopencv_cv_setWindowTitle",  [](String &winname, String &title) { cv::setWindowTitle(winname, title); ;})
		 setWindowTitle(winname::String, title::String) -> nothing
	 getWindowProperty
	 .method("jlopencv_cv_getWindowProperty",  [](String &winname, int &prop_id) { auto retval = cv::getWindowProperty(winname, prop_id); return retval;})
		 getWindowProperty(winname::String, prop_id::int) -> ( retval::double ) 
	 getWindowImageRect
	 .method("jlopencv_cv_getWindowImageRect",  [](String &winname) { auto retval = cv::getWindowImageRect(winname); return retval;})
		 getWindowImageRect(winname::String) -> ( retval::Rect ) 
	 selectROI
	 .method("jlopencv_cv_selectROI",  [](String &windowName, Mat &img, bool &showCrosshair, bool &fromCenter) { auto retval = cv::selectROI(windowName, img, showCrosshair, fromCenter); return retval;})
		 selectROI(windowName::String, img::Mat, showCrosshair::bool, fromCenter::bool) -> ( retval::Rect ) 
	 selectROI
	 .method("jlopencv_cv_selectROI",  [](String &windowName, UMat &img, bool &showCrosshair, bool &fromCenter) { auto retval = cv::selectROI(windowName, img, showCrosshair, fromCenter); return retval;})
		 selectROI(windowName::String, img::UMat, showCrosshair::bool, fromCenter::bool) -> ( retval::Rect ) 
	 selectROI
	 .method("jlopencv_cv_selectROI",  [](Mat &img, bool &showCrosshair, bool &fromCenter) { auto retval = cv::selectROI(img, showCrosshair, fromCenter); return retval;})
		 selectROI(img::Mat, showCrosshair::bool, fromCenter::bool) -> ( retval::Rect ) 
	 selectROI
	 .method("jlopencv_cv_selectROI",  [](UMat &img, bool &showCrosshair, bool &fromCenter) { auto retval = cv::selectROI(img, showCrosshair, fromCenter); return retval;})
		 selectROI(img::UMat, showCrosshair::bool, fromCenter::bool) -> ( retval::Rect ) 
	 selectROIs
	 .method("jlopencv_cv_selectROIs",  [](String &windowName, Mat &img, bool &showCrosshair, bool &fromCenter) {vector<Rect> boundingBoxes; cv::selectROIs(windowName, img, boundingBoxes, showCrosshair, fromCenter); return boundingBoxes;})
		 selectROIs(windowName::String, img::Mat, showCrosshair::bool, fromCenter::bool) -> ( boundingBoxes::vector<Rect> ) 
	 selectROIs
	 .method("jlopencv_cv_selectROIs",  [](String &windowName, UMat &img, bool &showCrosshair, bool &fromCenter) {vector<Rect> boundingBoxes; cv::selectROIs(windowName, img, boundingBoxes, showCrosshair, fromCenter); return boundingBoxes;})
		 selectROIs(windowName::String, img::UMat, showCrosshair::bool, fromCenter::bool) -> ( boundingBoxes::vector<Rect> ) 
	 getTrackbarPos
	 .method("jlopencv_cv_getTrackbarPos",  [](String &trackbarname, String &winname) { auto retval = cv::getTrackbarPos(trackbarname, winname); return retval;})
		 getTrackbarPos(trackbarname::String, winname::String) -> ( retval::int ) 
	 setTrackbarPos
	 .method("jlopencv_cv_setTrackbarPos",  [](String &trackbarname, String &winname, int &pos) { cv::setTrackbarPos(trackbarname, winname, pos); ;})
		 setTrackbarPos(trackbarname::String, winname::String, pos::int) -> nothing
	 setTrackbarMax
	 .method("jlopencv_cv_setTrackbarMax",  [](String &trackbarname, String &winname, int &maxval) { cv::setTrackbarMax(trackbarname, winname, maxval); ;})
		 setTrackbarMax(trackbarname::String, winname::String, maxval::int) -> nothing
	 setTrackbarMin
	 .method("jlopencv_cv_setTrackbarMin",  [](String &trackbarname, String &winname, int &minval) { cv::setTrackbarMin(trackbarname, winname, minval); ;})
		 setTrackbarMin(trackbarname::String, winname::String, minval::int) -> nothing
	 addText
	 .method("jlopencv_cv_addText",  [](Mat &img, String &text, Point &org, String &nameFont, int &pointSize, Scalar &color, int &weight, int &style, int &spacing) { cv::addText(img, text, org, nameFont, pointSize, color, weight, style, spacing); ;})
		 addText(img::Mat, text::String, org::Point, nameFont::String, pointSize::int, color::Scalar, weight::int, style::int, spacing::int) -> nothing
	 addText
	 .method("jlopencv_cv_addText",  [](Mat &img, String &text, Point &org, String &nameFont, int &pointSize, Scalar &color, int &weight, int &style, int &spacing) { cv::addText(img, text, org, nameFont, pointSize, color, weight, style, spacing); ;})
		 addText(img::Mat, text::String, org::Point, nameFont::String, pointSize::int, color::Scalar, weight::int, style::int, spacing::int) -> nothing
	 displayOverlay
	 .method("jlopencv_cv_displayOverlay",  [](String &winname, String &text, int &delayms) { cv::displayOverlay(winname, text, delayms); ;})
		 displayOverlay(winname::String, text::String, delayms::int) -> nothing
	 displayStatusBar
	 .method("jlopencv_cv_displayStatusBar",  [](String &winname, String &text, int &delayms) { cv::displayStatusBar(winname, text, delayms); ;})
		 displayStatusBar(winname::String, text::String, delayms::int) -> nothing


	 SORT_EVERY_ROW 	 cv::SORT_EVERY_ROW
	 SORT_EVERY_COLUMN 	 cv::SORT_EVERY_COLUMN
	 SORT_ASCENDING 	 cv::SORT_ASCENDING
	 SORT_DESCENDING 	 cv::SORT_DESCENDING
	 COVAR_SCRAMBLED 	 cv::COVAR_SCRAMBLED
	 COVAR_NORMAL 	 cv::COVAR_NORMAL
	 COVAR_USE_AVG 	 cv::COVAR_USE_AVG
	 COVAR_SCALE 	 cv::COVAR_SCALE
	 COVAR_ROWS 	 cv::COVAR_ROWS
	 COVAR_COLS 	 cv::COVAR_COLS
	 KMEANS_RANDOM_CENTERS 	 cv::KMEANS_RANDOM_CENTERS
	 KMEANS_PP_CENTERS 	 cv::KMEANS_PP_CENTERS
	 KMEANS_USE_INITIAL_LABELS 	 cv::KMEANS_USE_INITIAL_LABELS
	 REDUCE_SUM 	 cv::REDUCE_SUM
	 REDUCE_AVG 	 cv::REDUCE_AVG
	 REDUCE_MAX 	 cv::REDUCE_MAX
	 REDUCE_MIN 	 cv::REDUCE_MIN
	 ROTATE_90_CLOCKWISE 	 cv::ROTATE_90_CLOCKWISE
	 ROTATE_180 	 cv::ROTATE_180
	 ROTATE_90_COUNTERCLOCKWISE 	 cv::ROTATE_90_COUNTERCLOCKWISE
	 PCA_DATA_AS_ROW 	 cv::PCA::DATA_AS_ROW
	 PCA_DATA_AS_COL 	 cv::PCA::DATA_AS_COL
	 PCA_USE_AVG 	 cv::PCA::USE_AVG
	 SVD_MODIFY_A 	 cv::SVD::MODIFY_A
	 SVD_NO_UV 	 cv::SVD::NO_UV
	 SVD_FULL_UV 	 cv::SVD::FULL_UV
	 RNG_UNIFORM 	 cv::RNG::UNIFORM
	 RNG_NORMAL 	 cv::RNG::NORMAL
	 Formatter_FMT_DEFAULT 	 cv::Formatter::FMT_DEFAULT
	 Formatter_FMT_MATLAB 	 cv::Formatter::FMT_MATLAB
	 Formatter_FMT_CSV 	 cv::Formatter::FMT_CSV
	 Formatter_FMT_PYTHON 	 cv::Formatter::FMT_PYTHON
	 Formatter_FMT_NUMPY 	 cv::Formatter::FMT_NUMPY
	 Formatter_FMT_C 	 cv::Formatter::FMT_C
	 Param_INT 	 cv::Param::INT
	 Param_BOOLEAN 	 cv::Param::BOOLEAN
	 Param_REAL 	 cv::Param::REAL
	 Param_STRING 	 cv::Param::STRING
	 Param_MAT 	 cv::Param::MAT
	 Param_MAT_VECTOR 	 cv::Param::MAT_VECTOR
	 Param_ALGORITHM 	 cv::Param::ALGORITHM
	 Param_FLOAT 	 cv::Param::FLOAT
	 Param_UNSIGNED_INT 	 cv::Param::UNSIGNED_INT
	 Param_UINT64 	 cv::Param::UINT64
	 Param_UCHAR 	 cv::Param::UCHAR
	 Param_SCALAR 	 cv::Param::SCALAR
	 ACCESS_READ 	 cv::ACCESS_READ
	 ACCESS_WRITE 	 cv::ACCESS_WRITE
	 ACCESS_RW 	 cv::ACCESS_RW
	 ACCESS_MASK 	 cv::ACCESS_MASK
	 ACCESS_FAST 	 cv::ACCESS_FAST
	 _InputArray_KIND_SHIFT 	 cv::_InputArray::KIND_SHIFT
	 _InputArray_FIXED_TYPE 	 cv::_InputArray::FIXED_TYPE
	 _InputArray_FIXED_SIZE 	 cv::_InputArray::FIXED_SIZE
	 _InputArray_KIND_MASK 	 cv::_InputArray::KIND_MASK
	 _InputArray_NONE 	 cv::_InputArray::NONE
	 _InputArray_MAT 	 cv::_InputArray::MAT
	 _InputArray_MATX 	 cv::_InputArray::MATX
	 _InputArray_STD_VECTOR 	 cv::_InputArray::STD_VECTOR
	 _InputArray_STD_VECTOR_VECTOR 	 cv::_InputArray::STD_VECTOR_VECTOR
	 _InputArray_STD_VECTOR_MAT 	 cv::_InputArray::STD_VECTOR_MAT
	 _InputArray_EXPR 	 cv::_InputArray::EXPR
	 _InputArray_OPENGL_BUFFER 	 cv::_InputArray::OPENGL_BUFFER
	 _InputArray_CUDA_HOST_MEM 	 cv::_InputArray::CUDA_HOST_MEM
	 _InputArray_CUDA_GPU_MAT 	 cv::_InputArray::CUDA_GPU_MAT
	 _InputArray_UMAT 	 cv::_InputArray::UMAT
	 _InputArray_STD_VECTOR_UMAT 	 cv::_InputArray::STD_VECTOR_UMAT
	 _InputArray_STD_BOOL_VECTOR 	 cv::_InputArray::STD_BOOL_VECTOR
	 _InputArray_STD_VECTOR_CUDA_GPU_MAT 	 cv::_InputArray::STD_VECTOR_CUDA_GPU_MAT
	 _InputArray_STD_ARRAY 	 cv::_InputArray::STD_ARRAY
	 _InputArray_STD_ARRAY_MAT 	 cv::_InputArray::STD_ARRAY_MAT
	 _OutputArray_DEPTH_MASK_8U 	 cv::_OutputArray::DEPTH_MASK_8U
	 _OutputArray_DEPTH_MASK_8S 	 cv::_OutputArray::DEPTH_MASK_8S
	 _OutputArray_DEPTH_MASK_16U 	 cv::_OutputArray::DEPTH_MASK_16U
	 _OutputArray_DEPTH_MASK_16S 	 cv::_OutputArray::DEPTH_MASK_16S
	 _OutputArray_DEPTH_MASK_32S 	 cv::_OutputArray::DEPTH_MASK_32S
	 _OutputArray_DEPTH_MASK_32F 	 cv::_OutputArray::DEPTH_MASK_32F
	 _OutputArray_DEPTH_MASK_64F 	 cv::_OutputArray::DEPTH_MASK_64F
	 _OutputArray_DEPTH_MASK_16F 	 cv::_OutputArray::DEPTH_MASK_16F
	 _OutputArray_DEPTH_MASK_ALL 	 cv::_OutputArray::DEPTH_MASK_ALL
	 _OutputArray_DEPTH_MASK_ALL_BUT_8S 	 cv::_OutputArray::DEPTH_MASK_ALL_BUT_8S
	 _OutputArray_DEPTH_MASK_ALL_16F 	 cv::_OutputArray::DEPTH_MASK_ALL_16F
	 _OutputArray_DEPTH_MASK_FLT 	 cv::_OutputArray::DEPTH_MASK_FLT
	 USAGE_DEFAULT 	 cv::USAGE_DEFAULT
	 USAGE_ALLOCATE_HOST_MEMORY 	 cv::USAGE_ALLOCATE_HOST_MEMORY
	 USAGE_ALLOCATE_DEVICE_MEMORY 	 cv::USAGE_ALLOCATE_DEVICE_MEMORY
	 USAGE_ALLOCATE_SHARED_MEMORY 	 cv::USAGE_ALLOCATE_SHARED_MEMORY
	 __UMAT_USAGE_FLAGS_32BIT 	 cv::__UMAT_USAGE_FLAGS_32BIT
	 UMatData_COPY_ON_MAP 	 cv::UMatData::COPY_ON_MAP
	 UMatData_HOST_COPY_OBSOLETE 	 cv::UMatData::HOST_COPY_OBSOLETE
	 UMatData_DEVICE_COPY_OBSOLETE 	 cv::UMatData::DEVICE_COPY_OBSOLETE
	 UMatData_TEMP_UMAT 	 cv::UMatData::TEMP_UMAT
	 UMatData_TEMP_COPIED_UMAT 	 cv::UMatData::TEMP_COPIED_UMAT
	 UMatData_USER_ALLOCATED 	 cv::UMatData::USER_ALLOCATED
	 UMatData_DEVICE_MEM_MAPPED 	 cv::UMatData::DEVICE_MEM_MAPPED
	 UMatData_ASYNC_CLEANUP 	 cv::UMatData::ASYNC_CLEANUP
	 Mat_MAGIC_VAL 	 cv::Mat::MAGIC_VAL
	 Mat_AUTO_STEP 	 cv::Mat::AUTO_STEP
	 Mat_CONTINUOUS_FLAG 	 cv::Mat::CONTINUOUS_FLAG
	 Mat_SUBMATRIX_FLAG 	 cv::Mat::SUBMATRIX_FLAG
	 Mat_MAGIC_MASK 	 cv::Mat::MAGIC_MASK
	 Mat_TYPE_MASK 	 cv::Mat::TYPE_MASK
	 Mat_DEPTH_MASK 	 cv::Mat::DEPTH_MASK
	 UMat_MAGIC_VAL 	 cv::UMat::MAGIC_VAL
	 UMat_AUTO_STEP 	 cv::UMat::AUTO_STEP
	 UMat_CONTINUOUS_FLAG 	 cv::UMat::CONTINUOUS_FLAG
	 UMat_SUBMATRIX_FLAG 	 cv::UMat::SUBMATRIX_FLAG
	 UMat_MAGIC_MASK 	 cv::UMat::MAGIC_MASK
	 UMat_TYPE_MASK 	 cv::UMat::TYPE_MASK
	 UMat_DEPTH_MASK 	 cv::UMat::DEPTH_MASK
	 SparseMat_MAGIC_VAL 	 cv::SparseMat::MAGIC_VAL
	 SparseMat_MAX_DIM 	 cv::SparseMat::MAX_DIM
	 SparseMat_HASH_SCALE 	 cv::SparseMat::HASH_SCALE
	 SparseMat_HASH_BIT 	 cv::SparseMat::HASH_BIT
	 FILTER_SCHARR 	 cv::FILTER_SCHARR
	 MORPH_ERODE 	 cv::MORPH_ERODE
	 MORPH_DILATE 	 cv::MORPH_DILATE
	 MORPH_OPEN 	 cv::MORPH_OPEN
	 MORPH_CLOSE 	 cv::MORPH_CLOSE
	 MORPH_GRADIENT 	 cv::MORPH_GRADIENT
	 MORPH_TOPHAT 	 cv::MORPH_TOPHAT
	 MORPH_BLACKHAT 	 cv::MORPH_BLACKHAT
	 MORPH_HITMISS 	 cv::MORPH_HITMISS
	 MORPH_RECT 	 cv::MORPH_RECT
	 MORPH_CROSS 	 cv::MORPH_CROSS
	 MORPH_ELLIPSE 	 cv::MORPH_ELLIPSE
	 INTER_NEAREST 	 cv::INTER_NEAREST
	 INTER_LINEAR 	 cv::INTER_LINEAR
	 INTER_CUBIC 	 cv::INTER_CUBIC
	 INTER_AREA 	 cv::INTER_AREA
	 INTER_LANCZOS4 	 cv::INTER_LANCZOS4
	 INTER_LINEAR_EXACT 	 cv::INTER_LINEAR_EXACT
	 INTER_MAX 	 cv::INTER_MAX
	 WARP_FILL_OUTLIERS 	 cv::WARP_FILL_OUTLIERS
	 WARP_INVERSE_MAP 	 cv::WARP_INVERSE_MAP
	 WARP_POLAR_LINEAR 	 cv::WARP_POLAR_LINEAR
	 WARP_POLAR_LOG 	 cv::WARP_POLAR_LOG
	 INTER_BITS 	 cv::INTER_BITS
	 INTER_BITS2 	 cv::INTER_BITS2
	 INTER_TAB_SIZE 	 cv::INTER_TAB_SIZE
	 INTER_TAB_SIZE2 	 cv::INTER_TAB_SIZE2
	 DIST_USER 	 cv::DIST_USER
	 DIST_L1 	 cv::DIST_L1
	 DIST_L2 	 cv::DIST_L2
	 DIST_C 	 cv::DIST_C
	 DIST_L12 	 cv::DIST_L12
	 DIST_FAIR 	 cv::DIST_FAIR
	 DIST_WELSCH 	 cv::DIST_WELSCH
	 DIST_HUBER 	 cv::DIST_HUBER
	 DIST_MASK_3 	 cv::DIST_MASK_3
	 DIST_MASK_5 	 cv::DIST_MASK_5
	 DIST_MASK_PRECISE 	 cv::DIST_MASK_PRECISE
	 THRESH_BINARY 	 cv::THRESH_BINARY
	 THRESH_BINARY_INV 	 cv::THRESH_BINARY_INV
	 THRESH_TRUNC 	 cv::THRESH_TRUNC
	 THRESH_TOZERO 	 cv::THRESH_TOZERO
	 THRESH_TOZERO_INV 	 cv::THRESH_TOZERO_INV
	 THRESH_MASK 	 cv::THRESH_MASK
	 THRESH_OTSU 	 cv::THRESH_OTSU
	 THRESH_TRIANGLE 	 cv::THRESH_TRIANGLE
	 ADAPTIVE_THRESH_MEAN_C 	 cv::ADAPTIVE_THRESH_MEAN_C
	 ADAPTIVE_THRESH_GAUSSIAN_C 	 cv::ADAPTIVE_THRESH_GAUSSIAN_C
	 GC_BGD 	 cv::GC_BGD
	 GC_FGD 	 cv::GC_FGD
	 GC_PR_BGD 	 cv::GC_PR_BGD
	 GC_PR_FGD 	 cv::GC_PR_FGD
	 GC_INIT_WITH_RECT 	 cv::GC_INIT_WITH_RECT
	 GC_INIT_WITH_MASK 	 cv::GC_INIT_WITH_MASK
	 GC_EVAL 	 cv::GC_EVAL
	 GC_EVAL_FREEZE_MODEL 	 cv::GC_EVAL_FREEZE_MODEL
	 DIST_LABEL_CCOMP 	 cv::DIST_LABEL_CCOMP
	 DIST_LABEL_PIXEL 	 cv::DIST_LABEL_PIXEL
	 FLOODFILL_FIXED_RANGE 	 cv::FLOODFILL_FIXED_RANGE
	 FLOODFILL_MASK_ONLY 	 cv::FLOODFILL_MASK_ONLY
	 CC_STAT_LEFT 	 cv::CC_STAT_LEFT
	 CC_STAT_TOP 	 cv::CC_STAT_TOP
	 CC_STAT_WIDTH 	 cv::CC_STAT_WIDTH
	 CC_STAT_HEIGHT 	 cv::CC_STAT_HEIGHT
	 CC_STAT_AREA 	 cv::CC_STAT_AREA
	 CC_STAT_MAX 	 cv::CC_STAT_MAX
	 CCL_WU 	 cv::CCL_WU
	 CCL_DEFAULT 	 cv::CCL_DEFAULT
	 CCL_GRANA 	 cv::CCL_GRANA
	 RETR_EXTERNAL 	 cv::RETR_EXTERNAL
	 RETR_LIST 	 cv::RETR_LIST
	 RETR_CCOMP 	 cv::RETR_CCOMP
	 RETR_TREE 	 cv::RETR_TREE
	 RETR_FLOODFILL 	 cv::RETR_FLOODFILL
	 CHAIN_APPROX_NONE 	 cv::CHAIN_APPROX_NONE
	 CHAIN_APPROX_SIMPLE 	 cv::CHAIN_APPROX_SIMPLE
	 CHAIN_APPROX_TC89_L1 	 cv::CHAIN_APPROX_TC89_L1
	 CHAIN_APPROX_TC89_KCOS 	 cv::CHAIN_APPROX_TC89_KCOS
	 CONTOURS_MATCH_I1 	 cv::CONTOURS_MATCH_I1
	 CONTOURS_MATCH_I2 	 cv::CONTOURS_MATCH_I2
	 CONTOURS_MATCH_I3 	 cv::CONTOURS_MATCH_I3
	 HOUGH_STANDARD 	 cv::HOUGH_STANDARD
	 HOUGH_PROBABILISTIC 	 cv::HOUGH_PROBABILISTIC
	 HOUGH_MULTI_SCALE 	 cv::HOUGH_MULTI_SCALE
	 HOUGH_GRADIENT 	 cv::HOUGH_GRADIENT
	 HOUGH_GRADIENT_ALT 	 cv::HOUGH_GRADIENT_ALT
	 LSD_REFINE_NONE 	 cv::LSD_REFINE_NONE
	 LSD_REFINE_STD 	 cv::LSD_REFINE_STD
	 LSD_REFINE_ADV 	 cv::LSD_REFINE_ADV
	 HISTCMP_CORREL 	 cv::HISTCMP_CORREL
	 HISTCMP_CHISQR 	 cv::HISTCMP_CHISQR
	 HISTCMP_INTERSECT 	 cv::HISTCMP_INTERSECT
	 HISTCMP_BHATTACHARYYA 	 cv::HISTCMP_BHATTACHARYYA
	 HISTCMP_HELLINGER 	 cv::HISTCMP_HELLINGER
	 HISTCMP_CHISQR_ALT 	 cv::HISTCMP_CHISQR_ALT
	 HISTCMP_KL_DIV 	 cv::HISTCMP_KL_DIV
	 COLOR_BGR2BGRA 	 cv::COLOR_BGR2BGRA
	 COLOR_RGB2RGBA 	 cv::COLOR_RGB2RGBA
	 COLOR_BGRA2BGR 	 cv::COLOR_BGRA2BGR
	 COLOR_RGBA2RGB 	 cv::COLOR_RGBA2RGB
	 COLOR_BGR2RGBA 	 cv::COLOR_BGR2RGBA
	 COLOR_RGB2BGRA 	 cv::COLOR_RGB2BGRA
	 COLOR_RGBA2BGR 	 cv::COLOR_RGBA2BGR
	 COLOR_BGRA2RGB 	 cv::COLOR_BGRA2RGB
	 COLOR_BGR2RGB 	 cv::COLOR_BGR2RGB
	 COLOR_RGB2BGR 	 cv::COLOR_RGB2BGR
	 COLOR_BGRA2RGBA 	 cv::COLOR_BGRA2RGBA
	 COLOR_RGBA2BGRA 	 cv::COLOR_RGBA2BGRA
	 COLOR_BGR2GRAY 	 cv::COLOR_BGR2GRAY
	 COLOR_RGB2GRAY 	 cv::COLOR_RGB2GRAY
	 COLOR_GRAY2BGR 	 cv::COLOR_GRAY2BGR
	 COLOR_GRAY2RGB 	 cv::COLOR_GRAY2RGB
	 COLOR_GRAY2BGRA 	 cv::COLOR_GRAY2BGRA
	 COLOR_GRAY2RGBA 	 cv::COLOR_GRAY2RGBA
	 COLOR_BGRA2GRAY 	 cv::COLOR_BGRA2GRAY
	 COLOR_RGBA2GRAY 	 cv::COLOR_RGBA2GRAY
	 COLOR_BGR2BGR565 	 cv::COLOR_BGR2BGR565
	 COLOR_RGB2BGR565 	 cv::COLOR_RGB2BGR565
	 COLOR_BGR5652BGR 	 cv::COLOR_BGR5652BGR
	 COLOR_BGR5652RGB 	 cv::COLOR_BGR5652RGB
	 COLOR_BGRA2BGR565 	 cv::COLOR_BGRA2BGR565
	 COLOR_RGBA2BGR565 	 cv::COLOR_RGBA2BGR565
	 COLOR_BGR5652BGRA 	 cv::COLOR_BGR5652BGRA
	 COLOR_BGR5652RGBA 	 cv::COLOR_BGR5652RGBA
	 COLOR_GRAY2BGR565 	 cv::COLOR_GRAY2BGR565
	 COLOR_BGR5652GRAY 	 cv::COLOR_BGR5652GRAY
	 COLOR_BGR2BGR555 	 cv::COLOR_BGR2BGR555
	 COLOR_RGB2BGR555 	 cv::COLOR_RGB2BGR555
	 COLOR_BGR5552BGR 	 cv::COLOR_BGR5552BGR
	 COLOR_BGR5552RGB 	 cv::COLOR_BGR5552RGB
	 COLOR_BGRA2BGR555 	 cv::COLOR_BGRA2BGR555
	 COLOR_RGBA2BGR555 	 cv::COLOR_RGBA2BGR555
	 COLOR_BGR5552BGRA 	 cv::COLOR_BGR5552BGRA
	 COLOR_BGR5552RGBA 	 cv::COLOR_BGR5552RGBA
	 COLOR_GRAY2BGR555 	 cv::COLOR_GRAY2BGR555
	 COLOR_BGR5552GRAY 	 cv::COLOR_BGR5552GRAY
	 COLOR_BGR2XYZ 	 cv::COLOR_BGR2XYZ
	 COLOR_RGB2XYZ 	 cv::COLOR_RGB2XYZ
	 COLOR_XYZ2BGR 	 cv::COLOR_XYZ2BGR
	 COLOR_XYZ2RGB 	 cv::COLOR_XYZ2RGB
	 COLOR_BGR2YCrCb 	 cv::COLOR_BGR2YCrCb
	 COLOR_RGB2YCrCb 	 cv::COLOR_RGB2YCrCb
	 COLOR_YCrCb2BGR 	 cv::COLOR_YCrCb2BGR
	 COLOR_YCrCb2RGB 	 cv::COLOR_YCrCb2RGB
	 COLOR_BGR2HSV 	 cv::COLOR_BGR2HSV
	 COLOR_RGB2HSV 	 cv::COLOR_RGB2HSV
	 COLOR_BGR2Lab 	 cv::COLOR_BGR2Lab
	 COLOR_RGB2Lab 	 cv::COLOR_RGB2Lab
	 COLOR_BGR2Luv 	 cv::COLOR_BGR2Luv
	 COLOR_RGB2Luv 	 cv::COLOR_RGB2Luv
	 COLOR_BGR2HLS 	 cv::COLOR_BGR2HLS
	 COLOR_RGB2HLS 	 cv::COLOR_RGB2HLS
	 COLOR_HSV2BGR 	 cv::COLOR_HSV2BGR
	 COLOR_HSV2RGB 	 cv::COLOR_HSV2RGB
	 COLOR_Lab2BGR 	 cv::COLOR_Lab2BGR
	 COLOR_Lab2RGB 	 cv::COLOR_Lab2RGB
	 COLOR_Luv2BGR 	 cv::COLOR_Luv2BGR
	 COLOR_Luv2RGB 	 cv::COLOR_Luv2RGB
	 COLOR_HLS2BGR 	 cv::COLOR_HLS2BGR
	 COLOR_HLS2RGB 	 cv::COLOR_HLS2RGB
	 COLOR_BGR2HSV_FULL 	 cv::COLOR_BGR2HSV_FULL
	 COLOR_RGB2HSV_FULL 	 cv::COLOR_RGB2HSV_FULL
	 COLOR_BGR2HLS_FULL 	 cv::COLOR_BGR2HLS_FULL
	 COLOR_RGB2HLS_FULL 	 cv::COLOR_RGB2HLS_FULL
	 COLOR_HSV2BGR_FULL 	 cv::COLOR_HSV2BGR_FULL
	 COLOR_HSV2RGB_FULL 	 cv::COLOR_HSV2RGB_FULL
	 COLOR_HLS2BGR_FULL 	 cv::COLOR_HLS2BGR_FULL
	 COLOR_HLS2RGB_FULL 	 cv::COLOR_HLS2RGB_FULL
	 COLOR_LBGR2Lab 	 cv::COLOR_LBGR2Lab
	 COLOR_LRGB2Lab 	 cv::COLOR_LRGB2Lab
	 COLOR_LBGR2Luv 	 cv::COLOR_LBGR2Luv
	 COLOR_LRGB2Luv 	 cv::COLOR_LRGB2Luv
	 COLOR_Lab2LBGR 	 cv::COLOR_Lab2LBGR
	 COLOR_Lab2LRGB 	 cv::COLOR_Lab2LRGB
	 COLOR_Luv2LBGR 	 cv::COLOR_Luv2LBGR
	 COLOR_Luv2LRGB 	 cv::COLOR_Luv2LRGB
	 COLOR_BGR2YUV 	 cv::COLOR_BGR2YUV
	 COLOR_RGB2YUV 	 cv::COLOR_RGB2YUV
	 COLOR_YUV2BGR 	 cv::COLOR_YUV2BGR
	 COLOR_YUV2RGB 	 cv::COLOR_YUV2RGB
	 COLOR_YUV2RGB_NV12 	 cv::COLOR_YUV2RGB_NV12
	 COLOR_YUV2BGR_NV12 	 cv::COLOR_YUV2BGR_NV12
	 COLOR_YUV2RGB_NV21 	 cv::COLOR_YUV2RGB_NV21
	 COLOR_YUV2BGR_NV21 	 cv::COLOR_YUV2BGR_NV21
	 COLOR_YUV420sp2RGB 	 cv::COLOR_YUV420sp2RGB
	 COLOR_YUV420sp2BGR 	 cv::COLOR_YUV420sp2BGR
	 COLOR_YUV2RGBA_NV12 	 cv::COLOR_YUV2RGBA_NV12
	 COLOR_YUV2BGRA_NV12 	 cv::COLOR_YUV2BGRA_NV12
	 COLOR_YUV2RGBA_NV21 	 cv::COLOR_YUV2RGBA_NV21
	 COLOR_YUV2BGRA_NV21 	 cv::COLOR_YUV2BGRA_NV21
	 COLOR_YUV420sp2RGBA 	 cv::COLOR_YUV420sp2RGBA
	 COLOR_YUV420sp2BGRA 	 cv::COLOR_YUV420sp2BGRA
	 COLOR_YUV2RGB_YV12 	 cv::COLOR_YUV2RGB_YV12
	 COLOR_YUV2BGR_YV12 	 cv::COLOR_YUV2BGR_YV12
	 COLOR_YUV2RGB_IYUV 	 cv::COLOR_YUV2RGB_IYUV
	 COLOR_YUV2BGR_IYUV 	 cv::COLOR_YUV2BGR_IYUV
	 COLOR_YUV2RGB_I420 	 cv::COLOR_YUV2RGB_I420
	 COLOR_YUV2BGR_I420 	 cv::COLOR_YUV2BGR_I420
	 COLOR_YUV420p2RGB 	 cv::COLOR_YUV420p2RGB
	 COLOR_YUV420p2BGR 	 cv::COLOR_YUV420p2BGR
	 COLOR_YUV2RGBA_YV12 	 cv::COLOR_YUV2RGBA_YV12
	 COLOR_YUV2BGRA_YV12 	 cv::COLOR_YUV2BGRA_YV12
	 COLOR_YUV2RGBA_IYUV 	 cv::COLOR_YUV2RGBA_IYUV
	 COLOR_YUV2BGRA_IYUV 	 cv::COLOR_YUV2BGRA_IYUV
	 COLOR_YUV2RGBA_I420 	 cv::COLOR_YUV2RGBA_I420
	 COLOR_YUV2BGRA_I420 	 cv::COLOR_YUV2BGRA_I420
	 COLOR_YUV420p2RGBA 	 cv::COLOR_YUV420p2RGBA
	 COLOR_YUV420p2BGRA 	 cv::COLOR_YUV420p2BGRA
	 COLOR_YUV2GRAY_420 	 cv::COLOR_YUV2GRAY_420
	 COLOR_YUV2GRAY_NV21 	 cv::COLOR_YUV2GRAY_NV21
	 COLOR_YUV2GRAY_NV12 	 cv::COLOR_YUV2GRAY_NV12
	 COLOR_YUV2GRAY_YV12 	 cv::COLOR_YUV2GRAY_YV12
	 COLOR_YUV2GRAY_IYUV 	 cv::COLOR_YUV2GRAY_IYUV
	 COLOR_YUV2GRAY_I420 	 cv::COLOR_YUV2GRAY_I420
	 COLOR_YUV420sp2GRAY 	 cv::COLOR_YUV420sp2GRAY
	 COLOR_YUV420p2GRAY 	 cv::COLOR_YUV420p2GRAY
	 COLOR_YUV2RGB_UYVY 	 cv::COLOR_YUV2RGB_UYVY
	 COLOR_YUV2BGR_UYVY 	 cv::COLOR_YUV2BGR_UYVY
	 COLOR_YUV2RGB_Y422 	 cv::COLOR_YUV2RGB_Y422
	 COLOR_YUV2BGR_Y422 	 cv::COLOR_YUV2BGR_Y422
	 COLOR_YUV2RGB_UYNV 	 cv::COLOR_YUV2RGB_UYNV
	 COLOR_YUV2BGR_UYNV 	 cv::COLOR_YUV2BGR_UYNV
	 COLOR_YUV2RGBA_UYVY 	 cv::COLOR_YUV2RGBA_UYVY
	 COLOR_YUV2BGRA_UYVY 	 cv::COLOR_YUV2BGRA_UYVY
	 COLOR_YUV2RGBA_Y422 	 cv::COLOR_YUV2RGBA_Y422
	 COLOR_YUV2BGRA_Y422 	 cv::COLOR_YUV2BGRA_Y422
	 COLOR_YUV2RGBA_UYNV 	 cv::COLOR_YUV2RGBA_UYNV
	 COLOR_YUV2BGRA_UYNV 	 cv::COLOR_YUV2BGRA_UYNV
	 COLOR_YUV2RGB_YUY2 	 cv::COLOR_YUV2RGB_YUY2
	 COLOR_YUV2BGR_YUY2 	 cv::COLOR_YUV2BGR_YUY2
	 COLOR_YUV2RGB_YVYU 	 cv::COLOR_YUV2RGB_YVYU
	 COLOR_YUV2BGR_YVYU 	 cv::COLOR_YUV2BGR_YVYU
	 COLOR_YUV2RGB_YUYV 	 cv::COLOR_YUV2RGB_YUYV
	 COLOR_YUV2BGR_YUYV 	 cv::COLOR_YUV2BGR_YUYV
	 COLOR_YUV2RGB_YUNV 	 cv::COLOR_YUV2RGB_YUNV
	 COLOR_YUV2BGR_YUNV 	 cv::COLOR_YUV2BGR_YUNV
	 COLOR_YUV2RGBA_YUY2 	 cv::COLOR_YUV2RGBA_YUY2
	 COLOR_YUV2BGRA_YUY2 	 cv::COLOR_YUV2BGRA_YUY2
	 COLOR_YUV2RGBA_YVYU 	 cv::COLOR_YUV2RGBA_YVYU
	 COLOR_YUV2BGRA_YVYU 	 cv::COLOR_YUV2BGRA_YVYU
	 COLOR_YUV2RGBA_YUYV 	 cv::COLOR_YUV2RGBA_YUYV
	 COLOR_YUV2BGRA_YUYV 	 cv::COLOR_YUV2BGRA_YUYV
	 COLOR_YUV2RGBA_YUNV 	 cv::COLOR_YUV2RGBA_YUNV
	 COLOR_YUV2BGRA_YUNV 	 cv::COLOR_YUV2BGRA_YUNV
	 COLOR_YUV2GRAY_UYVY 	 cv::COLOR_YUV2GRAY_UYVY
	 COLOR_YUV2GRAY_YUY2 	 cv::COLOR_YUV2GRAY_YUY2
	 COLOR_YUV2GRAY_Y422 	 cv::COLOR_YUV2GRAY_Y422
	 COLOR_YUV2GRAY_UYNV 	 cv::COLOR_YUV2GRAY_UYNV
	 COLOR_YUV2GRAY_YVYU 	 cv::COLOR_YUV2GRAY_YVYU
	 COLOR_YUV2GRAY_YUYV 	 cv::COLOR_YUV2GRAY_YUYV
	 COLOR_YUV2GRAY_YUNV 	 cv::COLOR_YUV2GRAY_YUNV
	 COLOR_RGBA2mRGBA 	 cv::COLOR_RGBA2mRGBA
	 COLOR_mRGBA2RGBA 	 cv::COLOR_mRGBA2RGBA
	 COLOR_RGB2YUV_I420 	 cv::COLOR_RGB2YUV_I420
	 COLOR_BGR2YUV_I420 	 cv::COLOR_BGR2YUV_I420
	 COLOR_RGB2YUV_IYUV 	 cv::COLOR_RGB2YUV_IYUV
	 COLOR_BGR2YUV_IYUV 	 cv::COLOR_BGR2YUV_IYUV
	 COLOR_RGBA2YUV_I420 	 cv::COLOR_RGBA2YUV_I420
	 COLOR_BGRA2YUV_I420 	 cv::COLOR_BGRA2YUV_I420
	 COLOR_RGBA2YUV_IYUV 	 cv::COLOR_RGBA2YUV_IYUV
	 COLOR_BGRA2YUV_IYUV 	 cv::COLOR_BGRA2YUV_IYUV
	 COLOR_RGB2YUV_YV12 	 cv::COLOR_RGB2YUV_YV12
	 COLOR_BGR2YUV_YV12 	 cv::COLOR_BGR2YUV_YV12
	 COLOR_RGBA2YUV_YV12 	 cv::COLOR_RGBA2YUV_YV12
	 COLOR_BGRA2YUV_YV12 	 cv::COLOR_BGRA2YUV_YV12
	 COLOR_BayerBG2BGR 	 cv::COLOR_BayerBG2BGR
	 COLOR_BayerGB2BGR 	 cv::COLOR_BayerGB2BGR
	 COLOR_BayerRG2BGR 	 cv::COLOR_BayerRG2BGR
	 COLOR_BayerGR2BGR 	 cv::COLOR_BayerGR2BGR
	 COLOR_BayerBG2RGB 	 cv::COLOR_BayerBG2RGB
	 COLOR_BayerGB2RGB 	 cv::COLOR_BayerGB2RGB
	 COLOR_BayerRG2RGB 	 cv::COLOR_BayerRG2RGB
	 COLOR_BayerGR2RGB 	 cv::COLOR_BayerGR2RGB
	 COLOR_BayerBG2GRAY 	 cv::COLOR_BayerBG2GRAY
	 COLOR_BayerGB2GRAY 	 cv::COLOR_BayerGB2GRAY
	 COLOR_BayerRG2GRAY 	 cv::COLOR_BayerRG2GRAY
	 COLOR_BayerGR2GRAY 	 cv::COLOR_BayerGR2GRAY
	 COLOR_BayerBG2BGR_VNG 	 cv::COLOR_BayerBG2BGR_VNG
	 COLOR_BayerGB2BGR_VNG 	 cv::COLOR_BayerGB2BGR_VNG
	 COLOR_BayerRG2BGR_VNG 	 cv::COLOR_BayerRG2BGR_VNG
	 COLOR_BayerGR2BGR_VNG 	 cv::COLOR_BayerGR2BGR_VNG
	 COLOR_BayerBG2RGB_VNG 	 cv::COLOR_BayerBG2RGB_VNG
	 COLOR_BayerGB2RGB_VNG 	 cv::COLOR_BayerGB2RGB_VNG
	 COLOR_BayerRG2RGB_VNG 	 cv::COLOR_BayerRG2RGB_VNG
	 COLOR_BayerGR2RGB_VNG 	 cv::COLOR_BayerGR2RGB_VNG
	 COLOR_BayerBG2BGR_EA 	 cv::COLOR_BayerBG2BGR_EA
	 COLOR_BayerGB2BGR_EA 	 cv::COLOR_BayerGB2BGR_EA
	 COLOR_BayerRG2BGR_EA 	 cv::COLOR_BayerRG2BGR_EA
	 COLOR_BayerGR2BGR_EA 	 cv::COLOR_BayerGR2BGR_EA
	 COLOR_BayerBG2RGB_EA 	 cv::COLOR_BayerBG2RGB_EA
	 COLOR_BayerGB2RGB_EA 	 cv::COLOR_BayerGB2RGB_EA
	 COLOR_BayerRG2RGB_EA 	 cv::COLOR_BayerRG2RGB_EA
	 COLOR_BayerGR2RGB_EA 	 cv::COLOR_BayerGR2RGB_EA
	 COLOR_BayerBG2BGRA 	 cv::COLOR_BayerBG2BGRA
	 COLOR_BayerGB2BGRA 	 cv::COLOR_BayerGB2BGRA
	 COLOR_BayerRG2BGRA 	 cv::COLOR_BayerRG2BGRA
	 COLOR_BayerGR2BGRA 	 cv::COLOR_BayerGR2BGRA
	 COLOR_BayerBG2RGBA 	 cv::COLOR_BayerBG2RGBA
	 COLOR_BayerGB2RGBA 	 cv::COLOR_BayerGB2RGBA
	 COLOR_BayerRG2RGBA 	 cv::COLOR_BayerRG2RGBA
	 COLOR_BayerGR2RGBA 	 cv::COLOR_BayerGR2RGBA
	 COLOR_COLORCVT_MAX 	 cv::COLOR_COLORCVT_MAX
	 INTERSECT_NONE 	 cv::INTERSECT_NONE
	 INTERSECT_PARTIAL 	 cv::INTERSECT_PARTIAL
	 INTERSECT_FULL 	 cv::INTERSECT_FULL
	 FILLED 	 cv::FILLED
	 LINE_4 	 cv::LINE_4
	 LINE_8 	 cv::LINE_8
	 LINE_AA 	 cv::LINE_AA
	 FONT_HERSHEY_SIMPLEX 	 cv::FONT_HERSHEY_SIMPLEX
	 FONT_HERSHEY_PLAIN 	 cv::FONT_HERSHEY_PLAIN
	 FONT_HERSHEY_DUPLEX 	 cv::FONT_HERSHEY_DUPLEX
	 FONT_HERSHEY_COMPLEX 	 cv::FONT_HERSHEY_COMPLEX
	 FONT_HERSHEY_TRIPLEX 	 cv::FONT_HERSHEY_TRIPLEX
	 FONT_HERSHEY_COMPLEX_SMALL 	 cv::FONT_HERSHEY_COMPLEX_SMALL
	 FONT_HERSHEY_SCRIPT_SIMPLEX 	 cv::FONT_HERSHEY_SCRIPT_SIMPLEX
	 FONT_HERSHEY_SCRIPT_COMPLEX 	 cv::FONT_HERSHEY_SCRIPT_COMPLEX
	 FONT_ITALIC 	 cv::FONT_ITALIC
	 MARKER_CROSS 	 cv::MARKER_CROSS
	 MARKER_TILTED_CROSS 	 cv::MARKER_TILTED_CROSS
	 MARKER_STAR 	 cv::MARKER_STAR
	 MARKER_DIAMOND 	 cv::MARKER_DIAMOND
	 MARKER_SQUARE 	 cv::MARKER_SQUARE
	 MARKER_TRIANGLE_UP 	 cv::MARKER_TRIANGLE_UP
	 MARKER_TRIANGLE_DOWN 	 cv::MARKER_TRIANGLE_DOWN
	 Subdiv2D_PTLOC_ERROR 	 cv::Subdiv2D::PTLOC_ERROR
	 Subdiv2D_PTLOC_OUTSIDE_RECT 	 cv::Subdiv2D::PTLOC_OUTSIDE_RECT
	 Subdiv2D_PTLOC_INSIDE 	 cv::Subdiv2D::PTLOC_INSIDE
	 Subdiv2D_PTLOC_VERTEX 	 cv::Subdiv2D::PTLOC_VERTEX
	 Subdiv2D_PTLOC_ON_EDGE 	 cv::Subdiv2D::PTLOC_ON_EDGE
	 Subdiv2D_NEXT_AROUND_ORG 	 cv::Subdiv2D::NEXT_AROUND_ORG
	 Subdiv2D_NEXT_AROUND_DST 	 cv::Subdiv2D::NEXT_AROUND_DST
	 Subdiv2D_PREV_AROUND_ORG 	 cv::Subdiv2D::PREV_AROUND_ORG
	 Subdiv2D_PREV_AROUND_DST 	 cv::Subdiv2D::PREV_AROUND_DST
	 Subdiv2D_NEXT_AROUND_LEFT 	 cv::Subdiv2D::NEXT_AROUND_LEFT
	 Subdiv2D_NEXT_AROUND_RIGHT 	 cv::Subdiv2D::NEXT_AROUND_RIGHT
	 Subdiv2D_PREV_AROUND_LEFT 	 cv::Subdiv2D::PREV_AROUND_LEFT
	 Subdiv2D_PREV_AROUND_RIGHT 	 cv::Subdiv2D::PREV_AROUND_RIGHT
	 TM_SQDIFF 	 cv::TM_SQDIFF
	 TM_SQDIFF_NORMED 	 cv::TM_SQDIFF_NORMED
	 TM_CCORR 	 cv::TM_CCORR
	 TM_CCORR_NORMED 	 cv::TM_CCORR_NORMED
	 TM_CCOEFF 	 cv::TM_CCOEFF
	 TM_CCOEFF_NORMED 	 cv::TM_CCOEFF_NORMED
	 COLORMAP_AUTUMN 	 cv::COLORMAP_AUTUMN
	 COLORMAP_BONE 	 cv::COLORMAP_BONE
	 COLORMAP_JET 	 cv::COLORMAP_JET
	 COLORMAP_WINTER 	 cv::COLORMAP_WINTER
	 COLORMAP_RAINBOW 	 cv::COLORMAP_RAINBOW
	 COLORMAP_OCEAN 	 cv::COLORMAP_OCEAN
	 COLORMAP_SUMMER 	 cv::COLORMAP_SUMMER
	 COLORMAP_SPRING 	 cv::COLORMAP_SPRING
	 COLORMAP_COOL 	 cv::COLORMAP_COOL
	 COLORMAP_HSV 	 cv::COLORMAP_HSV
	 COLORMAP_PINK 	 cv::COLORMAP_PINK
	 COLORMAP_HOT 	 cv::COLORMAP_HOT
	 COLORMAP_PARULA 	 cv::COLORMAP_PARULA
	 COLORMAP_MAGMA 	 cv::COLORMAP_MAGMA
	 COLORMAP_INFERNO 	 cv::COLORMAP_INFERNO
	 COLORMAP_PLASMA 	 cv::COLORMAP_PLASMA
	 COLORMAP_VIRIDIS 	 cv::COLORMAP_VIRIDIS
	 COLORMAP_CIVIDIS 	 cv::COLORMAP_CIVIDIS
	 COLORMAP_TWILIGHT 	 cv::COLORMAP_TWILIGHT
	 COLORMAP_TWILIGHT_SHIFTED 	 cv::COLORMAP_TWILIGHT_SHIFTED
	 COLORMAP_TURBO 	 cv::COLORMAP_TURBO
	 LMEDS 	 cv::LMEDS
	 RANSAC 	 cv::RANSAC
	 RHO 	 cv::RHO
	 SOLVEPNP_ITERATIVE 	 cv::SOLVEPNP_ITERATIVE
	 SOLVEPNP_EPNP 	 cv::SOLVEPNP_EPNP
	 SOLVEPNP_P3P 	 cv::SOLVEPNP_P3P
	 SOLVEPNP_DLS 	 cv::SOLVEPNP_DLS
	 SOLVEPNP_UPNP 	 cv::SOLVEPNP_UPNP
	 SOLVEPNP_AP3P 	 cv::SOLVEPNP_AP3P
	 SOLVEPNP_IPPE 	 cv::SOLVEPNP_IPPE
	 SOLVEPNP_IPPE_SQUARE 	 cv::SOLVEPNP_IPPE_SQUARE
	 SOLVEPNP_MAX_COUNT 	 cv::SOLVEPNP_MAX_COUNT
	 CALIB_CB_ADAPTIVE_THRESH 	 cv::CALIB_CB_ADAPTIVE_THRESH
	 CALIB_CB_NORMALIZE_IMAGE 	 cv::CALIB_CB_NORMALIZE_IMAGE
	 CALIB_CB_FILTER_QUADS 	 cv::CALIB_CB_FILTER_QUADS
	 CALIB_CB_FAST_CHECK 	 cv::CALIB_CB_FAST_CHECK
	 CALIB_CB_EXHAUSTIVE 	 cv::CALIB_CB_EXHAUSTIVE
	 CALIB_CB_ACCURACY 	 cv::CALIB_CB_ACCURACY
	 CALIB_CB_SYMMETRIC_GRID 	 cv::CALIB_CB_SYMMETRIC_GRID
	 CALIB_CB_ASYMMETRIC_GRID 	 cv::CALIB_CB_ASYMMETRIC_GRID
	 CALIB_CB_CLUSTERING 	 cv::CALIB_CB_CLUSTERING
	 CALIB_NINTRINSIC 	 cv::CALIB_NINTRINSIC
	 CALIB_USE_INTRINSIC_GUESS 	 cv::CALIB_USE_INTRINSIC_GUESS
	 CALIB_FIX_ASPECT_RATIO 	 cv::CALIB_FIX_ASPECT_RATIO
	 CALIB_FIX_PRINCIPAL_POINT 	 cv::CALIB_FIX_PRINCIPAL_POINT
	 CALIB_ZERO_TANGENT_DIST 	 cv::CALIB_ZERO_TANGENT_DIST
	 CALIB_FIX_FOCAL_LENGTH 	 cv::CALIB_FIX_FOCAL_LENGTH
	 CALIB_FIX_K1 	 cv::CALIB_FIX_K1
	 CALIB_FIX_K2 	 cv::CALIB_FIX_K2
	 CALIB_FIX_K3 	 cv::CALIB_FIX_K3
	 CALIB_FIX_K4 	 cv::CALIB_FIX_K4
	 CALIB_FIX_K5 	 cv::CALIB_FIX_K5
	 CALIB_FIX_K6 	 cv::CALIB_FIX_K6
	 CALIB_RATIONAL_MODEL 	 cv::CALIB_RATIONAL_MODEL
	 CALIB_THIN_PRISM_MODEL 	 cv::CALIB_THIN_PRISM_MODEL
	 CALIB_FIX_S1_S2_S3_S4 	 cv::CALIB_FIX_S1_S2_S3_S4
	 CALIB_TILTED_MODEL 	 cv::CALIB_TILTED_MODEL
	 CALIB_FIX_TAUX_TAUY 	 cv::CALIB_FIX_TAUX_TAUY
	 CALIB_USE_QR 	 cv::CALIB_USE_QR
	 CALIB_FIX_TANGENT_DIST 	 cv::CALIB_FIX_TANGENT_DIST
	 CALIB_FIX_INTRINSIC 	 cv::CALIB_FIX_INTRINSIC
	 CALIB_SAME_FOCAL_LENGTH 	 cv::CALIB_SAME_FOCAL_LENGTH
	 CALIB_ZERO_DISPARITY 	 cv::CALIB_ZERO_DISPARITY
	 CALIB_USE_LU 	 cv::CALIB_USE_LU
	 CALIB_USE_EXTRINSIC_GUESS 	 cv::CALIB_USE_EXTRINSIC_GUESS
	 FM_7POINT 	 cv::FM_7POINT
	 FM_8POINT 	 cv::FM_8POINT
	 FM_LMEDS 	 cv::FM_LMEDS
	 FM_RANSAC 	 cv::FM_RANSAC
	 CALIB_HAND_EYE_TSAI 	 cv::CALIB_HAND_EYE_TSAI
	 CALIB_HAND_EYE_PARK 	 cv::CALIB_HAND_EYE_PARK
	 CALIB_HAND_EYE_HORAUD 	 cv::CALIB_HAND_EYE_HORAUD
	 CALIB_HAND_EYE_ANDREFF 	 cv::CALIB_HAND_EYE_ANDREFF
	 CALIB_HAND_EYE_DANIILIDIS 	 cv::CALIB_HAND_EYE_DANIILIDIS
	 CirclesGridFinderParameters_SYMMETRIC_GRID 	 cv::CirclesGridFinderParameters::SYMMETRIC_GRID
	 CirclesGridFinderParameters_ASYMMETRIC_GRID 	 cv::CirclesGridFinderParameters::ASYMMETRIC_GRID
	 StereoMatcher_DISP_SHIFT 	 cv::StereoMatcher::DISP_SHIFT
	 StereoMatcher_DISP_SCALE 	 cv::StereoMatcher::DISP_SCALE
	 StereoBM_PREFILTER_NORMALIZED_RESPONSE 	 cv::StereoBM::PREFILTER_NORMALIZED_RESPONSE
	 StereoBM_PREFILTER_XSOBEL 	 cv::StereoBM::PREFILTER_XSOBEL
	 StereoSGBM_MODE_SGBM 	 cv::StereoSGBM::MODE_SGBM
	 StereoSGBM_MODE_HH 	 cv::StereoSGBM::MODE_HH
	 StereoSGBM_MODE_SGBM_3WAY 	 cv::StereoSGBM::MODE_SGBM_3WAY
	 StereoSGBM_MODE_HH4 	 cv::StereoSGBM::MODE_HH4
	 PROJ_SPHERICAL_ORTHO 	 cv::PROJ_SPHERICAL_ORTHO
	 PROJ_SPHERICAL_EQRECT 	 cv::PROJ_SPHERICAL_EQRECT
	 ORB_HARRIS_SCORE 	 cv::ORB::HARRIS_SCORE
	 ORB_FAST_SCORE 	 cv::ORB::FAST_SCORE
	 FastFeatureDetector_TYPE_5_8 	 cv::FastFeatureDetector::TYPE_5_8
	 FastFeatureDetector_TYPE_7_12 	 cv::FastFeatureDetector::TYPE_7_12
	 FastFeatureDetector_TYPE_9_16 	 cv::FastFeatureDetector::TYPE_9_16
	 FastFeatureDetector_THRESHOLD 	 cv::FastFeatureDetector::THRESHOLD
	 FastFeatureDetector_NONMAX_SUPPRESSION 	 cv::FastFeatureDetector::NONMAX_SUPPRESSION
	 FastFeatureDetector_FAST_N 	 cv::FastFeatureDetector::FAST_N
	 AgastFeatureDetector_AGAST_5_8 	 cv::AgastFeatureDetector::AGAST_5_8
	 AgastFeatureDetector_AGAST_7_12d 	 cv::AgastFeatureDetector::AGAST_7_12d
	 AgastFeatureDetector_AGAST_7_12s 	 cv::AgastFeatureDetector::AGAST_7_12s
	 AgastFeatureDetector_OAST_9_16 	 cv::AgastFeatureDetector::OAST_9_16
	 AgastFeatureDetector_THRESHOLD 	 cv::AgastFeatureDetector::THRESHOLD
	 AgastFeatureDetector_NONMAX_SUPPRESSION 	 cv::AgastFeatureDetector::NONMAX_SUPPRESSION
	 KAZE_DIFF_PM_G1 	 cv::KAZE::DIFF_PM_G1
	 KAZE_DIFF_PM_G2 	 cv::KAZE::DIFF_PM_G2
	 KAZE_DIFF_WEICKERT 	 cv::KAZE::DIFF_WEICKERT
	 KAZE_DIFF_CHARBONNIER 	 cv::KAZE::DIFF_CHARBONNIER
	 AKAZE_DESCRIPTOR_KAZE_UPRIGHT 	 cv::AKAZE::DESCRIPTOR_KAZE_UPRIGHT
	 AKAZE_DESCRIPTOR_KAZE 	 cv::AKAZE::DESCRIPTOR_KAZE
	 AKAZE_DESCRIPTOR_MLDB_UPRIGHT 	 cv::AKAZE::DESCRIPTOR_MLDB_UPRIGHT
	 AKAZE_DESCRIPTOR_MLDB 	 cv::AKAZE::DESCRIPTOR_MLDB
	 DescriptorMatcher_FLANNBASED 	 cv::DescriptorMatcher::FLANNBASED
	 DescriptorMatcher_BRUTEFORCE 	 cv::DescriptorMatcher::BRUTEFORCE
	 DescriptorMatcher_BRUTEFORCE_L1 	 cv::DescriptorMatcher::BRUTEFORCE_L1
	 DescriptorMatcher_BRUTEFORCE_HAMMING 	 cv::DescriptorMatcher::BRUTEFORCE_HAMMING
	 DescriptorMatcher_BRUTEFORCE_HAMMINGLUT 	 cv::DescriptorMatcher::BRUTEFORCE_HAMMINGLUT
	 DescriptorMatcher_BRUTEFORCE_SL2 	 cv::DescriptorMatcher::BRUTEFORCE_SL2
	 DrawMatchesFlags_DEFAULT 	 cv::DrawMatchesFlags::DEFAULT
	 DrawMatchesFlags_DRAW_OVER_OUTIMG 	 cv::DrawMatchesFlags::DRAW_OVER_OUTIMG
	 DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS 	 cv::DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS
	 DrawMatchesFlags_DRAW_RICH_KEYPOINTS 	 cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS
	 OPTFLOW_USE_INITIAL_FLOW 	 cv::OPTFLOW_USE_INITIAL_FLOW
	 OPTFLOW_LK_GET_MIN_EIGENVALS 	 cv::OPTFLOW_LK_GET_MIN_EIGENVALS
	 OPTFLOW_FARNEBACK_GAUSSIAN 	 cv::OPTFLOW_FARNEBACK_GAUSSIAN
	 MOTION_TRANSLATION 	 cv::MOTION_TRANSLATION
	 MOTION_EUCLIDEAN 	 cv::MOTION_EUCLIDEAN
	 MOTION_AFFINE 	 cv::MOTION_AFFINE
	 MOTION_HOMOGRAPHY 	 cv::MOTION_HOMOGRAPHY
	 DISOpticalFlow_PRESET_ULTRAFAST 	 cv::DISOpticalFlow::PRESET_ULTRAFAST
	 DISOpticalFlow_PRESET_FAST 	 cv::DISOpticalFlow::PRESET_FAST
	 DISOpticalFlow_PRESET_MEDIUM 	 cv::DISOpticalFlow::PRESET_MEDIUM
	 CASCADE_DO_CANNY_PRUNING 	 cv::CASCADE_DO_CANNY_PRUNING
	 CASCADE_SCALE_IMAGE 	 cv::CASCADE_SCALE_IMAGE
	 CASCADE_FIND_BIGGEST_OBJECT 	 cv::CASCADE_FIND_BIGGEST_OBJECT
	 CASCADE_DO_ROUGH_SEARCH 	 cv::CASCADE_DO_ROUGH_SEARCH
	 HOGDescriptor_L2Hys 	 cv::HOGDescriptor::L2Hys
	 HOGDescriptor_DEFAULT_NLEVELS 	 cv::HOGDescriptor::DEFAULT_NLEVELS
	 HOGDescriptor_DESCR_FORMAT_COL_BY_COL 	 cv::HOGDescriptor::DESCR_FORMAT_COL_BY_COL
	 HOGDescriptor_DESCR_FORMAT_ROW_BY_ROW 	 cv::HOGDescriptor::DESCR_FORMAT_ROW_BY_ROW
	 IMREAD_UNCHANGED 	 cv::IMREAD_UNCHANGED
	 IMREAD_GRAYSCALE 	 cv::IMREAD_GRAYSCALE
	 IMREAD_COLOR 	 cv::IMREAD_COLOR
	 IMREAD_ANYDEPTH 	 cv::IMREAD_ANYDEPTH
	 IMREAD_ANYCOLOR 	 cv::IMREAD_ANYCOLOR
	 IMREAD_LOAD_GDAL 	 cv::IMREAD_LOAD_GDAL
	 IMREAD_REDUCED_GRAYSCALE_2 	 cv::IMREAD_REDUCED_GRAYSCALE_2
	 IMREAD_REDUCED_COLOR_2 	 cv::IMREAD_REDUCED_COLOR_2
	 IMREAD_REDUCED_GRAYSCALE_4 	 cv::IMREAD_REDUCED_GRAYSCALE_4
	 IMREAD_REDUCED_COLOR_4 	 cv::IMREAD_REDUCED_COLOR_4
	 IMREAD_REDUCED_GRAYSCALE_8 	 cv::IMREAD_REDUCED_GRAYSCALE_8
	 IMREAD_REDUCED_COLOR_8 	 cv::IMREAD_REDUCED_COLOR_8
	 IMREAD_IGNORE_ORIENTATION 	 cv::IMREAD_IGNORE_ORIENTATION
	 IMWRITE_JPEG_QUALITY 	 cv::IMWRITE_JPEG_QUALITY
	 IMWRITE_JPEG_PROGRESSIVE 	 cv::IMWRITE_JPEG_PROGRESSIVE
	 IMWRITE_JPEG_OPTIMIZE 	 cv::IMWRITE_JPEG_OPTIMIZE
	 IMWRITE_JPEG_RST_INTERVAL 	 cv::IMWRITE_JPEG_RST_INTERVAL
	 IMWRITE_JPEG_LUMA_QUALITY 	 cv::IMWRITE_JPEG_LUMA_QUALITY
	 IMWRITE_JPEG_CHROMA_QUALITY 	 cv::IMWRITE_JPEG_CHROMA_QUALITY
	 IMWRITE_PNG_COMPRESSION 	 cv::IMWRITE_PNG_COMPRESSION
	 IMWRITE_PNG_STRATEGY 	 cv::IMWRITE_PNG_STRATEGY
	 IMWRITE_PNG_BILEVEL 	 cv::IMWRITE_PNG_BILEVEL
	 IMWRITE_PXM_BINARY 	 cv::IMWRITE_PXM_BINARY
	 IMWRITE_EXR_TYPE 	 cv::IMWRITE_EXR_TYPE
	 IMWRITE_WEBP_QUALITY 	 cv::IMWRITE_WEBP_QUALITY
	 IMWRITE_PAM_TUPLETYPE 	 cv::IMWRITE_PAM_TUPLETYPE
	 IMWRITE_TIFF_RESUNIT 	 cv::IMWRITE_TIFF_RESUNIT
	 IMWRITE_TIFF_XDPI 	 cv::IMWRITE_TIFF_XDPI
	 IMWRITE_TIFF_YDPI 	 cv::IMWRITE_TIFF_YDPI
	 IMWRITE_TIFF_COMPRESSION 	 cv::IMWRITE_TIFF_COMPRESSION
	 IMWRITE_JPEG2000_COMPRESSION_X1000 	 cv::IMWRITE_JPEG2000_COMPRESSION_X1000
	 IMWRITE_EXR_TYPE_HALF 	 cv::IMWRITE_EXR_TYPE_HALF
	 IMWRITE_EXR_TYPE_FLOAT 	 cv::IMWRITE_EXR_TYPE_FLOAT
	 IMWRITE_PNG_STRATEGY_DEFAULT 	 cv::IMWRITE_PNG_STRATEGY_DEFAULT
	 IMWRITE_PNG_STRATEGY_FILTERED 	 cv::IMWRITE_PNG_STRATEGY_FILTERED
	 IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY 	 cv::IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY
	 IMWRITE_PNG_STRATEGY_RLE 	 cv::IMWRITE_PNG_STRATEGY_RLE
	 IMWRITE_PNG_STRATEGY_FIXED 	 cv::IMWRITE_PNG_STRATEGY_FIXED
	 IMWRITE_PAM_FORMAT_NULL 	 cv::IMWRITE_PAM_FORMAT_NULL
	 IMWRITE_PAM_FORMAT_BLACKANDWHITE 	 cv::IMWRITE_PAM_FORMAT_BLACKANDWHITE
	 IMWRITE_PAM_FORMAT_GRAYSCALE 	 cv::IMWRITE_PAM_FORMAT_GRAYSCALE
	 IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA 	 cv::IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA
	 IMWRITE_PAM_FORMAT_RGB 	 cv::IMWRITE_PAM_FORMAT_RGB
	 IMWRITE_PAM_FORMAT_RGB_ALPHA 	 cv::IMWRITE_PAM_FORMAT_RGB_ALPHA
	 CAP_ANY 	 cv::CAP_ANY
	 CAP_VFW 	 cv::CAP_VFW
	 CAP_V4L 	 cv::CAP_V4L
	 CAP_V4L2 	 cv::CAP_V4L2
	 CAP_FIREWIRE 	 cv::CAP_FIREWIRE
	 CAP_FIREWARE 	 cv::CAP_FIREWARE
	 CAP_IEEE1394 	 cv::CAP_IEEE1394
	 CAP_DC1394 	 cv::CAP_DC1394
	 CAP_CMU1394 	 cv::CAP_CMU1394
	 CAP_QT 	 cv::CAP_QT
	 CAP_UNICAP 	 cv::CAP_UNICAP
	 CAP_DSHOW 	 cv::CAP_DSHOW
	 CAP_PVAPI 	 cv::CAP_PVAPI
	 CAP_OPENNI 	 cv::CAP_OPENNI
	 CAP_OPENNI_ASUS 	 cv::CAP_OPENNI_ASUS
	 CAP_ANDROID 	 cv::CAP_ANDROID
	 CAP_XIAPI 	 cv::CAP_XIAPI
	 CAP_AVFOUNDATION 	 cv::CAP_AVFOUNDATION
	 CAP_GIGANETIX 	 cv::CAP_GIGANETIX
	 CAP_MSMF 	 cv::CAP_MSMF
	 CAP_WINRT 	 cv::CAP_WINRT
	 CAP_INTELPERC 	 cv::CAP_INTELPERC
	 CAP_REALSENSE 	 cv::CAP_REALSENSE
	 CAP_OPENNI2 	 cv::CAP_OPENNI2
	 CAP_OPENNI2_ASUS 	 cv::CAP_OPENNI2_ASUS
	 CAP_GPHOTO2 	 cv::CAP_GPHOTO2
	 CAP_GSTREAMER 	 cv::CAP_GSTREAMER
	 CAP_FFMPEG 	 cv::CAP_FFMPEG
	 CAP_IMAGES 	 cv::CAP_IMAGES
	 CAP_ARAVIS 	 cv::CAP_ARAVIS
	 CAP_OPENCV_MJPEG 	 cv::CAP_OPENCV_MJPEG
	 CAP_INTEL_MFX 	 cv::CAP_INTEL_MFX
	 CAP_XINE 	 cv::CAP_XINE
	 CAP_PROP_POS_MSEC 	 cv::CAP_PROP_POS_MSEC
	 CAP_PROP_POS_FRAMES 	 cv::CAP_PROP_POS_FRAMES
	 CAP_PROP_POS_AVI_RATIO 	 cv::CAP_PROP_POS_AVI_RATIO
	 CAP_PROP_FRAME_WIDTH 	 cv::CAP_PROP_FRAME_WIDTH
	 CAP_PROP_FRAME_HEIGHT 	 cv::CAP_PROP_FRAME_HEIGHT
	 CAP_PROP_FPS 	 cv::CAP_PROP_FPS
	 CAP_PROP_FOURCC 	 cv::CAP_PROP_FOURCC
	 CAP_PROP_FRAME_COUNT 	 cv::CAP_PROP_FRAME_COUNT
	 CAP_PROP_FORMAT 	 cv::CAP_PROP_FORMAT
	 CAP_PROP_MODE 	 cv::CAP_PROP_MODE
	 CAP_PROP_BRIGHTNESS 	 cv::CAP_PROP_BRIGHTNESS
	 CAP_PROP_CONTRAST 	 cv::CAP_PROP_CONTRAST
	 CAP_PROP_SATURATION 	 cv::CAP_PROP_SATURATION
	 CAP_PROP_HUE 	 cv::CAP_PROP_HUE
	 CAP_PROP_GAIN 	 cv::CAP_PROP_GAIN
	 CAP_PROP_EXPOSURE 	 cv::CAP_PROP_EXPOSURE
	 CAP_PROP_CONVERT_RGB 	 cv::CAP_PROP_CONVERT_RGB
	 CAP_PROP_WHITE_BALANCE_BLUE_U 	 cv::CAP_PROP_WHITE_BALANCE_BLUE_U
	 CAP_PROP_RECTIFICATION 	 cv::CAP_PROP_RECTIFICATION
	 CAP_PROP_MONOCHROME 	 cv::CAP_PROP_MONOCHROME
	 CAP_PROP_SHARPNESS 	 cv::CAP_PROP_SHARPNESS
	 CAP_PROP_AUTO_EXPOSURE 	 cv::CAP_PROP_AUTO_EXPOSURE
	 CAP_PROP_GAMMA 	 cv::CAP_PROP_GAMMA
	 CAP_PROP_TEMPERATURE 	 cv::CAP_PROP_TEMPERATURE
	 CAP_PROP_TRIGGER 	 cv::CAP_PROP_TRIGGER
	 CAP_PROP_TRIGGER_DELAY 	 cv::CAP_PROP_TRIGGER_DELAY
	 CAP_PROP_WHITE_BALANCE_RED_V 	 cv::CAP_PROP_WHITE_BALANCE_RED_V
	 CAP_PROP_ZOOM 	 cv::CAP_PROP_ZOOM
	 CAP_PROP_FOCUS 	 cv::CAP_PROP_FOCUS
	 CAP_PROP_GUID 	 cv::CAP_PROP_GUID
	 CAP_PROP_ISO_SPEED 	 cv::CAP_PROP_ISO_SPEED
	 CAP_PROP_BACKLIGHT 	 cv::CAP_PROP_BACKLIGHT
	 CAP_PROP_PAN 	 cv::CAP_PROP_PAN
	 CAP_PROP_TILT 	 cv::CAP_PROP_TILT
	 CAP_PROP_ROLL 	 cv::CAP_PROP_ROLL
	 CAP_PROP_IRIS 	 cv::CAP_PROP_IRIS
	 CAP_PROP_SETTINGS 	 cv::CAP_PROP_SETTINGS
	 CAP_PROP_BUFFERSIZE 	 cv::CAP_PROP_BUFFERSIZE
	 CAP_PROP_AUTOFOCUS 	 cv::CAP_PROP_AUTOFOCUS
	 CAP_PROP_SAR_NUM 	 cv::CAP_PROP_SAR_NUM
	 CAP_PROP_SAR_DEN 	 cv::CAP_PROP_SAR_DEN
	 CAP_PROP_BACKEND 	 cv::CAP_PROP_BACKEND
	 CAP_PROP_CHANNEL 	 cv::CAP_PROP_CHANNEL
	 CAP_PROP_AUTO_WB 	 cv::CAP_PROP_AUTO_WB
	 CAP_PROP_WB_TEMPERATURE 	 cv::CAP_PROP_WB_TEMPERATURE
	 CAP_PROP_CODEC_PIXEL_FORMAT 	 cv::CAP_PROP_CODEC_PIXEL_FORMAT
	 VIDEOWRITER_PROP_QUALITY 	 cv::VIDEOWRITER_PROP_QUALITY
	 VIDEOWRITER_PROP_FRAMEBYTES 	 cv::VIDEOWRITER_PROP_FRAMEBYTES
	 VIDEOWRITER_PROP_NSTRIPES 	 cv::VIDEOWRITER_PROP_NSTRIPES
	 CAP_PROP_DC1394_OFF 	 cv::CAP_PROP_DC1394_OFF
	 CAP_PROP_DC1394_MODE_MANUAL 	 cv::CAP_PROP_DC1394_MODE_MANUAL
	 CAP_PROP_DC1394_MODE_AUTO 	 cv::CAP_PROP_DC1394_MODE_AUTO
	 CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO 	 cv::CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO
	 CAP_PROP_DC1394_MAX 	 cv::CAP_PROP_DC1394_MAX
	 CAP_OPENNI_DEPTH_GENERATOR 	 cv::CAP_OPENNI_DEPTH_GENERATOR
	 CAP_OPENNI_IMAGE_GENERATOR 	 cv::CAP_OPENNI_IMAGE_GENERATOR
	 CAP_OPENNI_IR_GENERATOR 	 cv::CAP_OPENNI_IR_GENERATOR
	 CAP_OPENNI_GENERATORS_MASK 	 cv::CAP_OPENNI_GENERATORS_MASK
	 CAP_PROP_OPENNI_OUTPUT_MODE 	 cv::CAP_PROP_OPENNI_OUTPUT_MODE
	 CAP_PROP_OPENNI_FRAME_MAX_DEPTH 	 cv::CAP_PROP_OPENNI_FRAME_MAX_DEPTH
	 CAP_PROP_OPENNI_BASELINE 	 cv::CAP_PROP_OPENNI_BASELINE
	 CAP_PROP_OPENNI_FOCAL_LENGTH 	 cv::CAP_PROP_OPENNI_FOCAL_LENGTH
	 CAP_PROP_OPENNI_REGISTRATION 	 cv::CAP_PROP_OPENNI_REGISTRATION
	 CAP_PROP_OPENNI_REGISTRATION_ON 	 cv::CAP_PROP_OPENNI_REGISTRATION_ON
	 CAP_PROP_OPENNI_APPROX_FRAME_SYNC 	 cv::CAP_PROP_OPENNI_APPROX_FRAME_SYNC
	 CAP_PROP_OPENNI_MAX_BUFFER_SIZE 	 cv::CAP_PROP_OPENNI_MAX_BUFFER_SIZE
	 CAP_PROP_OPENNI_CIRCLE_BUFFER 	 cv::CAP_PROP_OPENNI_CIRCLE_BUFFER
	 CAP_PROP_OPENNI_MAX_TIME_DURATION 	 cv::CAP_PROP_OPENNI_MAX_TIME_DURATION
	 CAP_PROP_OPENNI_GENERATOR_PRESENT 	 cv::CAP_PROP_OPENNI_GENERATOR_PRESENT
	 CAP_PROP_OPENNI2_SYNC 	 cv::CAP_PROP_OPENNI2_SYNC
	 CAP_PROP_OPENNI2_MIRROR 	 cv::CAP_PROP_OPENNI2_MIRROR
	 CAP_OPENNI_IMAGE_GENERATOR_PRESENT 	 cv::CAP_OPENNI_IMAGE_GENERATOR_PRESENT
	 CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE 	 cv::CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE
	 CAP_OPENNI_DEPTH_GENERATOR_PRESENT 	 cv::CAP_OPENNI_DEPTH_GENERATOR_PRESENT
	 CAP_OPENNI_DEPTH_GENERATOR_BASELINE 	 cv::CAP_OPENNI_DEPTH_GENERATOR_BASELINE
	 CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH 	 cv::CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH
	 CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION 	 cv::CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION
	 CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON 	 cv::CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON
	 CAP_OPENNI_IR_GENERATOR_PRESENT 	 cv::CAP_OPENNI_IR_GENERATOR_PRESENT
	 CAP_OPENNI_DEPTH_MAP 	 cv::CAP_OPENNI_DEPTH_MAP
	 CAP_OPENNI_POINT_CLOUD_MAP 	 cv::CAP_OPENNI_POINT_CLOUD_MAP
	 CAP_OPENNI_DISPARITY_MAP 	 cv::CAP_OPENNI_DISPARITY_MAP
	 CAP_OPENNI_DISPARITY_MAP_32F 	 cv::CAP_OPENNI_DISPARITY_MAP_32F
	 CAP_OPENNI_VALID_DEPTH_MASK 	 cv::CAP_OPENNI_VALID_DEPTH_MASK
	 CAP_OPENNI_BGR_IMAGE 	 cv::CAP_OPENNI_BGR_IMAGE
	 CAP_OPENNI_GRAY_IMAGE 	 cv::CAP_OPENNI_GRAY_IMAGE
	 CAP_OPENNI_IR_IMAGE 	 cv::CAP_OPENNI_IR_IMAGE
	 CAP_OPENNI_VGA_30HZ 	 cv::CAP_OPENNI_VGA_30HZ
	 CAP_OPENNI_SXGA_15HZ 	 cv::CAP_OPENNI_SXGA_15HZ
	 CAP_OPENNI_SXGA_30HZ 	 cv::CAP_OPENNI_SXGA_30HZ
	 CAP_OPENNI_QVGA_30HZ 	 cv::CAP_OPENNI_QVGA_30HZ
	 CAP_OPENNI_QVGA_60HZ 	 cv::CAP_OPENNI_QVGA_60HZ
	 CAP_PROP_GSTREAMER_QUEUE_LENGTH 	 cv::CAP_PROP_GSTREAMER_QUEUE_LENGTH
	 CAP_PROP_PVAPI_MULTICASTIP 	 cv::CAP_PROP_PVAPI_MULTICASTIP
	 CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE 	 cv::CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE
	 CAP_PROP_PVAPI_DECIMATIONHORIZONTAL 	 cv::CAP_PROP_PVAPI_DECIMATIONHORIZONTAL
	 CAP_PROP_PVAPI_DECIMATIONVERTICAL 	 cv::CAP_PROP_PVAPI_DECIMATIONVERTICAL
	 CAP_PROP_PVAPI_BINNINGX 	 cv::CAP_PROP_PVAPI_BINNINGX
	 CAP_PROP_PVAPI_BINNINGY 	 cv::CAP_PROP_PVAPI_BINNINGY
	 CAP_PROP_PVAPI_PIXELFORMAT 	 cv::CAP_PROP_PVAPI_PIXELFORMAT
	 CAP_PVAPI_FSTRIGMODE_FREERUN 	 cv::CAP_PVAPI_FSTRIGMODE_FREERUN
	 CAP_PVAPI_FSTRIGMODE_SYNCIN1 	 cv::CAP_PVAPI_FSTRIGMODE_SYNCIN1
	 CAP_PVAPI_FSTRIGMODE_SYNCIN2 	 cv::CAP_PVAPI_FSTRIGMODE_SYNCIN2
	 CAP_PVAPI_FSTRIGMODE_FIXEDRATE 	 cv::CAP_PVAPI_FSTRIGMODE_FIXEDRATE
	 CAP_PVAPI_FSTRIGMODE_SOFTWARE 	 cv::CAP_PVAPI_FSTRIGMODE_SOFTWARE
	 CAP_PVAPI_DECIMATION_OFF 	 cv::CAP_PVAPI_DECIMATION_OFF
	 CAP_PVAPI_DECIMATION_2OUTOF4 	 cv::CAP_PVAPI_DECIMATION_2OUTOF4
	 CAP_PVAPI_DECIMATION_2OUTOF8 	 cv::CAP_PVAPI_DECIMATION_2OUTOF8
	 CAP_PVAPI_DECIMATION_2OUTOF16 	 cv::CAP_PVAPI_DECIMATION_2OUTOF16
	 CAP_PVAPI_PIXELFORMAT_MONO8 	 cv::CAP_PVAPI_PIXELFORMAT_MONO8
	 CAP_PVAPI_PIXELFORMAT_MONO16 	 cv::CAP_PVAPI_PIXELFORMAT_MONO16
	 CAP_PVAPI_PIXELFORMAT_BAYER8 	 cv::CAP_PVAPI_PIXELFORMAT_BAYER8
	 CAP_PVAPI_PIXELFORMAT_BAYER16 	 cv::CAP_PVAPI_PIXELFORMAT_BAYER16
	 CAP_PVAPI_PIXELFORMAT_RGB24 	 cv::CAP_PVAPI_PIXELFORMAT_RGB24
	 CAP_PVAPI_PIXELFORMAT_BGR24 	 cv::CAP_PVAPI_PIXELFORMAT_BGR24
	 CAP_PVAPI_PIXELFORMAT_RGBA32 	 cv::CAP_PVAPI_PIXELFORMAT_RGBA32
	 CAP_PVAPI_PIXELFORMAT_BGRA32 	 cv::CAP_PVAPI_PIXELFORMAT_BGRA32
	 CAP_PROP_XI_DOWNSAMPLING 	 cv::CAP_PROP_XI_DOWNSAMPLING
	 CAP_PROP_XI_DATA_FORMAT 	 cv::CAP_PROP_XI_DATA_FORMAT
	 CAP_PROP_XI_OFFSET_X 	 cv::CAP_PROP_XI_OFFSET_X
	 CAP_PROP_XI_OFFSET_Y 	 cv::CAP_PROP_XI_OFFSET_Y
	 CAP_PROP_XI_TRG_SOURCE 	 cv::CAP_PROP_XI_TRG_SOURCE
	 CAP_PROP_XI_TRG_SOFTWARE 	 cv::CAP_PROP_XI_TRG_SOFTWARE
	 CAP_PROP_XI_GPI_SELECTOR 	 cv::CAP_PROP_XI_GPI_SELECTOR
	 CAP_PROP_XI_GPI_MODE 	 cv::CAP_PROP_XI_GPI_MODE
	 CAP_PROP_XI_GPI_LEVEL 	 cv::CAP_PROP_XI_GPI_LEVEL
	 CAP_PROP_XI_GPO_SELECTOR 	 cv::CAP_PROP_XI_GPO_SELECTOR
	 CAP_PROP_XI_GPO_MODE 	 cv::CAP_PROP_XI_GPO_MODE
	 CAP_PROP_XI_LED_SELECTOR 	 cv::CAP_PROP_XI_LED_SELECTOR
	 CAP_PROP_XI_LED_MODE 	 cv::CAP_PROP_XI_LED_MODE
	 CAP_PROP_XI_MANUAL_WB 	 cv::CAP_PROP_XI_MANUAL_WB
	 CAP_PROP_XI_AUTO_WB 	 cv::CAP_PROP_XI_AUTO_WB
	 CAP_PROP_XI_AEAG 	 cv::CAP_PROP_XI_AEAG
	 CAP_PROP_XI_EXP_PRIORITY 	 cv::CAP_PROP_XI_EXP_PRIORITY
	 CAP_PROP_XI_AE_MAX_LIMIT 	 cv::CAP_PROP_XI_AE_MAX_LIMIT
	 CAP_PROP_XI_AG_MAX_LIMIT 	 cv::CAP_PROP_XI_AG_MAX_LIMIT
	 CAP_PROP_XI_AEAG_LEVEL 	 cv::CAP_PROP_XI_AEAG_LEVEL
	 CAP_PROP_XI_TIMEOUT 	 cv::CAP_PROP_XI_TIMEOUT
	 CAP_PROP_XI_EXPOSURE 	 cv::CAP_PROP_XI_EXPOSURE
	 CAP_PROP_XI_EXPOSURE_BURST_COUNT 	 cv::CAP_PROP_XI_EXPOSURE_BURST_COUNT
	 CAP_PROP_XI_GAIN_SELECTOR 	 cv::CAP_PROP_XI_GAIN_SELECTOR
	 CAP_PROP_XI_GAIN 	 cv::CAP_PROP_XI_GAIN
	 CAP_PROP_XI_DOWNSAMPLING_TYPE 	 cv::CAP_PROP_XI_DOWNSAMPLING_TYPE
	 CAP_PROP_XI_BINNING_SELECTOR 	 cv::CAP_PROP_XI_BINNING_SELECTOR
	 CAP_PROP_XI_BINNING_VERTICAL 	 cv::CAP_PROP_XI_BINNING_VERTICAL
	 CAP_PROP_XI_BINNING_HORIZONTAL 	 cv::CAP_PROP_XI_BINNING_HORIZONTAL
	 CAP_PROP_XI_BINNING_PATTERN 	 cv::CAP_PROP_XI_BINNING_PATTERN
	 CAP_PROP_XI_DECIMATION_SELECTOR 	 cv::CAP_PROP_XI_DECIMATION_SELECTOR
	 CAP_PROP_XI_DECIMATION_VERTICAL 	 cv::CAP_PROP_XI_DECIMATION_VERTICAL
	 CAP_PROP_XI_DECIMATION_HORIZONTAL 	 cv::CAP_PROP_XI_DECIMATION_HORIZONTAL
	 CAP_PROP_XI_DECIMATION_PATTERN 	 cv::CAP_PROP_XI_DECIMATION_PATTERN
	 CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR 	 cv::CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR
	 CAP_PROP_XI_TEST_PATTERN 	 cv::CAP_PROP_XI_TEST_PATTERN
	 CAP_PROP_XI_IMAGE_DATA_FORMAT 	 cv::CAP_PROP_XI_IMAGE_DATA_FORMAT
	 CAP_PROP_XI_SHUTTER_TYPE 	 cv::CAP_PROP_XI_SHUTTER_TYPE
	 CAP_PROP_XI_SENSOR_TAPS 	 cv::CAP_PROP_XI_SENSOR_TAPS
	 CAP_PROP_XI_AEAG_ROI_OFFSET_X 	 cv::CAP_PROP_XI_AEAG_ROI_OFFSET_X
	 CAP_PROP_XI_AEAG_ROI_OFFSET_Y 	 cv::CAP_PROP_XI_AEAG_ROI_OFFSET_Y
	 CAP_PROP_XI_AEAG_ROI_WIDTH 	 cv::CAP_PROP_XI_AEAG_ROI_WIDTH
	 CAP_PROP_XI_AEAG_ROI_HEIGHT 	 cv::CAP_PROP_XI_AEAG_ROI_HEIGHT
	 CAP_PROP_XI_BPC 	 cv::CAP_PROP_XI_BPC
	 CAP_PROP_XI_WB_KR 	 cv::CAP_PROP_XI_WB_KR
	 CAP_PROP_XI_WB_KG 	 cv::CAP_PROP_XI_WB_KG
	 CAP_PROP_XI_WB_KB 	 cv::CAP_PROP_XI_WB_KB
	 CAP_PROP_XI_WIDTH 	 cv::CAP_PROP_XI_WIDTH
	 CAP_PROP_XI_HEIGHT 	 cv::CAP_PROP_XI_HEIGHT
	 CAP_PROP_XI_REGION_SELECTOR 	 cv::CAP_PROP_XI_REGION_SELECTOR
	 CAP_PROP_XI_REGION_MODE 	 cv::CAP_PROP_XI_REGION_MODE
	 CAP_PROP_XI_LIMIT_BANDWIDTH 	 cv::CAP_PROP_XI_LIMIT_BANDWIDTH
	 CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH 	 cv::CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH
	 CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH 	 cv::CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH
	 CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH 	 cv::CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH
	 CAP_PROP_XI_OUTPUT_DATA_PACKING 	 cv::CAP_PROP_XI_OUTPUT_DATA_PACKING
	 CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE 	 cv::CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE
	 CAP_PROP_XI_IS_COOLED 	 cv::CAP_PROP_XI_IS_COOLED
	 CAP_PROP_XI_COOLING 	 cv::CAP_PROP_XI_COOLING
	 CAP_PROP_XI_TARGET_TEMP 	 cv::CAP_PROP_XI_TARGET_TEMP
	 CAP_PROP_XI_CHIP_TEMP 	 cv::CAP_PROP_XI_CHIP_TEMP
	 CAP_PROP_XI_HOUS_TEMP 	 cv::CAP_PROP_XI_HOUS_TEMP
	 CAP_PROP_XI_HOUS_BACK_SIDE_TEMP 	 cv::CAP_PROP_XI_HOUS_BACK_SIDE_TEMP
	 CAP_PROP_XI_SENSOR_BOARD_TEMP 	 cv::CAP_PROP_XI_SENSOR_BOARD_TEMP
	 CAP_PROP_XI_CMS 	 cv::CAP_PROP_XI_CMS
	 CAP_PROP_XI_APPLY_CMS 	 cv::CAP_PROP_XI_APPLY_CMS
	 CAP_PROP_XI_IMAGE_IS_COLOR 	 cv::CAP_PROP_XI_IMAGE_IS_COLOR
	 CAP_PROP_XI_COLOR_FILTER_ARRAY 	 cv::CAP_PROP_XI_COLOR_FILTER_ARRAY
	 CAP_PROP_XI_GAMMAY 	 cv::CAP_PROP_XI_GAMMAY
	 CAP_PROP_XI_GAMMAC 	 cv::CAP_PROP_XI_GAMMAC
	 CAP_PROP_XI_SHARPNESS 	 cv::CAP_PROP_XI_SHARPNESS
	 CAP_PROP_XI_CC_MATRIX_00 	 cv::CAP_PROP_XI_CC_MATRIX_00
	 CAP_PROP_XI_CC_MATRIX_01 	 cv::CAP_PROP_XI_CC_MATRIX_01
	 CAP_PROP_XI_CC_MATRIX_02 	 cv::CAP_PROP_XI_CC_MATRIX_02
	 CAP_PROP_XI_CC_MATRIX_03 	 cv::CAP_PROP_XI_CC_MATRIX_03
	 CAP_PROP_XI_CC_MATRIX_10 	 cv::CAP_PROP_XI_CC_MATRIX_10
	 CAP_PROP_XI_CC_MATRIX_11 	 cv::CAP_PROP_XI_CC_MATRIX_11
	 CAP_PROP_XI_CC_MATRIX_12 	 cv::CAP_PROP_XI_CC_MATRIX_12
	 CAP_PROP_XI_CC_MATRIX_13 	 cv::CAP_PROP_XI_CC_MATRIX_13
	 CAP_PROP_XI_CC_MATRIX_20 	 cv::CAP_PROP_XI_CC_MATRIX_20
	 CAP_PROP_XI_CC_MATRIX_21 	 cv::CAP_PROP_XI_CC_MATRIX_21
	 CAP_PROP_XI_CC_MATRIX_22 	 cv::CAP_PROP_XI_CC_MATRIX_22
	 CAP_PROP_XI_CC_MATRIX_23 	 cv::CAP_PROP_XI_CC_MATRIX_23
	 CAP_PROP_XI_CC_MATRIX_30 	 cv::CAP_PROP_XI_CC_MATRIX_30
	 CAP_PROP_XI_CC_MATRIX_31 	 cv::CAP_PROP_XI_CC_MATRIX_31
	 CAP_PROP_XI_CC_MATRIX_32 	 cv::CAP_PROP_XI_CC_MATRIX_32
	 CAP_PROP_XI_CC_MATRIX_33 	 cv::CAP_PROP_XI_CC_MATRIX_33
	 CAP_PROP_XI_DEFAULT_CC_MATRIX 	 cv::CAP_PROP_XI_DEFAULT_CC_MATRIX
	 CAP_PROP_XI_TRG_SELECTOR 	 cv::CAP_PROP_XI_TRG_SELECTOR
	 CAP_PROP_XI_ACQ_FRAME_BURST_COUNT 	 cv::CAP_PROP_XI_ACQ_FRAME_BURST_COUNT
	 CAP_PROP_XI_DEBOUNCE_EN 	 cv::CAP_PROP_XI_DEBOUNCE_EN
	 CAP_PROP_XI_DEBOUNCE_T0 	 cv::CAP_PROP_XI_DEBOUNCE_T0
	 CAP_PROP_XI_DEBOUNCE_T1 	 cv::CAP_PROP_XI_DEBOUNCE_T1
	 CAP_PROP_XI_DEBOUNCE_POL 	 cv::CAP_PROP_XI_DEBOUNCE_POL
	 CAP_PROP_XI_LENS_MODE 	 cv::CAP_PROP_XI_LENS_MODE
	 CAP_PROP_XI_LENS_APERTURE_VALUE 	 cv::CAP_PROP_XI_LENS_APERTURE_VALUE
	 CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE 	 cv::CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE
	 CAP_PROP_XI_LENS_FOCUS_MOVE 	 cv::CAP_PROP_XI_LENS_FOCUS_MOVE
	 CAP_PROP_XI_LENS_FOCUS_DISTANCE 	 cv::CAP_PROP_XI_LENS_FOCUS_DISTANCE
	 CAP_PROP_XI_LENS_FOCAL_LENGTH 	 cv::CAP_PROP_XI_LENS_FOCAL_LENGTH
	 CAP_PROP_XI_LENS_FEATURE_SELECTOR 	 cv::CAP_PROP_XI_LENS_FEATURE_SELECTOR
	 CAP_PROP_XI_LENS_FEATURE 	 cv::CAP_PROP_XI_LENS_FEATURE
	 CAP_PROP_XI_DEVICE_MODEL_ID 	 cv::CAP_PROP_XI_DEVICE_MODEL_ID
	 CAP_PROP_XI_DEVICE_SN 	 cv::CAP_PROP_XI_DEVICE_SN
	 CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA 	 cv::CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA
	 CAP_PROP_XI_IMAGE_PAYLOAD_SIZE 	 cv::CAP_PROP_XI_IMAGE_PAYLOAD_SIZE
	 CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT 	 cv::CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT
	 CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ 	 cv::CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ
	 CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX 	 cv::CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX
	 CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT 	 cv::CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT
	 CAP_PROP_XI_FRAMERATE 	 cv::CAP_PROP_XI_FRAMERATE
	 CAP_PROP_XI_COUNTER_SELECTOR 	 cv::CAP_PROP_XI_COUNTER_SELECTOR
	 CAP_PROP_XI_COUNTER_VALUE 	 cv::CAP_PROP_XI_COUNTER_VALUE
	 CAP_PROP_XI_ACQ_TIMING_MODE 	 cv::CAP_PROP_XI_ACQ_TIMING_MODE
	 CAP_PROP_XI_AVAILABLE_BANDWIDTH 	 cv::CAP_PROP_XI_AVAILABLE_BANDWIDTH
	 CAP_PROP_XI_BUFFER_POLICY 	 cv::CAP_PROP_XI_BUFFER_POLICY
	 CAP_PROP_XI_LUT_EN 	 cv::CAP_PROP_XI_LUT_EN
	 CAP_PROP_XI_LUT_INDEX 	 cv::CAP_PROP_XI_LUT_INDEX
	 CAP_PROP_XI_LUT_VALUE 	 cv::CAP_PROP_XI_LUT_VALUE
	 CAP_PROP_XI_TRG_DELAY 	 cv::CAP_PROP_XI_TRG_DELAY
	 CAP_PROP_XI_TS_RST_MODE 	 cv::CAP_PROP_XI_TS_RST_MODE
	 CAP_PROP_XI_TS_RST_SOURCE 	 cv::CAP_PROP_XI_TS_RST_SOURCE
	 CAP_PROP_XI_IS_DEVICE_EXIST 	 cv::CAP_PROP_XI_IS_DEVICE_EXIST
	 CAP_PROP_XI_ACQ_BUFFER_SIZE 	 cv::CAP_PROP_XI_ACQ_BUFFER_SIZE
	 CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT 	 cv::CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT
	 CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE 	 cv::CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE
	 CAP_PROP_XI_BUFFERS_QUEUE_SIZE 	 cv::CAP_PROP_XI_BUFFERS_QUEUE_SIZE
	 CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT 	 cv::CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT
	 CAP_PROP_XI_RECENT_FRAME 	 cv::CAP_PROP_XI_RECENT_FRAME
	 CAP_PROP_XI_DEVICE_RESET 	 cv::CAP_PROP_XI_DEVICE_RESET
	 CAP_PROP_XI_COLUMN_FPN_CORRECTION 	 cv::CAP_PROP_XI_COLUMN_FPN_CORRECTION
	 CAP_PROP_XI_ROW_FPN_CORRECTION 	 cv::CAP_PROP_XI_ROW_FPN_CORRECTION
	 CAP_PROP_XI_SENSOR_MODE 	 cv::CAP_PROP_XI_SENSOR_MODE
	 CAP_PROP_XI_HDR 	 cv::CAP_PROP_XI_HDR
	 CAP_PROP_XI_HDR_KNEEPOINT_COUNT 	 cv::CAP_PROP_XI_HDR_KNEEPOINT_COUNT
	 CAP_PROP_XI_HDR_T1 	 cv::CAP_PROP_XI_HDR_T1
	 CAP_PROP_XI_HDR_T2 	 cv::CAP_PROP_XI_HDR_T2
	 CAP_PROP_XI_KNEEPOINT1 	 cv::CAP_PROP_XI_KNEEPOINT1
	 CAP_PROP_XI_KNEEPOINT2 	 cv::CAP_PROP_XI_KNEEPOINT2
	 CAP_PROP_XI_IMAGE_BLACK_LEVEL 	 cv::CAP_PROP_XI_IMAGE_BLACK_LEVEL
	 CAP_PROP_XI_HW_REVISION 	 cv::CAP_PROP_XI_HW_REVISION
	 CAP_PROP_XI_DEBUG_LEVEL 	 cv::CAP_PROP_XI_DEBUG_LEVEL
	 CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION 	 cv::CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION
	 CAP_PROP_XI_FFS_FILE_ID 	 cv::CAP_PROP_XI_FFS_FILE_ID
	 CAP_PROP_XI_FFS_FILE_SIZE 	 cv::CAP_PROP_XI_FFS_FILE_SIZE
	 CAP_PROP_XI_FREE_FFS_SIZE 	 cv::CAP_PROP_XI_FREE_FFS_SIZE
	 CAP_PROP_XI_USED_FFS_SIZE 	 cv::CAP_PROP_XI_USED_FFS_SIZE
	 CAP_PROP_XI_FFS_ACCESS_KEY 	 cv::CAP_PROP_XI_FFS_ACCESS_KEY
	 CAP_PROP_XI_SENSOR_FEATURE_SELECTOR 	 cv::CAP_PROP_XI_SENSOR_FEATURE_SELECTOR
	 CAP_PROP_XI_SENSOR_FEATURE_VALUE 	 cv::CAP_PROP_XI_SENSOR_FEATURE_VALUE
	 CAP_PROP_ARAVIS_AUTOTRIGGER 	 cv::CAP_PROP_ARAVIS_AUTOTRIGGER
	 CAP_PROP_IOS_DEVICE_FOCUS 	 cv::CAP_PROP_IOS_DEVICE_FOCUS
	 CAP_PROP_IOS_DEVICE_EXPOSURE 	 cv::CAP_PROP_IOS_DEVICE_EXPOSURE
	 CAP_PROP_IOS_DEVICE_FLASH 	 cv::CAP_PROP_IOS_DEVICE_FLASH
	 CAP_PROP_IOS_DEVICE_WHITEBALANCE 	 cv::CAP_PROP_IOS_DEVICE_WHITEBALANCE
	 CAP_PROP_IOS_DEVICE_TORCH 	 cv::CAP_PROP_IOS_DEVICE_TORCH
	 CAP_PROP_GIGA_FRAME_OFFSET_X 	 cv::CAP_PROP_GIGA_FRAME_OFFSET_X
	 CAP_PROP_GIGA_FRAME_OFFSET_Y 	 cv::CAP_PROP_GIGA_FRAME_OFFSET_Y
	 CAP_PROP_GIGA_FRAME_WIDTH_MAX 	 cv::CAP_PROP_GIGA_FRAME_WIDTH_MAX
	 CAP_PROP_GIGA_FRAME_HEIGH_MAX 	 cv::CAP_PROP_GIGA_FRAME_HEIGH_MAX
	 CAP_PROP_GIGA_FRAME_SENS_WIDTH 	 cv::CAP_PROP_GIGA_FRAME_SENS_WIDTH
	 CAP_PROP_GIGA_FRAME_SENS_HEIGH 	 cv::CAP_PROP_GIGA_FRAME_SENS_HEIGH
	 CAP_PROP_INTELPERC_PROFILE_COUNT 	 cv::CAP_PROP_INTELPERC_PROFILE_COUNT
	 CAP_PROP_INTELPERC_PROFILE_IDX 	 cv::CAP_PROP_INTELPERC_PROFILE_IDX
	 CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE 	 cv::CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE
	 CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE 	 cv::CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE
	 CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD 	 cv::CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD
	 CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ 	 cv::CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ
	 CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT 	 cv::CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT
	 CAP_INTELPERC_DEPTH_GENERATOR 	 cv::CAP_INTELPERC_DEPTH_GENERATOR
	 CAP_INTELPERC_IMAGE_GENERATOR 	 cv::CAP_INTELPERC_IMAGE_GENERATOR
	 CAP_INTELPERC_IR_GENERATOR 	 cv::CAP_INTELPERC_IR_GENERATOR
	 CAP_INTELPERC_GENERATORS_MASK 	 cv::CAP_INTELPERC_GENERATORS_MASK
	 CAP_INTELPERC_DEPTH_MAP 	 cv::CAP_INTELPERC_DEPTH_MAP
	 CAP_INTELPERC_UVDEPTH_MAP 	 cv::CAP_INTELPERC_UVDEPTH_MAP
	 CAP_INTELPERC_IR_MAP 	 cv::CAP_INTELPERC_IR_MAP
	 CAP_INTELPERC_IMAGE 	 cv::CAP_INTELPERC_IMAGE
	 CAP_PROP_GPHOTO2_PREVIEW 	 cv::CAP_PROP_GPHOTO2_PREVIEW
	 CAP_PROP_GPHOTO2_WIDGET_ENUMERATE 	 cv::CAP_PROP_GPHOTO2_WIDGET_ENUMERATE
	 CAP_PROP_GPHOTO2_RELOAD_CONFIG 	 cv::CAP_PROP_GPHOTO2_RELOAD_CONFIG
	 CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE 	 cv::CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE
	 CAP_PROP_GPHOTO2_COLLECT_MSGS 	 cv::CAP_PROP_GPHOTO2_COLLECT_MSGS
	 CAP_PROP_GPHOTO2_FLUSH_MSGS 	 cv::CAP_PROP_GPHOTO2_FLUSH_MSGS
	 CAP_PROP_SPEED 	 cv::CAP_PROP_SPEED
	 CAP_PROP_APERTURE 	 cv::CAP_PROP_APERTURE
	 CAP_PROP_EXPOSUREPROGRAM 	 cv::CAP_PROP_EXPOSUREPROGRAM
	 CAP_PROP_VIEWFINDER 	 cv::CAP_PROP_VIEWFINDER
	 CAP_PROP_IMAGES_BASE 	 cv::CAP_PROP_IMAGES_BASE
	 CAP_PROP_IMAGES_LAST 	 cv::CAP_PROP_IMAGES_LAST
	 WINDOW_NORMAL 	 cv::WINDOW_NORMAL
	 WINDOW_AUTOSIZE 	 cv::WINDOW_AUTOSIZE
	 WINDOW_OPENGL 	 cv::WINDOW_OPENGL
	 WINDOW_FULLSCREEN 	 cv::WINDOW_FULLSCREEN
	 WINDOW_FREERATIO 	 cv::WINDOW_FREERATIO
	 WINDOW_KEEPRATIO 	 cv::WINDOW_KEEPRATIO
	 WINDOW_GUI_EXPANDED 	 cv::WINDOW_GUI_EXPANDED
	 WINDOW_GUI_NORMAL 	 cv::WINDOW_GUI_NORMAL
	 WND_PROP_FULLSCREEN 	 cv::WND_PROP_FULLSCREEN
	 WND_PROP_AUTOSIZE 	 cv::WND_PROP_AUTOSIZE
	 WND_PROP_ASPECT_RATIO 	 cv::WND_PROP_ASPECT_RATIO
	 WND_PROP_OPENGL 	 cv::WND_PROP_OPENGL
	 WND_PROP_VISIBLE 	 cv::WND_PROP_VISIBLE
	 WND_PROP_TOPMOST 	 cv::WND_PROP_TOPMOST
	 EVENT_MOUSEMOVE 	 cv::EVENT_MOUSEMOVE
	 EVENT_LBUTTONDOWN 	 cv::EVENT_LBUTTONDOWN
	 EVENT_RBUTTONDOWN 	 cv::EVENT_RBUTTONDOWN
	 EVENT_MBUTTONDOWN 	 cv::EVENT_MBUTTONDOWN
	 EVENT_LBUTTONUP 	 cv::EVENT_LBUTTONUP
	 EVENT_RBUTTONUP 	 cv::EVENT_RBUTTONUP
	 EVENT_MBUTTONUP 	 cv::EVENT_MBUTTONUP
	 EVENT_LBUTTONDBLCLK 	 cv::EVENT_LBUTTONDBLCLK
	 EVENT_RBUTTONDBLCLK 	 cv::EVENT_RBUTTONDBLCLK
	 EVENT_MBUTTONDBLCLK 	 cv::EVENT_MBUTTONDBLCLK
	 EVENT_MOUSEWHEEL 	 cv::EVENT_MOUSEWHEEL
	 EVENT_MOUSEHWHEEL 	 cv::EVENT_MOUSEHWHEEL
	 EVENT_FLAG_LBUTTON 	 cv::EVENT_FLAG_LBUTTON
	 EVENT_FLAG_RBUTTON 	 cv::EVENT_FLAG_RBUTTON
	 EVENT_FLAG_MBUTTON 	 cv::EVENT_FLAG_MBUTTON
	 EVENT_FLAG_CTRLKEY 	 cv::EVENT_FLAG_CTRLKEY
	 EVENT_FLAG_SHIFTKEY 	 cv::EVENT_FLAG_SHIFTKEY
	 EVENT_FLAG_ALTKEY 	 cv::EVENT_FLAG_ALTKEY
	 QT_FONT_LIGHT 	 cv::QT_FONT_LIGHT
	 QT_FONT_NORMAL 	 cv::QT_FONT_NORMAL
	 QT_FONT_DEMIBOLD 	 cv::QT_FONT_DEMIBOLD
	 QT_FONT_BOLD 	 cv::QT_FONT_BOLD
	 QT_FONT_BLACK 	 cv::QT_FONT_BLACK
	 QT_STYLE_NORMAL 	 cv::QT_STYLE_NORMAL
	 QT_STYLE_ITALIC 	 cv::QT_STYLE_ITALIC
	 QT_STYLE_OBLIQUE 	 cv::QT_STYLE_OBLIQUE
	 QT_PUSH_BUTTON 	 cv::QT_PUSH_BUTTON
	 QT_CHECKBOX 	 cv::QT_CHECKBOX
	 QT_RADIOBOX 	 cv::QT_RADIOBOX
	 QT_NEW_BUTTONBAR 	 cv::QT_NEW_BUTTONBAR


	 SortFlags
	 CovarFlags
	 KmeansFlags
	 ReduceTypes
	 RotateFlags
	 Flags
	 FormatType
	 Param
	 AccessFlag
	 KindFlag
	 DepthMask
	 UMatUsageFlags
	 MemoryFlag
	 SpecialFilter
	 MorphTypes
	 MorphShapes
	 InterpolationFlags
	 WarpPolarMode
	 InterpolationMasks
	 DistanceTypes
	 DistanceTransformMasks
	 ThresholdTypes
	 AdaptiveThresholdTypes
	 GrabCutClasses
	 GrabCutModes
	 DistanceTransformLabelTypes
	 FloodFillFlags
	 ConnectedComponentsTypes
	 ConnectedComponentsAlgorithmsTypes
	 RetrievalModes
	 ContourApproximationModes
	 ShapeMatchModes
	 HoughModes
	 LineSegmentDetectorModes
	 HistCompMethods
	 ColorConversionCodes
	 RectanglesIntersectTypes
	 LineTypes
	 HersheyFonts
	 MarkerTypes
	 TemplateMatchModes
	 ColormapTypes
	 SolvePnPMethod
	 HandEyeCalibrationMethod
	 GridType
	 UndistortTypes
	 ScoreType
	 DetectorType
	 DiffusivityType
	 DescriptorType
	 MatcherType
	 DrawMatchesFlags
	 HistogramNormType
	 DescriptorStorageFormat
	 ImreadModes
	 ImwriteFlags
	 ImwriteEXRTypeFlags
	 ImwritePNGFlags
	 ImwritePAMFlags
	 VideoCaptureAPIs
	 VideoCaptureProperties
	 VideoWriterProperties
	 WindowFlags
	 WindowPropertyFlags
	 MouseEventTypes
	 MouseEventFlags
	 QtFontWeights
	 QtFontStyles
	 QtButtonTypes
cv.ocl
	 ocl_Device False
		 name
		 .method("jlopencv_cv_ocl_Device_name",  [](Device &cobj) { auto retval = cobj.name();  return retval;})
		 name() -> ( retval::String ) 
		 extensions
		 .method("jlopencv_cv_ocl_Device_extensions",  [](Device &cobj) { auto retval = cobj.extensions();  return retval;})
		 extensions() -> ( retval::String ) 
		 isExtensionSupported
		 .method("jlopencv_cv_ocl_Device_isExtensionSupported",  [](Device &cobj, String &extensionName) { auto retval = cobj.isExtensionSupported(extensionName);  return retval;})
		 isExtensionSupported(extensionName::String) -> ( retval::bool ) 
		 version
		 .method("jlopencv_cv_ocl_Device_version",  [](Device &cobj) { auto retval = cobj.version();  return retval;})
		 version() -> ( retval::String ) 
		 vendorName
		 .method("jlopencv_cv_ocl_Device_vendorName",  [](Device &cobj) { auto retval = cobj.vendorName();  return retval;})
		 vendorName() -> ( retval::String ) 
		 OpenCL_C_Version
		 .method("jlopencv_cv_ocl_Device_OpenCL_C_Version",  [](Device &cobj) { auto retval = cobj.OpenCL_C_Version();  return retval;})
		 OpenCL_C_Version() -> ( retval::String ) 
		 OpenCLVersion
		 .method("jlopencv_cv_ocl_Device_OpenCLVersion",  [](Device &cobj) { auto retval = cobj.OpenCLVersion();  return retval;})
		 OpenCLVersion() -> ( retval::String ) 
		 deviceVersionMajor
		 .method("jlopencv_cv_ocl_Device_deviceVersionMajor",  [](Device &cobj) { auto retval = cobj.deviceVersionMajor();  return retval;})
		 deviceVersionMajor() -> ( retval::int ) 
		 deviceVersionMinor
		 .method("jlopencv_cv_ocl_Device_deviceVersionMinor",  [](Device &cobj) { auto retval = cobj.deviceVersionMinor();  return retval;})
		 deviceVersionMinor() -> ( retval::int ) 
		 driverVersion
		 .method("jlopencv_cv_ocl_Device_driverVersion",  [](Device &cobj) { auto retval = cobj.driverVersion();  return retval;})
		 driverVersion() -> ( retval::String ) 
		 type
		 .method("jlopencv_cv_ocl_Device_type",  [](Device &cobj) { auto retval = cobj.type();  return retval;})
		 type() -> ( retval::int ) 
		 addressBits
		 .method("jlopencv_cv_ocl_Device_addressBits",  [](Device &cobj) { auto retval = cobj.addressBits();  return retval;})
		 addressBits() -> ( retval::int ) 
		 available
		 .method("jlopencv_cv_ocl_Device_available",  [](Device &cobj) { auto retval = cobj.available();  return retval;})
		 available() -> ( retval::bool ) 
		 compilerAvailable
		 .method("jlopencv_cv_ocl_Device_compilerAvailable",  [](Device &cobj) { auto retval = cobj.compilerAvailable();  return retval;})
		 compilerAvailable() -> ( retval::bool ) 
		 linkerAvailable
		 .method("jlopencv_cv_ocl_Device_linkerAvailable",  [](Device &cobj) { auto retval = cobj.linkerAvailable();  return retval;})
		 linkerAvailable() -> ( retval::bool ) 
		 doubleFPConfig
		 .method("jlopencv_cv_ocl_Device_doubleFPConfig",  [](Device &cobj) { auto retval = cobj.doubleFPConfig();  return retval;})
		 doubleFPConfig() -> ( retval::int ) 
		 singleFPConfig
		 .method("jlopencv_cv_ocl_Device_singleFPConfig",  [](Device &cobj) { auto retval = cobj.singleFPConfig();  return retval;})
		 singleFPConfig() -> ( retval::int ) 
		 halfFPConfig
		 .method("jlopencv_cv_ocl_Device_halfFPConfig",  [](Device &cobj) { auto retval = cobj.halfFPConfig();  return retval;})
		 halfFPConfig() -> ( retval::int ) 
		 endianLittle
		 .method("jlopencv_cv_ocl_Device_endianLittle",  [](Device &cobj) { auto retval = cobj.endianLittle();  return retval;})
		 endianLittle() -> ( retval::bool ) 
		 errorCorrectionSupport
		 .method("jlopencv_cv_ocl_Device_errorCorrectionSupport",  [](Device &cobj) { auto retval = cobj.errorCorrectionSupport();  return retval;})
		 errorCorrectionSupport() -> ( retval::bool ) 
		 executionCapabilities
		 .method("jlopencv_cv_ocl_Device_executionCapabilities",  [](Device &cobj) { auto retval = cobj.executionCapabilities();  return retval;})
		 executionCapabilities() -> ( retval::int ) 
		 globalMemCacheSize
		 .method("jlopencv_cv_ocl_Device_globalMemCacheSize",  [](Device &cobj) { auto retval = cobj.globalMemCacheSize();  return retval;})
		 globalMemCacheSize() -> ( retval::size_t ) 
		 globalMemCacheType
		 .method("jlopencv_cv_ocl_Device_globalMemCacheType",  [](Device &cobj) { auto retval = cobj.globalMemCacheType();  return retval;})
		 globalMemCacheType() -> ( retval::int ) 
		 globalMemCacheLineSize
		 .method("jlopencv_cv_ocl_Device_globalMemCacheLineSize",  [](Device &cobj) { auto retval = cobj.globalMemCacheLineSize();  return retval;})
		 globalMemCacheLineSize() -> ( retval::int ) 
		 globalMemSize
		 .method("jlopencv_cv_ocl_Device_globalMemSize",  [](Device &cobj) { auto retval = cobj.globalMemSize();  return retval;})
		 globalMemSize() -> ( retval::size_t ) 
		 localMemSize
		 .method("jlopencv_cv_ocl_Device_localMemSize",  [](Device &cobj) { auto retval = cobj.localMemSize();  return retval;})
		 localMemSize() -> ( retval::size_t ) 
		 localMemType
		 .method("jlopencv_cv_ocl_Device_localMemType",  [](Device &cobj) { auto retval = cobj.localMemType();  return retval;})
		 localMemType() -> ( retval::int ) 
		 hostUnifiedMemory
		 .method("jlopencv_cv_ocl_Device_hostUnifiedMemory",  [](Device &cobj) { auto retval = cobj.hostUnifiedMemory();  return retval;})
		 hostUnifiedMemory() -> ( retval::bool ) 
		 imageSupport
		 .method("jlopencv_cv_ocl_Device_imageSupport",  [](Device &cobj) { auto retval = cobj.imageSupport();  return retval;})
		 imageSupport() -> ( retval::bool ) 
		 imageFromBufferSupport
		 .method("jlopencv_cv_ocl_Device_imageFromBufferSupport",  [](Device &cobj) { auto retval = cobj.imageFromBufferSupport();  return retval;})
		 imageFromBufferSupport() -> ( retval::bool ) 
		 intelSubgroupsSupport
		 .method("jlopencv_cv_ocl_Device_intelSubgroupsSupport",  [](Device &cobj) { auto retval = cobj.intelSubgroupsSupport();  return retval;})
		 intelSubgroupsSupport() -> ( retval::bool ) 
		 image2DMaxWidth
		 .method("jlopencv_cv_ocl_Device_image2DMaxWidth",  [](Device &cobj) { auto retval = cobj.image2DMaxWidth();  return retval;})
		 image2DMaxWidth() -> ( retval::size_t ) 
		 image2DMaxHeight
		 .method("jlopencv_cv_ocl_Device_image2DMaxHeight",  [](Device &cobj) { auto retval = cobj.image2DMaxHeight();  return retval;})
		 image2DMaxHeight() -> ( retval::size_t ) 
		 image3DMaxWidth
		 .method("jlopencv_cv_ocl_Device_image3DMaxWidth",  [](Device &cobj) { auto retval = cobj.image3DMaxWidth();  return retval;})
		 image3DMaxWidth() -> ( retval::size_t ) 
		 image3DMaxHeight
		 .method("jlopencv_cv_ocl_Device_image3DMaxHeight",  [](Device &cobj) { auto retval = cobj.image3DMaxHeight();  return retval;})
		 image3DMaxHeight() -> ( retval::size_t ) 
		 image3DMaxDepth
		 .method("jlopencv_cv_ocl_Device_image3DMaxDepth",  [](Device &cobj) { auto retval = cobj.image3DMaxDepth();  return retval;})
		 image3DMaxDepth() -> ( retval::size_t ) 
		 imageMaxBufferSize
		 .method("jlopencv_cv_ocl_Device_imageMaxBufferSize",  [](Device &cobj) { auto retval = cobj.imageMaxBufferSize();  return retval;})
		 imageMaxBufferSize() -> ( retval::size_t ) 
		 imageMaxArraySize
		 .method("jlopencv_cv_ocl_Device_imageMaxArraySize",  [](Device &cobj) { auto retval = cobj.imageMaxArraySize();  return retval;})
		 imageMaxArraySize() -> ( retval::size_t ) 
		 vendorID
		 .method("jlopencv_cv_ocl_Device_vendorID",  [](Device &cobj) { auto retval = cobj.vendorID();  return retval;})
		 vendorID() -> ( retval::int ) 
		 isAMD
		 .method("jlopencv_cv_ocl_Device_isAMD",  [](Device &cobj) { auto retval = cobj.isAMD();  return retval;})
		 isAMD() -> ( retval::bool ) 
		 isIntel
		 .method("jlopencv_cv_ocl_Device_isIntel",  [](Device &cobj) { auto retval = cobj.isIntel();  return retval;})
		 isIntel() -> ( retval::bool ) 
		 isNVidia
		 .method("jlopencv_cv_ocl_Device_isNVidia",  [](Device &cobj) { auto retval = cobj.isNVidia();  return retval;})
		 isNVidia() -> ( retval::bool ) 
		 maxClockFrequency
		 .method("jlopencv_cv_ocl_Device_maxClockFrequency",  [](Device &cobj) { auto retval = cobj.maxClockFrequency();  return retval;})
		 maxClockFrequency() -> ( retval::int ) 
		 maxComputeUnits
		 .method("jlopencv_cv_ocl_Device_maxComputeUnits",  [](Device &cobj) { auto retval = cobj.maxComputeUnits();  return retval;})
		 maxComputeUnits() -> ( retval::int ) 
		 maxConstantArgs
		 .method("jlopencv_cv_ocl_Device_maxConstantArgs",  [](Device &cobj) { auto retval = cobj.maxConstantArgs();  return retval;})
		 maxConstantArgs() -> ( retval::int ) 
		 maxConstantBufferSize
		 .method("jlopencv_cv_ocl_Device_maxConstantBufferSize",  [](Device &cobj) { auto retval = cobj.maxConstantBufferSize();  return retval;})
		 maxConstantBufferSize() -> ( retval::size_t ) 
		 maxMemAllocSize
		 .method("jlopencv_cv_ocl_Device_maxMemAllocSize",  [](Device &cobj) { auto retval = cobj.maxMemAllocSize();  return retval;})
		 maxMemAllocSize() -> ( retval::size_t ) 
		 maxParameterSize
		 .method("jlopencv_cv_ocl_Device_maxParameterSize",  [](Device &cobj) { auto retval = cobj.maxParameterSize();  return retval;})
		 maxParameterSize() -> ( retval::size_t ) 
		 maxReadImageArgs
		 .method("jlopencv_cv_ocl_Device_maxReadImageArgs",  [](Device &cobj) { auto retval = cobj.maxReadImageArgs();  return retval;})
		 maxReadImageArgs() -> ( retval::int ) 
		 maxWriteImageArgs
		 .method("jlopencv_cv_ocl_Device_maxWriteImageArgs",  [](Device &cobj) { auto retval = cobj.maxWriteImageArgs();  return retval;})
		 maxWriteImageArgs() -> ( retval::int ) 
		 maxSamplers
		 .method("jlopencv_cv_ocl_Device_maxSamplers",  [](Device &cobj) { auto retval = cobj.maxSamplers();  return retval;})
		 maxSamplers() -> ( retval::int ) 
		 maxWorkGroupSize
		 .method("jlopencv_cv_ocl_Device_maxWorkGroupSize",  [](Device &cobj) { auto retval = cobj.maxWorkGroupSize();  return retval;})
		 maxWorkGroupSize() -> ( retval::size_t ) 
		 maxWorkItemDims
		 .method("jlopencv_cv_ocl_Device_maxWorkItemDims",  [](Device &cobj) { auto retval = cobj.maxWorkItemDims();  return retval;})
		 maxWorkItemDims() -> ( retval::int ) 
		 memBaseAddrAlign
		 .method("jlopencv_cv_ocl_Device_memBaseAddrAlign",  [](Device &cobj) { auto retval = cobj.memBaseAddrAlign();  return retval;})
		 memBaseAddrAlign() -> ( retval::int ) 
		 nativeVectorWidthChar
		 .method("jlopencv_cv_ocl_Device_nativeVectorWidthChar",  [](Device &cobj) { auto retval = cobj.nativeVectorWidthChar();  return retval;})
		 nativeVectorWidthChar() -> ( retval::int ) 
		 nativeVectorWidthShort
		 .method("jlopencv_cv_ocl_Device_nativeVectorWidthShort",  [](Device &cobj) { auto retval = cobj.nativeVectorWidthShort();  return retval;})
		 nativeVectorWidthShort() -> ( retval::int ) 
		 nativeVectorWidthInt
		 .method("jlopencv_cv_ocl_Device_nativeVectorWidthInt",  [](Device &cobj) { auto retval = cobj.nativeVectorWidthInt();  return retval;})
		 nativeVectorWidthInt() -> ( retval::int ) 
		 nativeVectorWidthLong
		 .method("jlopencv_cv_ocl_Device_nativeVectorWidthLong",  [](Device &cobj) { auto retval = cobj.nativeVectorWidthLong();  return retval;})
		 nativeVectorWidthLong() -> ( retval::int ) 
		 nativeVectorWidthFloat
		 .method("jlopencv_cv_ocl_Device_nativeVectorWidthFloat",  [](Device &cobj) { auto retval = cobj.nativeVectorWidthFloat();  return retval;})
		 nativeVectorWidthFloat() -> ( retval::int ) 
		 nativeVectorWidthDouble
		 .method("jlopencv_cv_ocl_Device_nativeVectorWidthDouble",  [](Device &cobj) { auto retval = cobj.nativeVectorWidthDouble();  return retval;})
		 nativeVectorWidthDouble() -> ( retval::int ) 
		 nativeVectorWidthHalf
		 .method("jlopencv_cv_ocl_Device_nativeVectorWidthHalf",  [](Device &cobj) { auto retval = cobj.nativeVectorWidthHalf();  return retval;})
		 nativeVectorWidthHalf() -> ( retval::int ) 
		 preferredVectorWidthChar
		 .method("jlopencv_cv_ocl_Device_preferredVectorWidthChar",  [](Device &cobj) { auto retval = cobj.preferredVectorWidthChar();  return retval;})
		 preferredVectorWidthChar() -> ( retval::int ) 
		 preferredVectorWidthShort
		 .method("jlopencv_cv_ocl_Device_preferredVectorWidthShort",  [](Device &cobj) { auto retval = cobj.preferredVectorWidthShort();  return retval;})
		 preferredVectorWidthShort() -> ( retval::int ) 
		 preferredVectorWidthInt
		 .method("jlopencv_cv_ocl_Device_preferredVectorWidthInt",  [](Device &cobj) { auto retval = cobj.preferredVectorWidthInt();  return retval;})
		 preferredVectorWidthInt() -> ( retval::int ) 
		 preferredVectorWidthLong
		 .method("jlopencv_cv_ocl_Device_preferredVectorWidthLong",  [](Device &cobj) { auto retval = cobj.preferredVectorWidthLong();  return retval;})
		 preferredVectorWidthLong() -> ( retval::int ) 
		 preferredVectorWidthFloat
		 .method("jlopencv_cv_ocl_Device_preferredVectorWidthFloat",  [](Device &cobj) { auto retval = cobj.preferredVectorWidthFloat();  return retval;})
		 preferredVectorWidthFloat() -> ( retval::int ) 
		 preferredVectorWidthDouble
		 .method("jlopencv_cv_ocl_Device_preferredVectorWidthDouble",  [](Device &cobj) { auto retval = cobj.preferredVectorWidthDouble();  return retval;})
		 preferredVectorWidthDouble() -> ( retval::int ) 
		 preferredVectorWidthHalf
		 .method("jlopencv_cv_ocl_Device_preferredVectorWidthHalf",  [](Device &cobj) { auto retval = cobj.preferredVectorWidthHalf();  return retval;})
		 preferredVectorWidthHalf() -> ( retval::int ) 
		 printfBufferSize
		 .method("jlopencv_cv_ocl_Device_printfBufferSize",  [](Device &cobj) { auto retval = cobj.printfBufferSize();  return retval;})
		 printfBufferSize() -> ( retval::size_t ) 
		 profilingTimerResolution
		 .method("jlopencv_cv_ocl_Device_profilingTimerResolution",  [](Device &cobj) { auto retval = cobj.profilingTimerResolution();  return retval;})
		 profilingTimerResolution() -> ( retval::size_t ) 
		 getDefault
		 .method("jlopencv_cv_ocl_Device_getDefault",  [](Device &cobj) { auto retval = cv::ocl::Device::getDefault(); return retval;})
		 getDefault() -> ( retval::Device ) 
	 .add_type<cv::ocl::Device>("ocl_Device").constructor<>()
	 function Base.getproperty(m::ocl_Device, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ocl_Device, s::Symbol, v)
    return Base.setfield(m, s, v)
end



	 haveOpenCL
	 .method("jlopencv_cv_ocl_haveOpenCL",  []() { auto retval = cv::ocl::haveOpenCL(); return retval;})
		 haveOpenCL() -> ( retval::bool ) 
	 useOpenCL
	 .method("jlopencv_cv_ocl_useOpenCL",  []() { auto retval = cv::ocl::useOpenCL(); return retval;})
		 useOpenCL() -> ( retval::bool ) 
	 haveAmdBlas
	 .method("jlopencv_cv_ocl_haveAmdBlas",  []() { auto retval = cv::ocl::haveAmdBlas(); return retval;})
		 haveAmdBlas() -> ( retval::bool ) 
	 haveAmdFft
	 .method("jlopencv_cv_ocl_haveAmdFft",  []() { auto retval = cv::ocl::haveAmdFft(); return retval;})
		 haveAmdFft() -> ( retval::bool ) 
	 setUseOpenCL
	 .method("jlopencv_cv_ocl_setUseOpenCL",  [](bool &flag) { cv::ocl::setUseOpenCL(flag); ;})
		 setUseOpenCL(flag::bool) -> nothing
	 finish
	 .method("jlopencv_cv_ocl_finish",  []() { cv::ocl::finish(); ;})
		 finish() -> nothing
	 Device_getDefault
	 .method("jlopencv_cv_ocl_Device_getDefault",  []() { auto retval = cv::ocl::Device::getDefault(); return retval;})
		 Device_getDefault() -> ( retval::Device ) 


	 Device_TYPE_DEFAULT 	 cv::ocl::Device::TYPE_DEFAULT
	 Device_TYPE_CPU 	 cv::ocl::Device::TYPE_CPU
	 Device_TYPE_GPU 	 cv::ocl::Device::TYPE_GPU
	 Device_TYPE_ACCELERATOR 	 cv::ocl::Device::TYPE_ACCELERATOR
	 Device_TYPE_DGPU 	 cv::ocl::Device::TYPE_DGPU
	 Device_TYPE_IGPU 	 cv::ocl::Device::TYPE_IGPU
	 Device_TYPE_ALL 	 cv::ocl::Device::TYPE_ALL
	 Device_FP_DENORM 	 cv::ocl::Device::FP_DENORM
	 Device_FP_INF_NAN 	 cv::ocl::Device::FP_INF_NAN
	 Device_FP_ROUND_TO_NEAREST 	 cv::ocl::Device::FP_ROUND_TO_NEAREST
	 Device_FP_ROUND_TO_ZERO 	 cv::ocl::Device::FP_ROUND_TO_ZERO
	 Device_FP_ROUND_TO_INF 	 cv::ocl::Device::FP_ROUND_TO_INF
	 Device_FP_FMA 	 cv::ocl::Device::FP_FMA
	 Device_FP_SOFT_FLOAT 	 cv::ocl::Device::FP_SOFT_FLOAT
	 Device_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT 	 cv::ocl::Device::FP_CORRECTLY_ROUNDED_DIVIDE_SQRT
	 Device_EXEC_KERNEL 	 cv::ocl::Device::EXEC_KERNEL
	 Device_EXEC_NATIVE_KERNEL 	 cv::ocl::Device::EXEC_NATIVE_KERNEL
	 Device_NO_CACHE 	 cv::ocl::Device::NO_CACHE
	 Device_READ_ONLY_CACHE 	 cv::ocl::Device::READ_ONLY_CACHE
	 Device_READ_WRITE_CACHE 	 cv::ocl::Device::READ_WRITE_CACHE
	 Device_NO_LOCAL_MEM 	 cv::ocl::Device::NO_LOCAL_MEM
	 Device_LOCAL_IS_LOCAL 	 cv::ocl::Device::LOCAL_IS_LOCAL
	 Device_LOCAL_IS_GLOBAL 	 cv::ocl::Device::LOCAL_IS_GLOBAL
	 Device_UNKNOWN_VENDOR 	 cv::ocl::Device::UNKNOWN_VENDOR
	 Device_VENDOR_AMD 	 cv::ocl::Device::VENDOR_AMD
	 Device_VENDOR_INTEL 	 cv::ocl::Device::VENDOR_INTEL
	 Device_VENDOR_NVIDIA 	 cv::ocl::Device::VENDOR_NVIDIA
	 KernelArg_LOCAL 	 cv::ocl::KernelArg::LOCAL
	 KernelArg_READ_ONLY 	 cv::ocl::KernelArg::READ_ONLY
	 KernelArg_WRITE_ONLY 	 cv::ocl::KernelArg::WRITE_ONLY
	 KernelArg_READ_WRITE 	 cv::ocl::KernelArg::READ_WRITE
	 KernelArg_CONSTANT 	 cv::ocl::KernelArg::CONSTANT
	 KernelArg_PTR_ONLY 	 cv::ocl::KernelArg::PTR_ONLY
	 KernelArg_NO_SIZE 	 cv::ocl::KernelArg::NO_SIZE
	 OCL_VECTOR_OWN 	 cv::ocl::OCL_VECTOR_OWN
	 OCL_VECTOR_MAX 	 cv::ocl::OCL_VECTOR_MAX
	 OCL_VECTOR_DEFAULT 	 cv::ocl::OCL_VECTOR_DEFAULT


	 OclVectorStrategy
cv.flann
	 flann_Index False
		 build
		 .method("jlopencv_cv_flann_Index_build",  [](Index &cobj, Mat &features, IndexParams &params, cvflann_flann_distance_t &distType) { cobj.build(features, params, distType);  ;})
		 build(features::Mat, params::IndexParams, distType::cvflann_flann_distance_t) -> nothing
		 build
		 .method("jlopencv_cv_flann_Index_build",  [](Index &cobj, UMat &features, IndexParams &params, cvflann_flann_distance_t &distType) { cobj.build(features, params, distType);  ;})
		 build(features::UMat, params::IndexParams, distType::cvflann_flann_distance_t) -> nothing
		 knnSearch
		 .method("jlopencv_cv_flann_Index_knnSearch",  [](Index &cobj, Mat &query, int &knn, Mat &indices, Mat &dists, SearchParams &params) { cobj.knnSearch(query, indices, dists, knn, params);  return make_tuple<Mat,Mat>(indices,dists);})
		 knnSearch(query::Mat, knn::int, indices::Mat, dists::Mat, params::SearchParams) -> ( indices::Mat, dists::Mat ) 
		 knnSearch
		 .method("jlopencv_cv_flann_Index_knnSearch",  [](Index &cobj, UMat &query, int &knn, UMat &indices, UMat &dists, SearchParams &params) { cobj.knnSearch(query, indices, dists, knn, params);  return make_tuple<UMat,UMat>(indices,dists);})
		 knnSearch(query::UMat, knn::int, indices::UMat, dists::UMat, params::SearchParams) -> ( indices::UMat, dists::UMat ) 
		 radiusSearch
		 .method("jlopencv_cv_flann_Index_radiusSearch",  [](Index &cobj, Mat &query, double &radius, int &maxResults, Mat &indices, Mat &dists, SearchParams &params) { auto retval = cobj.radiusSearch(query, indices, dists, radius, maxResults, params);  return make_tuple<int,Mat,Mat>(retval,indices,dists);})
		 radiusSearch(query::Mat, radius::double, maxResults::int, indices::Mat, dists::Mat, params::SearchParams) -> ( retval::int, indices::Mat, dists::Mat ) 
		 radiusSearch
		 .method("jlopencv_cv_flann_Index_radiusSearch",  [](Index &cobj, UMat &query, double &radius, int &maxResults, UMat &indices, UMat &dists, SearchParams &params) { auto retval = cobj.radiusSearch(query, indices, dists, radius, maxResults, params);  return make_tuple<int,UMat,UMat>(retval,indices,dists);})
		 radiusSearch(query::UMat, radius::double, maxResults::int, indices::UMat, dists::UMat, params::SearchParams) -> ( retval::int, indices::UMat, dists::UMat ) 
		 save
		 .method("jlopencv_cv_flann_Index_save",  [](Index &cobj, String &filename) { cobj.save(filename);  ;})
		 save(filename::String) -> nothing
		 load
		 .method("jlopencv_cv_flann_Index_load",  [](Index &cobj, Mat &features, String &filename) { auto retval = cobj.load(features, filename);  return retval;})
		 load(features::Mat, filename::String) -> ( retval::bool ) 
		 load
		 .method("jlopencv_cv_flann_Index_load",  [](Index &cobj, UMat &features, String &filename) { auto retval = cobj.load(features, filename);  return retval;})
		 load(features::UMat, filename::String) -> ( retval::bool ) 
		 release
		 .method("jlopencv_cv_flann_Index_release",  [](Index &cobj) { cobj.release();  ;})
		 release() -> nothing
		 getDistance
		 .method("jlopencv_cv_flann_Index_getDistance",  [](Index &cobj) { auto retval = cobj.getDistance();  return retval;})
		 getDistance() -> ( retval::cvflann::flann_distance_t ) 
		 getAlgorithm
		 .method("jlopencv_cv_flann_Index_getAlgorithm",  [](Index &cobj) { auto retval = cobj.getAlgorithm();  return retval;})
		 getAlgorithm() -> ( retval::cvflann::flann_algorithm_t ) 
	 .add_type<cv::flann::Index>("flann_Index").constructor<>().constructor<const Mat&,const IndexParams&,const cvflann_flann_distance_t&>().constructor<const UMat&,const IndexParams&,const cvflann_flann_distance_t&>()
	 function Base.getproperty(m::flann_Index, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::flann_Index, s::Symbol, v)
    return Base.setfield(m, s, v)
end





	 FLANN_INDEX_TYPE_8U 	 cv::flann::FLANN_INDEX_TYPE_8U
	 FLANN_INDEX_TYPE_8S 	 cv::flann::FLANN_INDEX_TYPE_8S
	 FLANN_INDEX_TYPE_16U 	 cv::flann::FLANN_INDEX_TYPE_16U
	 FLANN_INDEX_TYPE_16S 	 cv::flann::FLANN_INDEX_TYPE_16S
	 FLANN_INDEX_TYPE_32S 	 cv::flann::FLANN_INDEX_TYPE_32S
	 FLANN_INDEX_TYPE_32F 	 cv::flann::FLANN_INDEX_TYPE_32F
	 FLANN_INDEX_TYPE_64F 	 cv::flann::FLANN_INDEX_TYPE_64F
	 FLANN_INDEX_TYPE_STRING 	 cv::flann::FLANN_INDEX_TYPE_STRING
	 FLANN_INDEX_TYPE_BOOL 	 cv::flann::FLANN_INDEX_TYPE_BOOL
	 FLANN_INDEX_TYPE_ALGORITHM 	 cv::flann::FLANN_INDEX_TYPE_ALGORITHM
	 LAST_VALUE_FLANN_INDEX_TYPE 	 cv::flann::LAST_VALUE_FLANN_INDEX_TYPE


	 FlannIndexType
cv.ml
	 ml_ParamGrid False
		 create
		 .method("jlopencv_cv_ml_ParamGrid_create",  [](ParamGrid &cobj, double &minVal, double &maxVal, double &logstep) { auto retval = cv::ml::ParamGrid::create(minVal, maxVal, logstep); return retval;})
		 create(minVal::double, maxVal::double, logstep::double) -> ( retval::Ptr<ParamGrid> ) 
	 .add_type<cv::ml::ParamGrid>("ml_ParamGrid").method("jlopencv_ml_ParamGrid_set_minVal", [](cv::ml::ParamGrid &cobj,const double &v) {cobj.minVal=v;}).method("jlopencv_ml_ParamGrid_set_maxVal", [](cv::ml::ParamGrid &cobj,const double &v) {cobj.maxVal=v;}).method("jlopencv_ml_ParamGrid_set_logStep", [](cv::ml::ParamGrid &cobj,const double &v) {cobj.logStep=v;}).method("jlopencv_ml_ParamGrid_get_minVal", [](const cv::ml::ParamGrid &cobj) {return cobj.minVal;}).method("jlopencv_ml_ParamGrid_get_maxVal", [](const cv::ml::ParamGrid &cobj) {return cobj.maxVal;}).method("jlopencv_ml_ParamGrid_get_logStep", [](const cv::ml::ParamGrid &cobj) {return cobj.logStep;})
	 function Base.getproperty(m::ml_ParamGrid, s::Symbol)
    if s==:minVal
        return jlopencv_argconvert_jl(jlopencv_ml_ParamGrid_get_minVal(m))
    end
    if s==:maxVal
        return jlopencv_argconvert_jl(jlopencv_ml_ParamGrid_get_maxVal(m))
    end
    if s==:logStep
        return jlopencv_argconvert_jl(jlopencv_ml_ParamGrid_get_logStep(m))
    end
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ml_ParamGrid, s::Symbol, v)
    if s==:minVal
        jlopencv_ml_ParamGrid_set_minVal(m, jlopencv_argconvert_cpp(v))
    end
    if s==:maxVal
        jlopencv_ml_ParamGrid_set_maxVal(m, jlopencv_argconvert_cpp(v))
    end
    if s==:logStep
        jlopencv_ml_ParamGrid_set_logStep(m, jlopencv_argconvert_cpp(v))
    end
    return Base.setfield(m, s, v)
end

	 ml_TrainData False
		 getLayout
		 .method("jlopencv_cv_ml_TrainData_getLayout",  [](TrainData &cobj) { auto retval = cobj.getLayout();  return retval;})
		 getLayout() -> ( retval::int ) 
		 getNTrainSamples
		 .method("jlopencv_cv_ml_TrainData_getNTrainSamples",  [](TrainData &cobj) { auto retval = cobj.getNTrainSamples();  return retval;})
		 getNTrainSamples() -> ( retval::int ) 
		 getNTestSamples
		 .method("jlopencv_cv_ml_TrainData_getNTestSamples",  [](TrainData &cobj) { auto retval = cobj.getNTestSamples();  return retval;})
		 getNTestSamples() -> ( retval::int ) 
		 getNSamples
		 .method("jlopencv_cv_ml_TrainData_getNSamples",  [](TrainData &cobj) { auto retval = cobj.getNSamples();  return retval;})
		 getNSamples() -> ( retval::int ) 
		 getNVars
		 .method("jlopencv_cv_ml_TrainData_getNVars",  [](TrainData &cobj) { auto retval = cobj.getNVars();  return retval;})
		 getNVars() -> ( retval::int ) 
		 getNAllVars
		 .method("jlopencv_cv_ml_TrainData_getNAllVars",  [](TrainData &cobj) { auto retval = cobj.getNAllVars();  return retval;})
		 getNAllVars() -> ( retval::int ) 
		 getSample
		 .method("jlopencv_cv_ml_TrainData_getSample",  [](TrainData &cobj, Mat &varIdx, int &sidx, float &buf) { cobj.getSample(varIdx, sidx, &buf);  ;})
		 getSample(varIdx::Mat, sidx::int, buf::float*) -> nothing
		 getSample
		 .method("jlopencv_cv_ml_TrainData_getSample",  [](TrainData &cobj, UMat &varIdx, int &sidx, float &buf) { cobj.getSample(varIdx, sidx, &buf);  ;})
		 getSample(varIdx::UMat, sidx::int, buf::float*) -> nothing
		 getSamples
		 .method("jlopencv_cv_ml_TrainData_getSamples",  [](TrainData &cobj) { auto retval = cobj.getSamples();  return retval;})
		 getSamples() -> ( retval::Mat ) 
		 getMissing
		 .method("jlopencv_cv_ml_TrainData_getMissing",  [](TrainData &cobj) { auto retval = cobj.getMissing();  return retval;})
		 getMissing() -> ( retval::Mat ) 
		 getTrainSamples
		 .method("jlopencv_cv_ml_TrainData_getTrainSamples",  [](TrainData &cobj, int &layout, bool &compressSamples, bool &compressVars) { auto retval = cobj.getTrainSamples(layout, compressSamples, compressVars);  return retval;})
		 getTrainSamples(layout::int, compressSamples::bool, compressVars::bool) -> ( retval::Mat ) 
		 getTrainResponses
		 .method("jlopencv_cv_ml_TrainData_getTrainResponses",  [](TrainData &cobj) { auto retval = cobj.getTrainResponses();  return retval;})
		 getTrainResponses() -> ( retval::Mat ) 
		 getTrainNormCatResponses
		 .method("jlopencv_cv_ml_TrainData_getTrainNormCatResponses",  [](TrainData &cobj) { auto retval = cobj.getTrainNormCatResponses();  return retval;})
		 getTrainNormCatResponses() -> ( retval::Mat ) 
		 getTestResponses
		 .method("jlopencv_cv_ml_TrainData_getTestResponses",  [](TrainData &cobj) { auto retval = cobj.getTestResponses();  return retval;})
		 getTestResponses() -> ( retval::Mat ) 
		 getTestNormCatResponses
		 .method("jlopencv_cv_ml_TrainData_getTestNormCatResponses",  [](TrainData &cobj) { auto retval = cobj.getTestNormCatResponses();  return retval;})
		 getTestNormCatResponses() -> ( retval::Mat ) 
		 getResponses
		 .method("jlopencv_cv_ml_TrainData_getResponses",  [](TrainData &cobj) { auto retval = cobj.getResponses();  return retval;})
		 getResponses() -> ( retval::Mat ) 
		 getNormCatResponses
		 .method("jlopencv_cv_ml_TrainData_getNormCatResponses",  [](TrainData &cobj) { auto retval = cobj.getNormCatResponses();  return retval;})
		 getNormCatResponses() -> ( retval::Mat ) 
		 getSampleWeights
		 .method("jlopencv_cv_ml_TrainData_getSampleWeights",  [](TrainData &cobj) { auto retval = cobj.getSampleWeights();  return retval;})
		 getSampleWeights() -> ( retval::Mat ) 
		 getTrainSampleWeights
		 .method("jlopencv_cv_ml_TrainData_getTrainSampleWeights",  [](TrainData &cobj) { auto retval = cobj.getTrainSampleWeights();  return retval;})
		 getTrainSampleWeights() -> ( retval::Mat ) 
		 getTestSampleWeights
		 .method("jlopencv_cv_ml_TrainData_getTestSampleWeights",  [](TrainData &cobj) { auto retval = cobj.getTestSampleWeights();  return retval;})
		 getTestSampleWeights() -> ( retval::Mat ) 
		 getVarIdx
		 .method("jlopencv_cv_ml_TrainData_getVarIdx",  [](TrainData &cobj) { auto retval = cobj.getVarIdx();  return retval;})
		 getVarIdx() -> ( retval::Mat ) 
		 getVarType
		 .method("jlopencv_cv_ml_TrainData_getVarType",  [](TrainData &cobj) { auto retval = cobj.getVarType();  return retval;})
		 getVarType() -> ( retval::Mat ) 
		 getVarSymbolFlags
		 .method("jlopencv_cv_ml_TrainData_getVarSymbolFlags",  [](TrainData &cobj) { auto retval = cobj.getVarSymbolFlags();  return retval;})
		 getVarSymbolFlags() -> ( retval::Mat ) 
		 getResponseType
		 .method("jlopencv_cv_ml_TrainData_getResponseType",  [](TrainData &cobj) { auto retval = cobj.getResponseType();  return retval;})
		 getResponseType() -> ( retval::int ) 
		 getTrainSampleIdx
		 .method("jlopencv_cv_ml_TrainData_getTrainSampleIdx",  [](TrainData &cobj) { auto retval = cobj.getTrainSampleIdx();  return retval;})
		 getTrainSampleIdx() -> ( retval::Mat ) 
		 getTestSampleIdx
		 .method("jlopencv_cv_ml_TrainData_getTestSampleIdx",  [](TrainData &cobj) { auto retval = cobj.getTestSampleIdx();  return retval;})
		 getTestSampleIdx() -> ( retval::Mat ) 
		 getValues
		 .method("jlopencv_cv_ml_TrainData_getValues",  [](TrainData &cobj, int &vi, Mat &sidx, float &values) { cobj.getValues(vi, sidx, &values);  ;})
		 getValues(vi::int, sidx::Mat, values::float*) -> nothing
		 getValues
		 .method("jlopencv_cv_ml_TrainData_getValues",  [](TrainData &cobj, int &vi, UMat &sidx, float &values) { cobj.getValues(vi, sidx, &values);  ;})
		 getValues(vi::int, sidx::UMat, values::float*) -> nothing
		 getDefaultSubstValues
		 .method("jlopencv_cv_ml_TrainData_getDefaultSubstValues",  [](TrainData &cobj) { auto retval = cobj.getDefaultSubstValues();  return retval;})
		 getDefaultSubstValues() -> ( retval::Mat ) 
		 getCatCount
		 .method("jlopencv_cv_ml_TrainData_getCatCount",  [](TrainData &cobj, int &vi) { auto retval = cobj.getCatCount(vi);  return retval;})
		 getCatCount(vi::int) -> ( retval::int ) 
		 getClassLabels
		 .method("jlopencv_cv_ml_TrainData_getClassLabels",  [](TrainData &cobj) { auto retval = cobj.getClassLabels();  return retval;})
		 getClassLabels() -> ( retval::Mat ) 
		 getCatOfs
		 .method("jlopencv_cv_ml_TrainData_getCatOfs",  [](TrainData &cobj) { auto retval = cobj.getCatOfs();  return retval;})
		 getCatOfs() -> ( retval::Mat ) 
		 getCatMap
		 .method("jlopencv_cv_ml_TrainData_getCatMap",  [](TrainData &cobj) { auto retval = cobj.getCatMap();  return retval;})
		 getCatMap() -> ( retval::Mat ) 
		 setTrainTestSplit
		 .method("jlopencv_cv_ml_TrainData_setTrainTestSplit",  [](TrainData &cobj, int &count, bool &shuffle) { cobj.setTrainTestSplit(count, shuffle);  ;})
		 setTrainTestSplit(count::int, shuffle::bool) -> nothing
		 setTrainTestSplitRatio
		 .method("jlopencv_cv_ml_TrainData_setTrainTestSplitRatio",  [](TrainData &cobj, double &ratio, bool &shuffle) { cobj.setTrainTestSplitRatio(ratio, shuffle);  ;})
		 setTrainTestSplitRatio(ratio::double, shuffle::bool) -> nothing
		 shuffleTrainTest
		 .method("jlopencv_cv_ml_TrainData_shuffleTrainTest",  [](TrainData &cobj) { cobj.shuffleTrainTest();  ;})
		 shuffleTrainTest() -> nothing
		 getTestSamples
		 .method("jlopencv_cv_ml_TrainData_getTestSamples",  [](TrainData &cobj) { auto retval = cobj.getTestSamples();  return retval;})
		 getTestSamples() -> ( retval::Mat ) 
		 getNames
		 .method("jlopencv_cv_ml_TrainData_getNames",  [](TrainData &cobj, vector<String> &names) { cobj.getNames(names);  ;})
		 getNames(names::vector<String>) -> nothing
		 getSubVector
		 .method("jlopencv_cv_ml_TrainData_getSubVector",  [](TrainData &cobj, Mat &vec, Mat &idx) { auto retval = cv::ml::TrainData::getSubVector(vec, idx); return retval;})
		 getSubVector(vec::Mat, idx::Mat) -> ( retval::Mat ) 
		 getSubVector
		 .method("jlopencv_cv_ml_TrainData_getSubVector",  [](TrainData &cobj, Mat &vec, Mat &idx) { auto retval = cv::ml::TrainData::getSubVector(vec, idx); return retval;})
		 getSubVector(vec::Mat, idx::Mat) -> ( retval::Mat ) 
		 getSubMatrix
		 .method("jlopencv_cv_ml_TrainData_getSubMatrix",  [](TrainData &cobj, Mat &matrix, Mat &idx, int &layout) { auto retval = cv::ml::TrainData::getSubMatrix(matrix, idx, layout); return retval;})
		 getSubMatrix(matrix::Mat, idx::Mat, layout::int) -> ( retval::Mat ) 
		 getSubMatrix
		 .method("jlopencv_cv_ml_TrainData_getSubMatrix",  [](TrainData &cobj, Mat &matrix, Mat &idx, int &layout) { auto retval = cv::ml::TrainData::getSubMatrix(matrix, idx, layout); return retval;})
		 getSubMatrix(matrix::Mat, idx::Mat, layout::int) -> ( retval::Mat ) 
		 create
		 .method("jlopencv_cv_ml_TrainData_create",  [](TrainData &cobj, Mat &samples, int &layout, Mat &responses, Mat &varIdx, Mat &sampleIdx, Mat &sampleWeights, Mat &varType) { auto retval = cv::ml::TrainData::create(samples, layout, responses, varIdx, sampleIdx, sampleWeights, varType); return retval;})
		 create(samples::Mat, layout::int, responses::Mat, varIdx::Mat, sampleIdx::Mat, sampleWeights::Mat, varType::Mat) -> ( retval::Ptr<TrainData> ) 
		 create
		 .method("jlopencv_cv_ml_TrainData_create",  [](TrainData &cobj, UMat &samples, int &layout, UMat &responses, UMat &varIdx, UMat &sampleIdx, UMat &sampleWeights, UMat &varType) { auto retval = cv::ml::TrainData::create(samples, layout, responses, varIdx, sampleIdx, sampleWeights, varType); return retval;})
		 create(samples::UMat, layout::int, responses::UMat, varIdx::UMat, sampleIdx::UMat, sampleWeights::UMat, varType::UMat) -> ( retval::Ptr<TrainData> ) 
	 .add_type<cv::ml::TrainData>("ml_TrainData")
	 function Base.getproperty(m::ml_TrainData, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ml_TrainData, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 ml_StatModel True
		 getVarCount
		 .method("jlopencv_cv_ml_StatModel_getVarCount",  [](cv::Ptr<StatModel> &cobj) { auto retval = cobj->getVarCount();  return retval;})
		 getVarCount() -> ( retval::int ) 
		 empty
		 .method("jlopencv_cv_ml_StatModel_empty",  [](cv::Ptr<StatModel> &cobj) { auto retval = cobj->empty();  return retval;})
		 empty() -> ( retval::bool ) 
		 isTrained
		 .method("jlopencv_cv_ml_StatModel_isTrained",  [](cv::Ptr<StatModel> &cobj) { auto retval = cobj->isTrained();  return retval;})
		 isTrained() -> ( retval::bool ) 
		 isClassifier
		 .method("jlopencv_cv_ml_StatModel_isClassifier",  [](cv::Ptr<StatModel> &cobj) { auto retval = cobj->isClassifier();  return retval;})
		 isClassifier() -> ( retval::bool ) 
		 train
		 .method("jlopencv_cv_ml_StatModel_train",  [](cv::Ptr<StatModel> &cobj, Ptr<TrainData> &trainData, int &flags) { auto retval = cobj->train(trainData, flags);  return retval;})
		 train(trainData::Ptr<TrainData>, flags::int) -> ( retval::bool ) 
		 train
		 .method("jlopencv_cv_ml_StatModel_train",  [](cv::Ptr<StatModel> &cobj, Mat &samples, int &layout, Mat &responses) { auto retval = cobj->train(samples, layout, responses);  return retval;})
		 train(samples::Mat, layout::int, responses::Mat) -> ( retval::bool ) 
		 train
		 .method("jlopencv_cv_ml_StatModel_train",  [](cv::Ptr<StatModel> &cobj, UMat &samples, int &layout, UMat &responses) { auto retval = cobj->train(samples, layout, responses);  return retval;})
		 train(samples::UMat, layout::int, responses::UMat) -> ( retval::bool ) 
		 calcError
		 .method("jlopencv_cv_ml_StatModel_calcError",  [](cv::Ptr<StatModel> &cobj, Ptr<TrainData> &data, bool &test, Mat &resp) { auto retval = cobj->calcError(data, test, resp);  return make_tuple<float,Mat>(retval,resp);})
		 calcError(data::Ptr<TrainData>, test::bool; resp::Mat) -> ( retval::float, resp::Mat ) 
		 calcError
		 .method("jlopencv_cv_ml_StatModel_calcError",  [](cv::Ptr<StatModel> &cobj, Ptr<TrainData> &data, bool &test, UMat &resp) { auto retval = cobj->calcError(data, test, resp);  return make_tuple<float,UMat>(retval,resp);})
		 calcError(data::Ptr<TrainData>, test::bool; resp::UMat) -> ( retval::float, resp::UMat ) 
		 predict
		 .method("jlopencv_cv_ml_StatModel_predict",  [](cv::Ptr<StatModel> &cobj, Mat &samples, Mat &results, int &flags) { auto retval = cobj->predict(samples, results, flags);  return make_tuple<float,Mat>(retval,results);})
		 predict(samples::Mat, results::Mat, flags::int) -> ( retval::float, results::Mat ) 
		 predict
		 .method("jlopencv_cv_ml_StatModel_predict",  [](cv::Ptr<StatModel> &cobj, UMat &samples, UMat &results, int &flags) { auto retval = cobj->predict(samples, results, flags);  return make_tuple<float,UMat>(retval,results);})
		 predict(samples::UMat, results::UMat, flags::int) -> ( retval::float, results::UMat ) 
	 WIP
	 function Base.getproperty(m::ml_StatModel, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ml_StatModel, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 ml_NormalBayesClassifier True
		 predictProb
		 .method("jlopencv_cv_ml_NormalBayesClassifier_predictProb",  [](cv::Ptr<NormalBayesClassifier> &cobj, Mat &inputs, Mat &outputs, Mat &outputProbs, int &flags) { auto retval = cobj->predictProb(inputs, outputs, outputProbs, flags);  return make_tuple<float,Mat,Mat>(retval,outputs,outputProbs);})
		 predictProb(inputs::Mat, outputs::Mat, outputProbs::Mat, flags::int) -> ( retval::float, outputs::Mat, outputProbs::Mat ) 
		 predictProb
		 .method("jlopencv_cv_ml_NormalBayesClassifier_predictProb",  [](cv::Ptr<NormalBayesClassifier> &cobj, UMat &inputs, UMat &outputs, UMat &outputProbs, int &flags) { auto retval = cobj->predictProb(inputs, outputs, outputProbs, flags);  return make_tuple<float,UMat,UMat>(retval,outputs,outputProbs);})
		 predictProb(inputs::UMat, outputs::UMat, outputProbs::UMat, flags::int) -> ( retval::float, outputs::UMat, outputProbs::UMat ) 
		 create
		 .method("jlopencv_cv_ml_NormalBayesClassifier_create",  [](cv::Ptr<NormalBayesClassifier> &cobj) { auto retval = cv::ml::NormalBayesClassifier::create(); return retval;})
		 create() -> ( retval::Ptr<NormalBayesClassifier> ) 
		 load
		 .method("jlopencv_cv_ml_NormalBayesClassifier_load",  [](cv::Ptr<NormalBayesClassifier> &cobj, String &filepath, String &nodeName) { auto retval = cv::ml::NormalBayesClassifier::load(filepath, nodeName); return retval;})
		 load(filepath::String, nodeName::String) -> ( retval::Ptr<NormalBayesClassifier> ) 
	 WIP
	 function Base.getproperty(m::ml_NormalBayesClassifier, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ml_NormalBayesClassifier, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 ml_KNearest True
		 getDefaultK
		 .method("jlopencv_cv_ml_KNearest_getDefaultK",  [](cv::Ptr<KNearest> &cobj) { auto retval = cobj->getDefaultK();  return retval;})
		 getDefaultK() -> ( retval::int ) 
		 setDefaultK
		 .method("jlopencv_cv_ml_KNearest_setDefaultK",  [](cv::Ptr<KNearest> &cobj, int &val) { cobj->setDefaultK(val);  ;})
		 setDefaultK(val::int) -> nothing
		 getIsClassifier
		 .method("jlopencv_cv_ml_KNearest_getIsClassifier",  [](cv::Ptr<KNearest> &cobj) { auto retval = cobj->getIsClassifier();  return retval;})
		 getIsClassifier() -> ( retval::bool ) 
		 setIsClassifier
		 .method("jlopencv_cv_ml_KNearest_setIsClassifier",  [](cv::Ptr<KNearest> &cobj, bool &val) { cobj->setIsClassifier(val);  ;})
		 setIsClassifier(val::bool) -> nothing
		 getEmax
		 .method("jlopencv_cv_ml_KNearest_getEmax",  [](cv::Ptr<KNearest> &cobj) { auto retval = cobj->getEmax();  return retval;})
		 getEmax() -> ( retval::int ) 
		 setEmax
		 .method("jlopencv_cv_ml_KNearest_setEmax",  [](cv::Ptr<KNearest> &cobj, int &val) { cobj->setEmax(val);  ;})
		 setEmax(val::int) -> nothing
		 getAlgorithmType
		 .method("jlopencv_cv_ml_KNearest_getAlgorithmType",  [](cv::Ptr<KNearest> &cobj) { auto retval = cobj->getAlgorithmType();  return retval;})
		 getAlgorithmType() -> ( retval::int ) 
		 setAlgorithmType
		 .method("jlopencv_cv_ml_KNearest_setAlgorithmType",  [](cv::Ptr<KNearest> &cobj, int &val) { cobj->setAlgorithmType(val);  ;})
		 setAlgorithmType(val::int) -> nothing
		 findNearest
		 .method("jlopencv_cv_ml_KNearest_findNearest",  [](cv::Ptr<KNearest> &cobj, Mat &samples, int &k, Mat &results, Mat &neighborResponses, Mat &dist) { auto retval = cobj->findNearest(samples, k, results, neighborResponses, dist);  return make_tuple<float,Mat,Mat,Mat>(retval,results,neighborResponses,dist);})
		 findNearest(samples::Mat, k::int; results::Mat, neighborResponses::Mat, dist::Mat) -> ( retval::float, results::Mat, neighborResponses::Mat, dist::Mat ) 
		 findNearest
		 .method("jlopencv_cv_ml_KNearest_findNearest",  [](cv::Ptr<KNearest> &cobj, UMat &samples, int &k, UMat &results, UMat &neighborResponses, UMat &dist) { auto retval = cobj->findNearest(samples, k, results, neighborResponses, dist);  return make_tuple<float,UMat,UMat,UMat>(retval,results,neighborResponses,dist);})
		 findNearest(samples::UMat, k::int; results::UMat, neighborResponses::UMat, dist::UMat) -> ( retval::float, results::UMat, neighborResponses::UMat, dist::UMat ) 
		 create
		 .method("jlopencv_cv_ml_KNearest_create",  [](cv::Ptr<KNearest> &cobj) { auto retval = cv::ml::KNearest::create(); return retval;})
		 create() -> ( retval::Ptr<KNearest> ) 
		 load
		 .method("jlopencv_cv_ml_KNearest_load",  [](cv::Ptr<KNearest> &cobj, String &filepath) { auto retval = cv::ml::KNearest::load(filepath); return retval;})
		 load(filepath::String) -> ( retval::Ptr<KNearest> ) 
	 WIP
	 function Base.getproperty(m::ml_KNearest, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ml_KNearest, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 ml_SVM True
		 getType
		 .method("jlopencv_cv_ml_SVM_getType",  [](cv::Ptr<SVM> &cobj) { auto retval = cobj->getType();  return retval;})
		 getType() -> ( retval::int ) 
		 setType
		 .method("jlopencv_cv_ml_SVM_setType",  [](cv::Ptr<SVM> &cobj, int &val) { cobj->setType(val);  ;})
		 setType(val::int) -> nothing
		 getGamma
		 .method("jlopencv_cv_ml_SVM_getGamma",  [](cv::Ptr<SVM> &cobj) { auto retval = cobj->getGamma();  return retval;})
		 getGamma() -> ( retval::double ) 
		 setGamma
		 .method("jlopencv_cv_ml_SVM_setGamma",  [](cv::Ptr<SVM> &cobj, double &val) { cobj->setGamma(val);  ;})
		 setGamma(val::double) -> nothing
		 getCoef0
		 .method("jlopencv_cv_ml_SVM_getCoef0",  [](cv::Ptr<SVM> &cobj) { auto retval = cobj->getCoef0();  return retval;})
		 getCoef0() -> ( retval::double ) 
		 setCoef0
		 .method("jlopencv_cv_ml_SVM_setCoef0",  [](cv::Ptr<SVM> &cobj, double &val) { cobj->setCoef0(val);  ;})
		 setCoef0(val::double) -> nothing
		 getDegree
		 .method("jlopencv_cv_ml_SVM_getDegree",  [](cv::Ptr<SVM> &cobj) { auto retval = cobj->getDegree();  return retval;})
		 getDegree() -> ( retval::double ) 
		 setDegree
		 .method("jlopencv_cv_ml_SVM_setDegree",  [](cv::Ptr<SVM> &cobj, double &val) { cobj->setDegree(val);  ;})
		 setDegree(val::double) -> nothing
		 getC
		 .method("jlopencv_cv_ml_SVM_getC",  [](cv::Ptr<SVM> &cobj) { auto retval = cobj->getC();  return retval;})
		 getC() -> ( retval::double ) 
		 setC
		 .method("jlopencv_cv_ml_SVM_setC",  [](cv::Ptr<SVM> &cobj, double &val) { cobj->setC(val);  ;})
		 setC(val::double) -> nothing
		 getNu
		 .method("jlopencv_cv_ml_SVM_getNu",  [](cv::Ptr<SVM> &cobj) { auto retval = cobj->getNu();  return retval;})
		 getNu() -> ( retval::double ) 
		 setNu
		 .method("jlopencv_cv_ml_SVM_setNu",  [](cv::Ptr<SVM> &cobj, double &val) { cobj->setNu(val);  ;})
		 setNu(val::double) -> nothing
		 getP
		 .method("jlopencv_cv_ml_SVM_getP",  [](cv::Ptr<SVM> &cobj) { auto retval = cobj->getP();  return retval;})
		 getP() -> ( retval::double ) 
		 setP
		 .method("jlopencv_cv_ml_SVM_setP",  [](cv::Ptr<SVM> &cobj, double &val) { cobj->setP(val);  ;})
		 setP(val::double) -> nothing
		 getClassWeights
		 .method("jlopencv_cv_ml_SVM_getClassWeights",  [](cv::Ptr<SVM> &cobj) { auto retval = cobj->getClassWeights();  return retval;})
		 getClassWeights() -> ( retval::cv::Mat ) 
		 setClassWeights
		 .method("jlopencv_cv_ml_SVM_setClassWeights",  [](cv::Ptr<SVM> &cobj, Mat &val) { cobj->setClassWeights(val);  ;})
		 setClassWeights(val::Mat) -> nothing
		 setClassWeights
		 .method("jlopencv_cv_ml_SVM_setClassWeights",  [](cv::Ptr<SVM> &cobj, Mat &val) { cobj->setClassWeights(val);  ;})
		 setClassWeights(val::Mat) -> nothing
		 getTermCriteria
		 .method("jlopencv_cv_ml_SVM_getTermCriteria",  [](cv::Ptr<SVM> &cobj) { auto retval = cobj->getTermCriteria();  return retval;})
		 getTermCriteria() -> ( retval::cv::TermCriteria ) 
		 setTermCriteria
		 .method("jlopencv_cv_ml_SVM_setTermCriteria",  [](cv::Ptr<SVM> &cobj, TermCriteria &val) { cobj->setTermCriteria(val);  ;})
		 setTermCriteria(val::TermCriteria) -> nothing
		 getKernelType
		 .method("jlopencv_cv_ml_SVM_getKernelType",  [](cv::Ptr<SVM> &cobj) { auto retval = cobj->getKernelType();  return retval;})
		 getKernelType() -> ( retval::int ) 
		 setKernel
		 .method("jlopencv_cv_ml_SVM_setKernel",  [](cv::Ptr<SVM> &cobj, int &kernelType) { cobj->setKernel(kernelType);  ;})
		 setKernel(kernelType::int) -> nothing
		 trainAuto
		 .method("jlopencv_cv_ml_SVM_trainAuto",  [](cv::Ptr<SVM> &cobj, Mat &samples, int &layout, Mat &responses, int &kFold, Ptr<ParamGrid> &Cgrid, Ptr<ParamGrid> &gammaGrid, Ptr<ParamGrid> &pGrid, Ptr<ParamGrid> &nuGrid, Ptr<ParamGrid> &coeffGrid, Ptr<ParamGrid> &degreeGrid, bool &balanced) { auto retval = cobj->trainAuto(samples, layout, responses, kFold, Cgrid, gammaGrid, pGrid, nuGrid, coeffGrid, degreeGrid, balanced);  return retval;})
		 trainAuto(samples::Mat, layout::int, responses::Mat, kFold::int, Cgrid::Ptr<ParamGrid>, gammaGrid::Ptr<ParamGrid>, pGrid::Ptr<ParamGrid>, nuGrid::Ptr<ParamGrid>, coeffGrid::Ptr<ParamGrid>, degreeGrid::Ptr<ParamGrid>, balanced::bool) -> ( retval::bool ) 
		 trainAuto
		 .method("jlopencv_cv_ml_SVM_trainAuto",  [](cv::Ptr<SVM> &cobj, UMat &samples, int &layout, UMat &responses, int &kFold, Ptr<ParamGrid> &Cgrid, Ptr<ParamGrid> &gammaGrid, Ptr<ParamGrid> &pGrid, Ptr<ParamGrid> &nuGrid, Ptr<ParamGrid> &coeffGrid, Ptr<ParamGrid> &degreeGrid, bool &balanced) { auto retval = cobj->trainAuto(samples, layout, responses, kFold, Cgrid, gammaGrid, pGrid, nuGrid, coeffGrid, degreeGrid, balanced);  return retval;})
		 trainAuto(samples::UMat, layout::int, responses::UMat, kFold::int, Cgrid::Ptr<ParamGrid>, gammaGrid::Ptr<ParamGrid>, pGrid::Ptr<ParamGrid>, nuGrid::Ptr<ParamGrid>, coeffGrid::Ptr<ParamGrid>, degreeGrid::Ptr<ParamGrid>, balanced::bool) -> ( retval::bool ) 
		 getSupportVectors
		 .method("jlopencv_cv_ml_SVM_getSupportVectors",  [](cv::Ptr<SVM> &cobj) { auto retval = cobj->getSupportVectors();  return retval;})
		 getSupportVectors() -> ( retval::Mat ) 
		 getUncompressedSupportVectors
		 .method("jlopencv_cv_ml_SVM_getUncompressedSupportVectors",  [](cv::Ptr<SVM> &cobj) { auto retval = cobj->getUncompressedSupportVectors();  return retval;})
		 getUncompressedSupportVectors() -> ( retval::Mat ) 
		 getDecisionFunction
		 .method("jlopencv_cv_ml_SVM_getDecisionFunction",  [](cv::Ptr<SVM> &cobj, int &i, Mat &alpha, Mat &svidx) { auto retval = cobj->getDecisionFunction(i, alpha, svidx);  return make_tuple<double,Mat,Mat>(retval,alpha,svidx);})
		 getDecisionFunction(i::int; alpha::Mat, svidx::Mat) -> ( retval::double, alpha::Mat, svidx::Mat ) 
		 getDecisionFunction
		 .method("jlopencv_cv_ml_SVM_getDecisionFunction",  [](cv::Ptr<SVM> &cobj, int &i, UMat &alpha, UMat &svidx) { auto retval = cobj->getDecisionFunction(i, alpha, svidx);  return make_tuple<double,UMat,UMat>(retval,alpha,svidx);})
		 getDecisionFunction(i::int; alpha::UMat, svidx::UMat) -> ( retval::double, alpha::UMat, svidx::UMat ) 
		 getDefaultGridPtr
		 .method("jlopencv_cv_ml_SVM_getDefaultGridPtr",  [](cv::Ptr<SVM> &cobj, int &param_id) { auto retval = cv::ml::SVM::getDefaultGridPtr(param_id); return retval;})
		 getDefaultGridPtr(param_id::int) -> ( retval::Ptr<ParamGrid> ) 
		 create
		 .method("jlopencv_cv_ml_SVM_create",  [](cv::Ptr<SVM> &cobj) { auto retval = cv::ml::SVM::create(); return retval;})
		 create() -> ( retval::Ptr<SVM> ) 
		 load
		 .method("jlopencv_cv_ml_SVM_load",  [](cv::Ptr<SVM> &cobj, String &filepath) { auto retval = cv::ml::SVM::load(filepath); return retval;})
		 load(filepath::String) -> ( retval::Ptr<SVM> ) 
	 WIP
	 function Base.getproperty(m::ml_SVM, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ml_SVM, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 ml_EM True
		 getClustersNumber
		 .method("jlopencv_cv_ml_EM_getClustersNumber",  [](cv::Ptr<EM> &cobj) { auto retval = cobj->getClustersNumber();  return retval;})
		 getClustersNumber() -> ( retval::int ) 
		 setClustersNumber
		 .method("jlopencv_cv_ml_EM_setClustersNumber",  [](cv::Ptr<EM> &cobj, int &val) { cobj->setClustersNumber(val);  ;})
		 setClustersNumber(val::int) -> nothing
		 getCovarianceMatrixType
		 .method("jlopencv_cv_ml_EM_getCovarianceMatrixType",  [](cv::Ptr<EM> &cobj) { auto retval = cobj->getCovarianceMatrixType();  return retval;})
		 getCovarianceMatrixType() -> ( retval::int ) 
		 setCovarianceMatrixType
		 .method("jlopencv_cv_ml_EM_setCovarianceMatrixType",  [](cv::Ptr<EM> &cobj, int &val) { cobj->setCovarianceMatrixType(val);  ;})
		 setCovarianceMatrixType(val::int) -> nothing
		 getTermCriteria
		 .method("jlopencv_cv_ml_EM_getTermCriteria",  [](cv::Ptr<EM> &cobj) { auto retval = cobj->getTermCriteria();  return retval;})
		 getTermCriteria() -> ( retval::TermCriteria ) 
		 setTermCriteria
		 .method("jlopencv_cv_ml_EM_setTermCriteria",  [](cv::Ptr<EM> &cobj, TermCriteria &val) { cobj->setTermCriteria(val);  ;})
		 setTermCriteria(val::TermCriteria) -> nothing
		 getWeights
		 .method("jlopencv_cv_ml_EM_getWeights",  [](cv::Ptr<EM> &cobj) { auto retval = cobj->getWeights();  return retval;})
		 getWeights() -> ( retval::Mat ) 
		 getMeans
		 .method("jlopencv_cv_ml_EM_getMeans",  [](cv::Ptr<EM> &cobj) { auto retval = cobj->getMeans();  return retval;})
		 getMeans() -> ( retval::Mat ) 
		 getCovs
		 .method("jlopencv_cv_ml_EM_getCovs",  [](cv::Ptr<EM> &cobj) {vector<Mat> covs; cobj->getCovs(covs);  return covs;})
		 getCovs() -> ( covs::vector<Mat> ) 
		 getCovs
		 .method("jlopencv_cv_ml_EM_getCovs",  [](cv::Ptr<EM> &cobj) {vector<Mat> covs; cobj->getCovs(covs);  return covs;})
		 getCovs() -> ( covs::vector<Mat> ) 
		 predict
		 .method("jlopencv_cv_ml_EM_predict",  [](cv::Ptr<EM> &cobj, Mat &samples, Mat &results, int &flags) { auto retval = cobj->predict(samples, results, flags);  return make_tuple<float,Mat>(retval,results);})
		 predict(samples::Mat, results::Mat, flags::int) -> ( retval::float, results::Mat ) 
		 predict
		 .method("jlopencv_cv_ml_EM_predict",  [](cv::Ptr<EM> &cobj, UMat &samples, UMat &results, int &flags) { auto retval = cobj->predict(samples, results, flags);  return make_tuple<float,UMat>(retval,results);})
		 predict(samples::UMat, results::UMat, flags::int) -> ( retval::float, results::UMat ) 
		 predict2
		 .method("jlopencv_cv_ml_EM_predict2",  [](cv::Ptr<EM> &cobj, Mat &sample, Mat &probs) { auto retval = cobj->predict2(sample, probs);  return make_tuple<Vec2d,Mat>(retval,probs);})
		 predict2(sample::Mat; probs::Mat) -> ( retval::Vec2d, probs::Mat ) 
		 predict2
		 .method("jlopencv_cv_ml_EM_predict2",  [](cv::Ptr<EM> &cobj, UMat &sample, UMat &probs) { auto retval = cobj->predict2(sample, probs);  return make_tuple<Vec2d,UMat>(retval,probs);})
		 predict2(sample::UMat; probs::UMat) -> ( retval::Vec2d, probs::UMat ) 
		 trainEM
		 .method("jlopencv_cv_ml_EM_trainEM",  [](cv::Ptr<EM> &cobj, Mat &samples, Mat &logLikelihoods, Mat &labels, Mat &probs) { auto retval = cobj->trainEM(samples, logLikelihoods, labels, probs);  return make_tuple<bool,Mat,Mat,Mat>(retval,logLikelihoods,labels,probs);})
		 trainEM(samples::Mat; logLikelihoods::Mat, labels::Mat, probs::Mat) -> ( retval::bool, logLikelihoods::Mat, labels::Mat, probs::Mat ) 
		 trainEM
		 .method("jlopencv_cv_ml_EM_trainEM",  [](cv::Ptr<EM> &cobj, UMat &samples, UMat &logLikelihoods, UMat &labels, UMat &probs) { auto retval = cobj->trainEM(samples, logLikelihoods, labels, probs);  return make_tuple<bool,UMat,UMat,UMat>(retval,logLikelihoods,labels,probs);})
		 trainEM(samples::UMat; logLikelihoods::UMat, labels::UMat, probs::UMat) -> ( retval::bool, logLikelihoods::UMat, labels::UMat, probs::UMat ) 
		 trainE
		 .method("jlopencv_cv_ml_EM_trainE",  [](cv::Ptr<EM> &cobj, Mat &samples, Mat &means0, Mat &covs0, Mat &weights0, Mat &logLikelihoods, Mat &labels, Mat &probs) { auto retval = cobj->trainE(samples, means0, covs0, weights0, logLikelihoods, labels, probs);  return make_tuple<bool,Mat,Mat,Mat>(retval,logLikelihoods,labels,probs);})
		 trainE(samples::Mat, means0::Mat, covs0::Mat, weights0::Mat; logLikelihoods::Mat, labels::Mat, probs::Mat) -> ( retval::bool, logLikelihoods::Mat, labels::Mat, probs::Mat ) 
		 trainE
		 .method("jlopencv_cv_ml_EM_trainE",  [](cv::Ptr<EM> &cobj, UMat &samples, UMat &means0, UMat &covs0, UMat &weights0, UMat &logLikelihoods, UMat &labels, UMat &probs) { auto retval = cobj->trainE(samples, means0, covs0, weights0, logLikelihoods, labels, probs);  return make_tuple<bool,UMat,UMat,UMat>(retval,logLikelihoods,labels,probs);})
		 trainE(samples::UMat, means0::UMat, covs0::UMat, weights0::UMat; logLikelihoods::UMat, labels::UMat, probs::UMat) -> ( retval::bool, logLikelihoods::UMat, labels::UMat, probs::UMat ) 
		 trainM
		 .method("jlopencv_cv_ml_EM_trainM",  [](cv::Ptr<EM> &cobj, Mat &samples, Mat &probs0, Mat &logLikelihoods, Mat &labels, Mat &probs) { auto retval = cobj->trainM(samples, probs0, logLikelihoods, labels, probs);  return make_tuple<bool,Mat,Mat,Mat>(retval,logLikelihoods,labels,probs);})
		 trainM(samples::Mat, probs0::Mat; logLikelihoods::Mat, labels::Mat, probs::Mat) -> ( retval::bool, logLikelihoods::Mat, labels::Mat, probs::Mat ) 
		 trainM
		 .method("jlopencv_cv_ml_EM_trainM",  [](cv::Ptr<EM> &cobj, UMat &samples, UMat &probs0, UMat &logLikelihoods, UMat &labels, UMat &probs) { auto retval = cobj->trainM(samples, probs0, logLikelihoods, labels, probs);  return make_tuple<bool,UMat,UMat,UMat>(retval,logLikelihoods,labels,probs);})
		 trainM(samples::UMat, probs0::UMat; logLikelihoods::UMat, labels::UMat, probs::UMat) -> ( retval::bool, logLikelihoods::UMat, labels::UMat, probs::UMat ) 
		 create
		 .method("jlopencv_cv_ml_EM_create",  [](cv::Ptr<EM> &cobj) { auto retval = cv::ml::EM::create(); return retval;})
		 create() -> ( retval::Ptr<EM> ) 
		 load
		 .method("jlopencv_cv_ml_EM_load",  [](cv::Ptr<EM> &cobj, String &filepath, String &nodeName) { auto retval = cv::ml::EM::load(filepath, nodeName); return retval;})
		 load(filepath::String, nodeName::String) -> ( retval::Ptr<EM> ) 
	 WIP
	 function Base.getproperty(m::ml_EM, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ml_EM, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 ml_DTrees True
		 getMaxCategories
		 .method("jlopencv_cv_ml_DTrees_getMaxCategories",  [](cv::Ptr<DTrees> &cobj) { auto retval = cobj->getMaxCategories();  return retval;})
		 getMaxCategories() -> ( retval::int ) 
		 setMaxCategories
		 .method("jlopencv_cv_ml_DTrees_setMaxCategories",  [](cv::Ptr<DTrees> &cobj, int &val) { cobj->setMaxCategories(val);  ;})
		 setMaxCategories(val::int) -> nothing
		 getMaxDepth
		 .method("jlopencv_cv_ml_DTrees_getMaxDepth",  [](cv::Ptr<DTrees> &cobj) { auto retval = cobj->getMaxDepth();  return retval;})
		 getMaxDepth() -> ( retval::int ) 
		 setMaxDepth
		 .method("jlopencv_cv_ml_DTrees_setMaxDepth",  [](cv::Ptr<DTrees> &cobj, int &val) { cobj->setMaxDepth(val);  ;})
		 setMaxDepth(val::int) -> nothing
		 getMinSampleCount
		 .method("jlopencv_cv_ml_DTrees_getMinSampleCount",  [](cv::Ptr<DTrees> &cobj) { auto retval = cobj->getMinSampleCount();  return retval;})
		 getMinSampleCount() -> ( retval::int ) 
		 setMinSampleCount
		 .method("jlopencv_cv_ml_DTrees_setMinSampleCount",  [](cv::Ptr<DTrees> &cobj, int &val) { cobj->setMinSampleCount(val);  ;})
		 setMinSampleCount(val::int) -> nothing
		 getCVFolds
		 .method("jlopencv_cv_ml_DTrees_getCVFolds",  [](cv::Ptr<DTrees> &cobj) { auto retval = cobj->getCVFolds();  return retval;})
		 getCVFolds() -> ( retval::int ) 
		 setCVFolds
		 .method("jlopencv_cv_ml_DTrees_setCVFolds",  [](cv::Ptr<DTrees> &cobj, int &val) { cobj->setCVFolds(val);  ;})
		 setCVFolds(val::int) -> nothing
		 getUseSurrogates
		 .method("jlopencv_cv_ml_DTrees_getUseSurrogates",  [](cv::Ptr<DTrees> &cobj) { auto retval = cobj->getUseSurrogates();  return retval;})
		 getUseSurrogates() -> ( retval::bool ) 
		 setUseSurrogates
		 .method("jlopencv_cv_ml_DTrees_setUseSurrogates",  [](cv::Ptr<DTrees> &cobj, bool &val) { cobj->setUseSurrogates(val);  ;})
		 setUseSurrogates(val::bool) -> nothing
		 getUse1SERule
		 .method("jlopencv_cv_ml_DTrees_getUse1SERule",  [](cv::Ptr<DTrees> &cobj) { auto retval = cobj->getUse1SERule();  return retval;})
		 getUse1SERule() -> ( retval::bool ) 
		 setUse1SERule
		 .method("jlopencv_cv_ml_DTrees_setUse1SERule",  [](cv::Ptr<DTrees> &cobj, bool &val) { cobj->setUse1SERule(val);  ;})
		 setUse1SERule(val::bool) -> nothing
		 getTruncatePrunedTree
		 .method("jlopencv_cv_ml_DTrees_getTruncatePrunedTree",  [](cv::Ptr<DTrees> &cobj) { auto retval = cobj->getTruncatePrunedTree();  return retval;})
		 getTruncatePrunedTree() -> ( retval::bool ) 
		 setTruncatePrunedTree
		 .method("jlopencv_cv_ml_DTrees_setTruncatePrunedTree",  [](cv::Ptr<DTrees> &cobj, bool &val) { cobj->setTruncatePrunedTree(val);  ;})
		 setTruncatePrunedTree(val::bool) -> nothing
		 getRegressionAccuracy
		 .method("jlopencv_cv_ml_DTrees_getRegressionAccuracy",  [](cv::Ptr<DTrees> &cobj) { auto retval = cobj->getRegressionAccuracy();  return retval;})
		 getRegressionAccuracy() -> ( retval::float ) 
		 setRegressionAccuracy
		 .method("jlopencv_cv_ml_DTrees_setRegressionAccuracy",  [](cv::Ptr<DTrees> &cobj, float &val) { cobj->setRegressionAccuracy(val);  ;})
		 setRegressionAccuracy(val::float) -> nothing
		 getPriors
		 .method("jlopencv_cv_ml_DTrees_getPriors",  [](cv::Ptr<DTrees> &cobj) { auto retval = cobj->getPriors();  return retval;})
		 getPriors() -> ( retval::cv::Mat ) 
		 setPriors
		 .method("jlopencv_cv_ml_DTrees_setPriors",  [](cv::Ptr<DTrees> &cobj, Mat &val) { cobj->setPriors(val);  ;})
		 setPriors(val::Mat) -> nothing
		 setPriors
		 .method("jlopencv_cv_ml_DTrees_setPriors",  [](cv::Ptr<DTrees> &cobj, Mat &val) { cobj->setPriors(val);  ;})
		 setPriors(val::Mat) -> nothing
		 create
		 .method("jlopencv_cv_ml_DTrees_create",  [](cv::Ptr<DTrees> &cobj) { auto retval = cv::ml::DTrees::create(); return retval;})
		 create() -> ( retval::Ptr<DTrees> ) 
		 load
		 .method("jlopencv_cv_ml_DTrees_load",  [](cv::Ptr<DTrees> &cobj, String &filepath, String &nodeName) { auto retval = cv::ml::DTrees::load(filepath, nodeName); return retval;})
		 load(filepath::String, nodeName::String) -> ( retval::Ptr<DTrees> ) 
	 WIP
	 function Base.getproperty(m::ml_DTrees, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ml_DTrees, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 ml_RTrees True
		 getCalculateVarImportance
		 .method("jlopencv_cv_ml_RTrees_getCalculateVarImportance",  [](cv::Ptr<RTrees> &cobj) { auto retval = cobj->getCalculateVarImportance();  return retval;})
		 getCalculateVarImportance() -> ( retval::bool ) 
		 setCalculateVarImportance
		 .method("jlopencv_cv_ml_RTrees_setCalculateVarImportance",  [](cv::Ptr<RTrees> &cobj, bool &val) { cobj->setCalculateVarImportance(val);  ;})
		 setCalculateVarImportance(val::bool) -> nothing
		 getActiveVarCount
		 .method("jlopencv_cv_ml_RTrees_getActiveVarCount",  [](cv::Ptr<RTrees> &cobj) { auto retval = cobj->getActiveVarCount();  return retval;})
		 getActiveVarCount() -> ( retval::int ) 
		 setActiveVarCount
		 .method("jlopencv_cv_ml_RTrees_setActiveVarCount",  [](cv::Ptr<RTrees> &cobj, int &val) { cobj->setActiveVarCount(val);  ;})
		 setActiveVarCount(val::int) -> nothing
		 getTermCriteria
		 .method("jlopencv_cv_ml_RTrees_getTermCriteria",  [](cv::Ptr<RTrees> &cobj) { auto retval = cobj->getTermCriteria();  return retval;})
		 getTermCriteria() -> ( retval::TermCriteria ) 
		 setTermCriteria
		 .method("jlopencv_cv_ml_RTrees_setTermCriteria",  [](cv::Ptr<RTrees> &cobj, TermCriteria &val) { cobj->setTermCriteria(val);  ;})
		 setTermCriteria(val::TermCriteria) -> nothing
		 getVarImportance
		 .method("jlopencv_cv_ml_RTrees_getVarImportance",  [](cv::Ptr<RTrees> &cobj) { auto retval = cobj->getVarImportance();  return retval;})
		 getVarImportance() -> ( retval::Mat ) 
		 getVotes
		 .method("jlopencv_cv_ml_RTrees_getVotes",  [](cv::Ptr<RTrees> &cobj, Mat &samples, int &flags, Mat &results) { cobj->getVotes(samples, results, flags);  return results;})
		 getVotes(samples::Mat, flags::int; results::Mat) -> ( results::Mat ) 
		 getVotes
		 .method("jlopencv_cv_ml_RTrees_getVotes",  [](cv::Ptr<RTrees> &cobj, UMat &samples, int &flags, UMat &results) { cobj->getVotes(samples, results, flags);  return results;})
		 getVotes(samples::UMat, flags::int; results::UMat) -> ( results::UMat ) 
		 create
		 .method("jlopencv_cv_ml_RTrees_create",  [](cv::Ptr<RTrees> &cobj) { auto retval = cv::ml::RTrees::create(); return retval;})
		 create() -> ( retval::Ptr<RTrees> ) 
		 load
		 .method("jlopencv_cv_ml_RTrees_load",  [](cv::Ptr<RTrees> &cobj, String &filepath, String &nodeName) { auto retval = cv::ml::RTrees::load(filepath, nodeName); return retval;})
		 load(filepath::String, nodeName::String) -> ( retval::Ptr<RTrees> ) 
	 WIP
	 function Base.getproperty(m::ml_RTrees, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ml_RTrees, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 ml_Boost True
		 getBoostType
		 .method("jlopencv_cv_ml_Boost_getBoostType",  [](cv::Ptr<Boost> &cobj) { auto retval = cobj->getBoostType();  return retval;})
		 getBoostType() -> ( retval::int ) 
		 setBoostType
		 .method("jlopencv_cv_ml_Boost_setBoostType",  [](cv::Ptr<Boost> &cobj, int &val) { cobj->setBoostType(val);  ;})
		 setBoostType(val::int) -> nothing
		 getWeakCount
		 .method("jlopencv_cv_ml_Boost_getWeakCount",  [](cv::Ptr<Boost> &cobj) { auto retval = cobj->getWeakCount();  return retval;})
		 getWeakCount() -> ( retval::int ) 
		 setWeakCount
		 .method("jlopencv_cv_ml_Boost_setWeakCount",  [](cv::Ptr<Boost> &cobj, int &val) { cobj->setWeakCount(val);  ;})
		 setWeakCount(val::int) -> nothing
		 getWeightTrimRate
		 .method("jlopencv_cv_ml_Boost_getWeightTrimRate",  [](cv::Ptr<Boost> &cobj) { auto retval = cobj->getWeightTrimRate();  return retval;})
		 getWeightTrimRate() -> ( retval::double ) 
		 setWeightTrimRate
		 .method("jlopencv_cv_ml_Boost_setWeightTrimRate",  [](cv::Ptr<Boost> &cobj, double &val) { cobj->setWeightTrimRate(val);  ;})
		 setWeightTrimRate(val::double) -> nothing
		 create
		 .method("jlopencv_cv_ml_Boost_create",  [](cv::Ptr<Boost> &cobj) { auto retval = cv::ml::Boost::create(); return retval;})
		 create() -> ( retval::Ptr<Boost> ) 
		 load
		 .method("jlopencv_cv_ml_Boost_load",  [](cv::Ptr<Boost> &cobj, String &filepath, String &nodeName) { auto retval = cv::ml::Boost::load(filepath, nodeName); return retval;})
		 load(filepath::String, nodeName::String) -> ( retval::Ptr<Boost> ) 
	 WIP
	 function Base.getproperty(m::ml_Boost, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ml_Boost, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 ml_ANN_MLP True
		 setTrainMethod
		 .method("jlopencv_cv_ml_ANN_MLP_setTrainMethod",  [](cv::Ptr<ANN_MLP> &cobj, int &method, double &param1, double &param2) { cobj->setTrainMethod(method, param1, param2);  ;})
		 setTrainMethod(method::int, param1::double, param2::double) -> nothing
		 getTrainMethod
		 .method("jlopencv_cv_ml_ANN_MLP_getTrainMethod",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cobj->getTrainMethod();  return retval;})
		 getTrainMethod() -> ( retval::int ) 
		 setActivationFunction
		 .method("jlopencv_cv_ml_ANN_MLP_setActivationFunction",  [](cv::Ptr<ANN_MLP> &cobj, int &type, double &param1, double &param2) { cobj->setActivationFunction(type, param1, param2);  ;})
		 setActivationFunction(type::int, param1::double, param2::double) -> nothing
		 setLayerSizes
		 .method("jlopencv_cv_ml_ANN_MLP_setLayerSizes",  [](cv::Ptr<ANN_MLP> &cobj, Mat &_layer_sizes) { cobj->setLayerSizes(_layer_sizes);  ;})
		 setLayerSizes(_layer_sizes::Mat) -> nothing
		 setLayerSizes
		 .method("jlopencv_cv_ml_ANN_MLP_setLayerSizes",  [](cv::Ptr<ANN_MLP> &cobj, UMat &_layer_sizes) { cobj->setLayerSizes(_layer_sizes);  ;})
		 setLayerSizes(_layer_sizes::UMat) -> nothing
		 getLayerSizes
		 .method("jlopencv_cv_ml_ANN_MLP_getLayerSizes",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cobj->getLayerSizes();  return retval;})
		 getLayerSizes() -> ( retval::cv::Mat ) 
		 getTermCriteria
		 .method("jlopencv_cv_ml_ANN_MLP_getTermCriteria",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cobj->getTermCriteria();  return retval;})
		 getTermCriteria() -> ( retval::TermCriteria ) 
		 setTermCriteria
		 .method("jlopencv_cv_ml_ANN_MLP_setTermCriteria",  [](cv::Ptr<ANN_MLP> &cobj, TermCriteria &val) { cobj->setTermCriteria(val);  ;})
		 setTermCriteria(val::TermCriteria) -> nothing
		 getBackpropWeightScale
		 .method("jlopencv_cv_ml_ANN_MLP_getBackpropWeightScale",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cobj->getBackpropWeightScale();  return retval;})
		 getBackpropWeightScale() -> ( retval::double ) 
		 setBackpropWeightScale
		 .method("jlopencv_cv_ml_ANN_MLP_setBackpropWeightScale",  [](cv::Ptr<ANN_MLP> &cobj, double &val) { cobj->setBackpropWeightScale(val);  ;})
		 setBackpropWeightScale(val::double) -> nothing
		 getBackpropMomentumScale
		 .method("jlopencv_cv_ml_ANN_MLP_getBackpropMomentumScale",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cobj->getBackpropMomentumScale();  return retval;})
		 getBackpropMomentumScale() -> ( retval::double ) 
		 setBackpropMomentumScale
		 .method("jlopencv_cv_ml_ANN_MLP_setBackpropMomentumScale",  [](cv::Ptr<ANN_MLP> &cobj, double &val) { cobj->setBackpropMomentumScale(val);  ;})
		 setBackpropMomentumScale(val::double) -> nothing
		 getRpropDW0
		 .method("jlopencv_cv_ml_ANN_MLP_getRpropDW0",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cobj->getRpropDW0();  return retval;})
		 getRpropDW0() -> ( retval::double ) 
		 setRpropDW0
		 .method("jlopencv_cv_ml_ANN_MLP_setRpropDW0",  [](cv::Ptr<ANN_MLP> &cobj, double &val) { cobj->setRpropDW0(val);  ;})
		 setRpropDW0(val::double) -> nothing
		 getRpropDWPlus
		 .method("jlopencv_cv_ml_ANN_MLP_getRpropDWPlus",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cobj->getRpropDWPlus();  return retval;})
		 getRpropDWPlus() -> ( retval::double ) 
		 setRpropDWPlus
		 .method("jlopencv_cv_ml_ANN_MLP_setRpropDWPlus",  [](cv::Ptr<ANN_MLP> &cobj, double &val) { cobj->setRpropDWPlus(val);  ;})
		 setRpropDWPlus(val::double) -> nothing
		 getRpropDWMinus
		 .method("jlopencv_cv_ml_ANN_MLP_getRpropDWMinus",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cobj->getRpropDWMinus();  return retval;})
		 getRpropDWMinus() -> ( retval::double ) 
		 setRpropDWMinus
		 .method("jlopencv_cv_ml_ANN_MLP_setRpropDWMinus",  [](cv::Ptr<ANN_MLP> &cobj, double &val) { cobj->setRpropDWMinus(val);  ;})
		 setRpropDWMinus(val::double) -> nothing
		 getRpropDWMin
		 .method("jlopencv_cv_ml_ANN_MLP_getRpropDWMin",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cobj->getRpropDWMin();  return retval;})
		 getRpropDWMin() -> ( retval::double ) 
		 setRpropDWMin
		 .method("jlopencv_cv_ml_ANN_MLP_setRpropDWMin",  [](cv::Ptr<ANN_MLP> &cobj, double &val) { cobj->setRpropDWMin(val);  ;})
		 setRpropDWMin(val::double) -> nothing
		 getRpropDWMax
		 .method("jlopencv_cv_ml_ANN_MLP_getRpropDWMax",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cobj->getRpropDWMax();  return retval;})
		 getRpropDWMax() -> ( retval::double ) 
		 setRpropDWMax
		 .method("jlopencv_cv_ml_ANN_MLP_setRpropDWMax",  [](cv::Ptr<ANN_MLP> &cobj, double &val) { cobj->setRpropDWMax(val);  ;})
		 setRpropDWMax(val::double) -> nothing
		 getAnnealInitialT
		 .method("jlopencv_cv_ml_ANN_MLP_getAnnealInitialT",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cobj->getAnnealInitialT();  return retval;})
		 getAnnealInitialT() -> ( retval::double ) 
		 setAnnealInitialT
		 .method("jlopencv_cv_ml_ANN_MLP_setAnnealInitialT",  [](cv::Ptr<ANN_MLP> &cobj, double &val) { cobj->setAnnealInitialT(val);  ;})
		 setAnnealInitialT(val::double) -> nothing
		 getAnnealFinalT
		 .method("jlopencv_cv_ml_ANN_MLP_getAnnealFinalT",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cobj->getAnnealFinalT();  return retval;})
		 getAnnealFinalT() -> ( retval::double ) 
		 setAnnealFinalT
		 .method("jlopencv_cv_ml_ANN_MLP_setAnnealFinalT",  [](cv::Ptr<ANN_MLP> &cobj, double &val) { cobj->setAnnealFinalT(val);  ;})
		 setAnnealFinalT(val::double) -> nothing
		 getAnnealCoolingRatio
		 .method("jlopencv_cv_ml_ANN_MLP_getAnnealCoolingRatio",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cobj->getAnnealCoolingRatio();  return retval;})
		 getAnnealCoolingRatio() -> ( retval::double ) 
		 setAnnealCoolingRatio
		 .method("jlopencv_cv_ml_ANN_MLP_setAnnealCoolingRatio",  [](cv::Ptr<ANN_MLP> &cobj, double &val) { cobj->setAnnealCoolingRatio(val);  ;})
		 setAnnealCoolingRatio(val::double) -> nothing
		 getAnnealItePerStep
		 .method("jlopencv_cv_ml_ANN_MLP_getAnnealItePerStep",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cobj->getAnnealItePerStep();  return retval;})
		 getAnnealItePerStep() -> ( retval::int ) 
		 setAnnealItePerStep
		 .method("jlopencv_cv_ml_ANN_MLP_setAnnealItePerStep",  [](cv::Ptr<ANN_MLP> &cobj, int &val) { cobj->setAnnealItePerStep(val);  ;})
		 setAnnealItePerStep(val::int) -> nothing
		 getWeights
		 .method("jlopencv_cv_ml_ANN_MLP_getWeights",  [](cv::Ptr<ANN_MLP> &cobj, int &layerIdx) { auto retval = cobj->getWeights(layerIdx);  return retval;})
		 getWeights(layerIdx::int) -> ( retval::Mat ) 
		 create
		 .method("jlopencv_cv_ml_ANN_MLP_create",  [](cv::Ptr<ANN_MLP> &cobj) { auto retval = cv::ml::ANN_MLP::create(); return retval;})
		 create() -> ( retval::Ptr<ANN_MLP> ) 
		 load
		 .method("jlopencv_cv_ml_ANN_MLP_load",  [](cv::Ptr<ANN_MLP> &cobj, String &filepath) { auto retval = cv::ml::ANN_MLP::load(filepath); return retval;})
		 load(filepath::String) -> ( retval::Ptr<ANN_MLP> ) 
	 WIP
	 function Base.getproperty(m::ml_ANN_MLP, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ml_ANN_MLP, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 ml_LogisticRegression True
		 getLearningRate
		 .method("jlopencv_cv_ml_LogisticRegression_getLearningRate",  [](cv::Ptr<LogisticRegression> &cobj) { auto retval = cobj->getLearningRate();  return retval;})
		 getLearningRate() -> ( retval::double ) 
		 setLearningRate
		 .method("jlopencv_cv_ml_LogisticRegression_setLearningRate",  [](cv::Ptr<LogisticRegression> &cobj, double &val) { cobj->setLearningRate(val);  ;})
		 setLearningRate(val::double) -> nothing
		 getIterations
		 .method("jlopencv_cv_ml_LogisticRegression_getIterations",  [](cv::Ptr<LogisticRegression> &cobj) { auto retval = cobj->getIterations();  return retval;})
		 getIterations() -> ( retval::int ) 
		 setIterations
		 .method("jlopencv_cv_ml_LogisticRegression_setIterations",  [](cv::Ptr<LogisticRegression> &cobj, int &val) { cobj->setIterations(val);  ;})
		 setIterations(val::int) -> nothing
		 getRegularization
		 .method("jlopencv_cv_ml_LogisticRegression_getRegularization",  [](cv::Ptr<LogisticRegression> &cobj) { auto retval = cobj->getRegularization();  return retval;})
		 getRegularization() -> ( retval::int ) 
		 setRegularization
		 .method("jlopencv_cv_ml_LogisticRegression_setRegularization",  [](cv::Ptr<LogisticRegression> &cobj, int &val) { cobj->setRegularization(val);  ;})
		 setRegularization(val::int) -> nothing
		 getTrainMethod
		 .method("jlopencv_cv_ml_LogisticRegression_getTrainMethod",  [](cv::Ptr<LogisticRegression> &cobj) { auto retval = cobj->getTrainMethod();  return retval;})
		 getTrainMethod() -> ( retval::int ) 
		 setTrainMethod
		 .method("jlopencv_cv_ml_LogisticRegression_setTrainMethod",  [](cv::Ptr<LogisticRegression> &cobj, int &val) { cobj->setTrainMethod(val);  ;})
		 setTrainMethod(val::int) -> nothing
		 getMiniBatchSize
		 .method("jlopencv_cv_ml_LogisticRegression_getMiniBatchSize",  [](cv::Ptr<LogisticRegression> &cobj) { auto retval = cobj->getMiniBatchSize();  return retval;})
		 getMiniBatchSize() -> ( retval::int ) 
		 setMiniBatchSize
		 .method("jlopencv_cv_ml_LogisticRegression_setMiniBatchSize",  [](cv::Ptr<LogisticRegression> &cobj, int &val) { cobj->setMiniBatchSize(val);  ;})
		 setMiniBatchSize(val::int) -> nothing
		 getTermCriteria
		 .method("jlopencv_cv_ml_LogisticRegression_getTermCriteria",  [](cv::Ptr<LogisticRegression> &cobj) { auto retval = cobj->getTermCriteria();  return retval;})
		 getTermCriteria() -> ( retval::TermCriteria ) 
		 setTermCriteria
		 .method("jlopencv_cv_ml_LogisticRegression_setTermCriteria",  [](cv::Ptr<LogisticRegression> &cobj, TermCriteria &val) { cobj->setTermCriteria(val);  ;})
		 setTermCriteria(val::TermCriteria) -> nothing
		 predict
		 .method("jlopencv_cv_ml_LogisticRegression_predict",  [](cv::Ptr<LogisticRegression> &cobj, Mat &samples, Mat &results, int &flags) { auto retval = cobj->predict(samples, results, flags);  return make_tuple<float,Mat>(retval,results);})
		 predict(samples::Mat, results::Mat, flags::int) -> ( retval::float, results::Mat ) 
		 predict
		 .method("jlopencv_cv_ml_LogisticRegression_predict",  [](cv::Ptr<LogisticRegression> &cobj, UMat &samples, UMat &results, int &flags) { auto retval = cobj->predict(samples, results, flags);  return make_tuple<float,UMat>(retval,results);})
		 predict(samples::UMat, results::UMat, flags::int) -> ( retval::float, results::UMat ) 
		 get_learnt_thetas
		 .method("jlopencv_cv_ml_LogisticRegression_get_learnt_thetas",  [](cv::Ptr<LogisticRegression> &cobj) { auto retval = cobj->get_learnt_thetas();  return retval;})
		 get_learnt_thetas() -> ( retval::Mat ) 
		 create
		 .method("jlopencv_cv_ml_LogisticRegression_create",  [](cv::Ptr<LogisticRegression> &cobj) { auto retval = cv::ml::LogisticRegression::create(); return retval;})
		 create() -> ( retval::Ptr<LogisticRegression> ) 
		 load
		 .method("jlopencv_cv_ml_LogisticRegression_load",  [](cv::Ptr<LogisticRegression> &cobj, String &filepath, String &nodeName) { auto retval = cv::ml::LogisticRegression::load(filepath, nodeName); return retval;})
		 load(filepath::String, nodeName::String) -> ( retval::Ptr<LogisticRegression> ) 
	 WIP
	 function Base.getproperty(m::ml_LogisticRegression, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ml_LogisticRegression, s::Symbol, v)
    return Base.setfield(m, s, v)
end

	 ml_SVMSGD True
		 getWeights
		 .method("jlopencv_cv_ml_SVMSGD_getWeights",  [](cv::Ptr<SVMSGD> &cobj) { auto retval = cobj->getWeights();  return retval;})
		 getWeights() -> ( retval::Mat ) 
		 getShift
		 .method("jlopencv_cv_ml_SVMSGD_getShift",  [](cv::Ptr<SVMSGD> &cobj) { auto retval = cobj->getShift();  return retval;})
		 getShift() -> ( retval::float ) 
		 create
		 .method("jlopencv_cv_ml_SVMSGD_create",  [](cv::Ptr<SVMSGD> &cobj) { auto retval = cv::ml::SVMSGD::create(); return retval;})
		 create() -> ( retval::Ptr<SVMSGD> ) 
		 load
		 .method("jlopencv_cv_ml_SVMSGD_load",  [](cv::Ptr<SVMSGD> &cobj, String &filepath, String &nodeName) { auto retval = cv::ml::SVMSGD::load(filepath, nodeName); return retval;})
		 load(filepath::String, nodeName::String) -> ( retval::Ptr<SVMSGD> ) 
		 setOptimalParameters
		 .method("jlopencv_cv_ml_SVMSGD_setOptimalParameters",  [](cv::Ptr<SVMSGD> &cobj, int &svmsgdType, int &marginType) { cobj->setOptimalParameters(svmsgdType, marginType);  ;})
		 setOptimalParameters(svmsgdType::int, marginType::int) -> nothing
		 getSvmsgdType
		 .method("jlopencv_cv_ml_SVMSGD_getSvmsgdType",  [](cv::Ptr<SVMSGD> &cobj) { auto retval = cobj->getSvmsgdType();  return retval;})
		 getSvmsgdType() -> ( retval::int ) 
		 setSvmsgdType
		 .method("jlopencv_cv_ml_SVMSGD_setSvmsgdType",  [](cv::Ptr<SVMSGD> &cobj, int &svmsgdType) { cobj->setSvmsgdType(svmsgdType);  ;})
		 setSvmsgdType(svmsgdType::int) -> nothing
		 getMarginType
		 .method("jlopencv_cv_ml_SVMSGD_getMarginType",  [](cv::Ptr<SVMSGD> &cobj) { auto retval = cobj->getMarginType();  return retval;})
		 getMarginType() -> ( retval::int ) 
		 setMarginType
		 .method("jlopencv_cv_ml_SVMSGD_setMarginType",  [](cv::Ptr<SVMSGD> &cobj, int &marginType) { cobj->setMarginType(marginType);  ;})
		 setMarginType(marginType::int) -> nothing
		 getMarginRegularization
		 .method("jlopencv_cv_ml_SVMSGD_getMarginRegularization",  [](cv::Ptr<SVMSGD> &cobj) { auto retval = cobj->getMarginRegularization();  return retval;})
		 getMarginRegularization() -> ( retval::float ) 
		 setMarginRegularization
		 .method("jlopencv_cv_ml_SVMSGD_setMarginRegularization",  [](cv::Ptr<SVMSGD> &cobj, float &marginRegularization) { cobj->setMarginRegularization(marginRegularization);  ;})
		 setMarginRegularization(marginRegularization::float) -> nothing
		 getInitialStepSize
		 .method("jlopencv_cv_ml_SVMSGD_getInitialStepSize",  [](cv::Ptr<SVMSGD> &cobj) { auto retval = cobj->getInitialStepSize();  return retval;})
		 getInitialStepSize() -> ( retval::float ) 
		 setInitialStepSize
		 .method("jlopencv_cv_ml_SVMSGD_setInitialStepSize",  [](cv::Ptr<SVMSGD> &cobj, float &InitialStepSize) { cobj->setInitialStepSize(InitialStepSize);  ;})
		 setInitialStepSize(InitialStepSize::float) -> nothing
		 getStepDecreasingPower
		 .method("jlopencv_cv_ml_SVMSGD_getStepDecreasingPower",  [](cv::Ptr<SVMSGD> &cobj) { auto retval = cobj->getStepDecreasingPower();  return retval;})
		 getStepDecreasingPower() -> ( retval::float ) 
		 setStepDecreasingPower
		 .method("jlopencv_cv_ml_SVMSGD_setStepDecreasingPower",  [](cv::Ptr<SVMSGD> &cobj, float &stepDecreasingPower) { cobj->setStepDecreasingPower(stepDecreasingPower);  ;})
		 setStepDecreasingPower(stepDecreasingPower::float) -> nothing
		 getTermCriteria
		 .method("jlopencv_cv_ml_SVMSGD_getTermCriteria",  [](cv::Ptr<SVMSGD> &cobj) { auto retval = cobj->getTermCriteria();  return retval;})
		 getTermCriteria() -> ( retval::TermCriteria ) 
		 setTermCriteria
		 .method("jlopencv_cv_ml_SVMSGD_setTermCriteria",  [](cv::Ptr<SVMSGD> &cobj, TermCriteria &val) { cobj->setTermCriteria(val);  ;})
		 setTermCriteria(val::TermCriteria) -> nothing
	 WIP
	 function Base.getproperty(m::ml_SVMSGD, s::Symbol)
    return Base.getfield(m, s)
end
function Base.setproperty!(m::ml_SVMSGD, s::Symbol, v)
    return Base.setfield(m, s, v)
end



	 ParamGrid_create
	 .method("jlopencv_cv_ml_ParamGrid_create",  [](double &minVal, double &maxVal, double &logstep) { auto retval = cv::ml::ParamGrid::create(minVal, maxVal, logstep); return retval;})
		 ParamGrid_create(minVal::double, maxVal::double, logstep::double) -> ( retval::Ptr<ParamGrid> ) 
	 TrainData_create
	 .method("jlopencv_cv_ml_TrainData_create",  [](Mat &samples, int &layout, Mat &responses, Mat &varIdx, Mat &sampleIdx, Mat &sampleWeights, Mat &varType) { auto retval = cv::ml::TrainData::create(samples, layout, responses, varIdx, sampleIdx, sampleWeights, varType); return retval;})
		 TrainData_create(samples::Mat, layout::int, responses::Mat, varIdx::Mat, sampleIdx::Mat, sampleWeights::Mat, varType::Mat) -> ( retval::Ptr<TrainData> ) 
	 TrainData_create
	 .method("jlopencv_cv_ml_TrainData_create",  [](UMat &samples, int &layout, UMat &responses, UMat &varIdx, UMat &sampleIdx, UMat &sampleWeights, UMat &varType) { auto retval = cv::ml::TrainData::create(samples, layout, responses, varIdx, sampleIdx, sampleWeights, varType); return retval;})
		 TrainData_create(samples::UMat, layout::int, responses::UMat, varIdx::UMat, sampleIdx::UMat, sampleWeights::UMat, varType::UMat) -> ( retval::Ptr<TrainData> ) 
	 NormalBayesClassifier_create
	 .method("jlopencv_cv_ml_NormalBayesClassifier_create",  []() { auto retval = cv::ml::NormalBayesClassifier::create(); return retval;})
		 NormalBayesClassifier_create() -> ( retval::Ptr<NormalBayesClassifier> ) 
	 KNearest_create
	 .method("jlopencv_cv_ml_KNearest_create",  []() { auto retval = cv::ml::KNearest::create(); return retval;})
		 KNearest_create() -> ( retval::Ptr<KNearest> ) 
	 SVM_create
	 .method("jlopencv_cv_ml_SVM_create",  []() { auto retval = cv::ml::SVM::create(); return retval;})
		 SVM_create() -> ( retval::Ptr<SVM> ) 
	 EM_create
	 .method("jlopencv_cv_ml_EM_create",  []() { auto retval = cv::ml::EM::create(); return retval;})
		 EM_create() -> ( retval::Ptr<EM> ) 
	 DTrees_create
	 .method("jlopencv_cv_ml_DTrees_create",  []() { auto retval = cv::ml::DTrees::create(); return retval;})
		 DTrees_create() -> ( retval::Ptr<DTrees> ) 
	 RTrees_create
	 .method("jlopencv_cv_ml_RTrees_create",  []() { auto retval = cv::ml::RTrees::create(); return retval;})
		 RTrees_create() -> ( retval::Ptr<RTrees> ) 
	 Boost_create
	 .method("jlopencv_cv_ml_Boost_create",  []() { auto retval = cv::ml::Boost::create(); return retval;})
		 Boost_create() -> ( retval::Ptr<Boost> ) 
	 ANN_MLP_create
	 .method("jlopencv_cv_ml_ANN_MLP_create",  []() { auto retval = cv::ml::ANN_MLP::create(); return retval;})
		 ANN_MLP_create() -> ( retval::Ptr<ANN_MLP> ) 
	 LogisticRegression_create
	 .method("jlopencv_cv_ml_LogisticRegression_create",  []() { auto retval = cv::ml::LogisticRegression::create(); return retval;})
		 LogisticRegression_create() -> ( retval::Ptr<LogisticRegression> ) 
	 SVMSGD_create
	 .method("jlopencv_cv_ml_SVMSGD_create",  []() { auto retval = cv::ml::SVMSGD::create(); return retval;})
		 SVMSGD_create() -> ( retval::Ptr<SVMSGD> ) 
	 TrainData_getSubVector
	 .method("jlopencv_cv_ml_TrainData_getSubVector",  [](Mat &vec, Mat &idx) { auto retval = cv::ml::TrainData::getSubVector(vec, idx); return retval;})
		 TrainData_getSubVector(vec::Mat, idx::Mat) -> ( retval::Mat ) 
	 TrainData_getSubVector
	 .method("jlopencv_cv_ml_TrainData_getSubVector",  [](Mat &vec, Mat &idx) { auto retval = cv::ml::TrainData::getSubVector(vec, idx); return retval;})
		 TrainData_getSubVector(vec::Mat, idx::Mat) -> ( retval::Mat ) 
	 TrainData_getSubMatrix
	 .method("jlopencv_cv_ml_TrainData_getSubMatrix",  [](Mat &matrix, Mat &idx, int &layout) { auto retval = cv::ml::TrainData::getSubMatrix(matrix, idx, layout); return retval;})
		 TrainData_getSubMatrix(matrix::Mat, idx::Mat, layout::int) -> ( retval::Mat ) 
	 TrainData_getSubMatrix
	 .method("jlopencv_cv_ml_TrainData_getSubMatrix",  [](Mat &matrix, Mat &idx, int &layout) { auto retval = cv::ml::TrainData::getSubMatrix(matrix, idx, layout); return retval;})
		 TrainData_getSubMatrix(matrix::Mat, idx::Mat, layout::int) -> ( retval::Mat ) 
	 NormalBayesClassifier_load
	 .method("jlopencv_cv_ml_NormalBayesClassifier_load",  [](String &filepath, String &nodeName) { auto retval = cv::ml::NormalBayesClassifier::load(filepath, nodeName); return retval;})
		 NormalBayesClassifier_load(filepath::String, nodeName::String) -> ( retval::Ptr<NormalBayesClassifier> ) 
	 KNearest_load
	 .method("jlopencv_cv_ml_KNearest_load",  [](String &filepath) { auto retval = cv::ml::KNearest::load(filepath); return retval;})
		 KNearest_load(filepath::String) -> ( retval::Ptr<KNearest> ) 
	 SVM_load
	 .method("jlopencv_cv_ml_SVM_load",  [](String &filepath) { auto retval = cv::ml::SVM::load(filepath); return retval;})
		 SVM_load(filepath::String) -> ( retval::Ptr<SVM> ) 
	 EM_load
	 .method("jlopencv_cv_ml_EM_load",  [](String &filepath, String &nodeName) { auto retval = cv::ml::EM::load(filepath, nodeName); return retval;})
		 EM_load(filepath::String, nodeName::String) -> ( retval::Ptr<EM> ) 
	 DTrees_load
	 .method("jlopencv_cv_ml_DTrees_load",  [](String &filepath, String &nodeName) { auto retval = cv::ml::DTrees::load(filepath, nodeName); return retval;})
		 DTrees_load(filepath::String, nodeName::String) -> ( retval::Ptr<DTrees> ) 
	 RTrees_load
	 .method("jlopencv_cv_ml_RTrees_load",  [](String &filepath, String &nodeName) { auto retval = cv::ml::RTrees::load(filepath, nodeName); return retval;})
		 RTrees_load(filepath::String, nodeName::String) -> ( retval::Ptr<RTrees> ) 
	 Boost_load
	 .method("jlopencv_cv_ml_Boost_load",  [](String &filepath, String &nodeName) { auto retval = cv::ml::Boost::load(filepath, nodeName); return retval;})
		 Boost_load(filepath::String, nodeName::String) -> ( retval::Ptr<Boost> ) 
	 ANN_MLP_load
	 .method("jlopencv_cv_ml_ANN_MLP_load",  [](String &filepath) { auto retval = cv::ml::ANN_MLP::load(filepath); return retval;})
		 ANN_MLP_load(filepath::String) -> ( retval::Ptr<ANN_MLP> ) 
	 LogisticRegression_load
	 .method("jlopencv_cv_ml_LogisticRegression_load",  [](String &filepath, String &nodeName) { auto retval = cv::ml::LogisticRegression::load(filepath, nodeName); return retval;})
		 LogisticRegression_load(filepath::String, nodeName::String) -> ( retval::Ptr<LogisticRegression> ) 
	 SVMSGD_load
	 .method("jlopencv_cv_ml_SVMSGD_load",  [](String &filepath, String &nodeName) { auto retval = cv::ml::SVMSGD::load(filepath, nodeName); return retval;})
		 SVMSGD_load(filepath::String, nodeName::String) -> ( retval::Ptr<SVMSGD> ) 
	 SVM_getDefaultGridPtr
	 .method("jlopencv_cv_ml_SVM_getDefaultGridPtr",  [](int &param_id) { auto retval = cv::ml::SVM::getDefaultGridPtr(param_id); return retval;})
		 SVM_getDefaultGridPtr(param_id::int) -> ( retval::Ptr<ParamGrid> ) 


	 VAR_NUMERICAL 	 cv::ml::VAR_NUMERICAL
	 VAR_ORDERED 	 cv::ml::VAR_ORDERED
	 VAR_CATEGORICAL 	 cv::ml::VAR_CATEGORICAL
	 TEST_ERROR 	 cv::ml::TEST_ERROR
	 TRAIN_ERROR 	 cv::ml::TRAIN_ERROR
	 ROW_SAMPLE 	 cv::ml::ROW_SAMPLE
	 COL_SAMPLE 	 cv::ml::COL_SAMPLE
	 StatModel_UPDATE_MODEL 	 cv::ml::StatModel::UPDATE_MODEL
	 StatModel_RAW_OUTPUT 	 cv::ml::StatModel::RAW_OUTPUT
	 StatModel_COMPRESSED_INPUT 	 cv::ml::StatModel::COMPRESSED_INPUT
	 StatModel_PREPROCESSED_INPUT 	 cv::ml::StatModel::PREPROCESSED_INPUT
	 KNearest_BRUTE_FORCE 	 cv::ml::KNearest::BRUTE_FORCE
	 KNearest_KDTREE 	 cv::ml::KNearest::KDTREE
	 SVM_C_SVC 	 cv::ml::SVM::C_SVC
	 SVM_NU_SVC 	 cv::ml::SVM::NU_SVC
	 SVM_ONE_CLASS 	 cv::ml::SVM::ONE_CLASS
	 SVM_EPS_SVR 	 cv::ml::SVM::EPS_SVR
	 SVM_NU_SVR 	 cv::ml::SVM::NU_SVR
	 SVM_CUSTOM 	 cv::ml::SVM::CUSTOM
	 SVM_LINEAR 	 cv::ml::SVM::LINEAR
	 SVM_POLY 	 cv::ml::SVM::POLY
	 SVM_RBF 	 cv::ml::SVM::RBF
	 SVM_SIGMOID 	 cv::ml::SVM::SIGMOID
	 SVM_CHI2 	 cv::ml::SVM::CHI2
	 SVM_INTER 	 cv::ml::SVM::INTER
	 SVM_C 	 cv::ml::SVM::C
	 SVM_GAMMA 	 cv::ml::SVM::GAMMA
	 SVM_P 	 cv::ml::SVM::P
	 SVM_NU 	 cv::ml::SVM::NU
	 SVM_COEF 	 cv::ml::SVM::COEF
	 SVM_DEGREE 	 cv::ml::SVM::DEGREE
	 EM_COV_MAT_SPHERICAL 	 cv::ml::EM::COV_MAT_SPHERICAL
	 EM_COV_MAT_DIAGONAL 	 cv::ml::EM::COV_MAT_DIAGONAL
	 EM_COV_MAT_GENERIC 	 cv::ml::EM::COV_MAT_GENERIC
	 EM_COV_MAT_DEFAULT 	 cv::ml::EM::COV_MAT_DEFAULT
	 EM_DEFAULT_NCLUSTERS 	 cv::ml::EM::DEFAULT_NCLUSTERS
	 EM_DEFAULT_MAX_ITERS 	 cv::ml::EM::DEFAULT_MAX_ITERS
	 EM_START_E_STEP 	 cv::ml::EM::START_E_STEP
	 EM_START_M_STEP 	 cv::ml::EM::START_M_STEP
	 EM_START_AUTO_STEP 	 cv::ml::EM::START_AUTO_STEP
	 DTrees_PREDICT_AUTO 	 cv::ml::DTrees::PREDICT_AUTO
	 DTrees_PREDICT_SUM 	 cv::ml::DTrees::PREDICT_SUM
	 DTrees_PREDICT_MAX_VOTE 	 cv::ml::DTrees::PREDICT_MAX_VOTE
	 DTrees_PREDICT_MASK 	 cv::ml::DTrees::PREDICT_MASK
	 Boost_DISCRETE 	 cv::ml::Boost::DISCRETE
	 Boost_REAL 	 cv::ml::Boost::REAL
	 Boost_LOGIT 	 cv::ml::Boost::LOGIT
	 Boost_GENTLE 	 cv::ml::Boost::GENTLE
	 ANN_MLP_BACKPROP 	 cv::ml::ANN_MLP::BACKPROP
	 ANN_MLP_RPROP 	 cv::ml::ANN_MLP::RPROP
	 ANN_MLP_ANNEAL 	 cv::ml::ANN_MLP::ANNEAL
	 ANN_MLP_IDENTITY 	 cv::ml::ANN_MLP::IDENTITY
	 ANN_MLP_SIGMOID_SYM 	 cv::ml::ANN_MLP::SIGMOID_SYM
	 ANN_MLP_GAUSSIAN 	 cv::ml::ANN_MLP::GAUSSIAN
	 ANN_MLP_RELU 	 cv::ml::ANN_MLP::RELU
	 ANN_MLP_LEAKYRELU 	 cv::ml::ANN_MLP::LEAKYRELU
	 ANN_MLP_UPDATE_WEIGHTS 	 cv::ml::ANN_MLP::UPDATE_WEIGHTS
	 ANN_MLP_NO_INPUT_SCALE 	 cv::ml::ANN_MLP::NO_INPUT_SCALE
	 ANN_MLP_NO_OUTPUT_SCALE 	 cv::ml::ANN_MLP::NO_OUTPUT_SCALE
	 LogisticRegression_REG_DISABLE 	 cv::ml::LogisticRegression::REG_DISABLE
	 LogisticRegression_REG_L1 	 cv::ml::LogisticRegression::REG_L1
	 LogisticRegression_REG_L2 	 cv::ml::LogisticRegression::REG_L2
	 LogisticRegression_BATCH 	 cv::ml::LogisticRegression::BATCH
	 LogisticRegression_MINI_BATCH 	 cv::ml::LogisticRegression::MINI_BATCH
	 SVMSGD_SGD 	 cv::ml::SVMSGD::SGD
	 SVMSGD_ASGD 	 cv::ml::SVMSGD::ASGD
	 SVMSGD_SOFT_MARGIN 	 cv::ml::SVMSGD::SOFT_MARGIN
	 SVMSGD_HARD_MARGIN 	 cv::ml::SVMSGD::HARD_MARGIN


	 VariableTypes
	 ErrorTypes
	 SampleTypes
	 Flags
	 Types
	 KernelTypes
	 ParamTypes
	 TrainingMethods
	 ActivationFunctions
	 TrainFlags
	 RegKinds
	 Methods
	 SvmsgdType
	 MarginType
cv.fisheye


	 projectPoints
	 .method("jlopencv_cv_fisheye_projectPoints",  [](Mat &objectPoints, Mat &rvec, Mat &tvec, Mat &K, Mat &D, Mat &imagePoints, double &alpha, Mat &jacobian) { cv::fisheye::projectPoints(objectPoints, imagePoints, rvec, tvec, K, D, alpha, jacobian); return make_tuple<Mat,Mat>(imagePoints,jacobian);})
		 projectPoints(objectPoints::Mat, rvec::Mat, tvec::Mat, K::Mat, D::Mat, imagePoints::Mat, alpha::double; jacobian::Mat) -> ( imagePoints::Mat, jacobian::Mat ) 
	 projectPoints
	 .method("jlopencv_cv_fisheye_projectPoints",  [](UMat &objectPoints, UMat &rvec, UMat &tvec, UMat &K, UMat &D, UMat &imagePoints, double &alpha, UMat &jacobian) { cv::fisheye::projectPoints(objectPoints, imagePoints, rvec, tvec, K, D, alpha, jacobian); return make_tuple<UMat,UMat>(imagePoints,jacobian);})
		 projectPoints(objectPoints::UMat, rvec::UMat, tvec::UMat, K::UMat, D::UMat, imagePoints::UMat, alpha::double; jacobian::UMat) -> ( imagePoints::UMat, jacobian::UMat ) 
	 distortPoints
	 .method("jlopencv_cv_fisheye_distortPoints",  [](Mat &undistorted, Mat &K, Mat &D, Mat &distorted, double &alpha) { cv::fisheye::distortPoints(undistorted, distorted, K, D, alpha); return distorted;})
		 distortPoints(undistorted::Mat, K::Mat, D::Mat, distorted::Mat, alpha::double) -> ( distorted::Mat ) 
	 distortPoints
	 .method("jlopencv_cv_fisheye_distortPoints",  [](UMat &undistorted, UMat &K, UMat &D, UMat &distorted, double &alpha) { cv::fisheye::distortPoints(undistorted, distorted, K, D, alpha); return distorted;})
		 distortPoints(undistorted::UMat, K::UMat, D::UMat, distorted::UMat, alpha::double) -> ( distorted::UMat ) 
	 undistortPoints
	 .method("jlopencv_cv_fisheye_undistortPoints",  [](Mat &distorted, Mat &K, Mat &D, Mat &undistorted, Mat &R, Mat &P) { cv::fisheye::undistortPoints(distorted, undistorted, K, D, R, P); return undistorted;})
		 undistortPoints(distorted::Mat, K::Mat, D::Mat, undistorted::Mat, R::Mat, P::Mat) -> ( undistorted::Mat ) 
	 undistortPoints
	 .method("jlopencv_cv_fisheye_undistortPoints",  [](UMat &distorted, UMat &K, UMat &D, UMat &undistorted, UMat &R, UMat &P) { cv::fisheye::undistortPoints(distorted, undistorted, K, D, R, P); return undistorted;})
		 undistortPoints(distorted::UMat, K::UMat, D::UMat, undistorted::UMat, R::UMat, P::UMat) -> ( undistorted::UMat ) 
	 initUndistortRectifyMap
	 .method("jlopencv_cv_fisheye_initUndistortRectifyMap",  [](Mat &K, Mat &D, Mat &R, Mat &P, Size &size, int &m1type, Mat &map1, Mat &map2) { cv::fisheye::initUndistortRectifyMap(K, D, R, P, size, m1type, map1, map2); return make_tuple<Mat,Mat>(map1,map2);})
		 initUndistortRectifyMap(K::Mat, D::Mat, R::Mat, P::Mat, size::Size, m1type::int; map1::Mat, map2::Mat) -> ( map1::Mat, map2::Mat ) 
	 initUndistortRectifyMap
	 .method("jlopencv_cv_fisheye_initUndistortRectifyMap",  [](UMat &K, UMat &D, UMat &R, UMat &P, Size &size, int &m1type, UMat &map1, UMat &map2) { cv::fisheye::initUndistortRectifyMap(K, D, R, P, size, m1type, map1, map2); return make_tuple<UMat,UMat>(map1,map2);})
		 initUndistortRectifyMap(K::UMat, D::UMat, R::UMat, P::UMat, size::Size, m1type::int; map1::UMat, map2::UMat) -> ( map1::UMat, map2::UMat ) 
	 undistortImage
	 .method("jlopencv_cv_fisheye_undistortImage",  [](Mat &distorted, Mat &K, Mat &D, Mat &undistorted, Mat &Knew, Size &new_size) { cv::fisheye::undistortImage(distorted, undistorted, K, D, Knew, new_size); return undistorted;})
		 undistortImage(distorted::Mat, K::Mat, D::Mat, undistorted::Mat, Knew::Mat, new_size::Size) -> ( undistorted::Mat ) 
	 undistortImage
	 .method("jlopencv_cv_fisheye_undistortImage",  [](UMat &distorted, UMat &K, UMat &D, UMat &undistorted, UMat &Knew, Size &new_size) { cv::fisheye::undistortImage(distorted, undistorted, K, D, Knew, new_size); return undistorted;})
		 undistortImage(distorted::UMat, K::UMat, D::UMat, undistorted::UMat, Knew::UMat, new_size::Size) -> ( undistorted::UMat ) 
	 estimateNewCameraMatrixForUndistortRectify
	 .method("jlopencv_cv_fisheye_estimateNewCameraMatrixForUndistortRectify",  [](Mat &K, Mat &D, Size &image_size, Mat &R, Mat &P, double &balance, Size &new_size, double &fov_scale) { cv::fisheye::estimateNewCameraMatrixForUndistortRectify(K, D, image_size, R, P, balance, new_size, fov_scale); return P;})
		 estimateNewCameraMatrixForUndistortRectify(K::Mat, D::Mat, image_size::Size, R::Mat, P::Mat, balance::double, new_size::Size, fov_scale::double) -> ( P::Mat ) 
	 estimateNewCameraMatrixForUndistortRectify
	 .method("jlopencv_cv_fisheye_estimateNewCameraMatrixForUndistortRectify",  [](UMat &K, UMat &D, Size &image_size, UMat &R, UMat &P, double &balance, Size &new_size, double &fov_scale) { cv::fisheye::estimateNewCameraMatrixForUndistortRectify(K, D, image_size, R, P, balance, new_size, fov_scale); return P;})
		 estimateNewCameraMatrixForUndistortRectify(K::UMat, D::UMat, image_size::Size, R::UMat, P::UMat, balance::double, new_size::Size, fov_scale::double) -> ( P::UMat ) 
	 calibrate
	 .method("jlopencv_cv_fisheye_calibrate",  [](vector<Mat> &objectPoints, vector<Mat> &imagePoints, Size &image_size, Mat &K, Mat &D, int &flags, TermCriteria &criteria) {vector<Mat> rvecs;vector<Mat> tvecs; auto retval = cv::fisheye::calibrate(objectPoints, imagePoints, image_size, K, D, rvecs, tvecs, flags, criteria); return make_tuple<double,Mat,Mat,vector<Mat>,vector<Mat>>(retval,K,D,rvecs,tvecs);})
		 calibrate(objectPoints::vector<Mat>, imagePoints::vector<Mat>, image_size::Size, K::Mat, D::Mat, flags::int, criteria::TermCriteria) -> ( retval::double, K::Mat, D::Mat, rvecs::vector<Mat>, tvecs::vector<Mat> ) 
	 calibrate
	 .method("jlopencv_cv_fisheye_calibrate",  [](vector<UMat> &objectPoints, vector<UMat> &imagePoints, Size &image_size, UMat &K, UMat &D, int &flags, TermCriteria &criteria) {vector<UMat> rvecs;vector<UMat> tvecs; auto retval = cv::fisheye::calibrate(objectPoints, imagePoints, image_size, K, D, rvecs, tvecs, flags, criteria); return make_tuple<double,UMat,UMat,vector<UMat>,vector<UMat>>(retval,K,D,rvecs,tvecs);})
		 calibrate(objectPoints::vector<UMat>, imagePoints::vector<UMat>, image_size::Size, K::UMat, D::UMat, flags::int, criteria::TermCriteria) -> ( retval::double, K::UMat, D::UMat, rvecs::vector<UMat>, tvecs::vector<UMat> ) 
	 stereoRectify
	 .method("jlopencv_cv_fisheye_stereoRectify",  [](Mat &K1, Mat &D1, Mat &K2, Mat &D2, Size &imageSize, Mat &R, Mat &tvec, int &flags, Mat &R1, Mat &R2, Mat &P1, Mat &P2, Mat &Q, Size &newImageSize, double &balance, double &fov_scale) { cv::fisheye::stereoRectify(K1, D1, K2, D2, imageSize, R, tvec, R1, R2, P1, P2, Q, flags, newImageSize, balance, fov_scale); return make_tuple<Mat,Mat,Mat,Mat,Mat>(R1,R2,P1,P2,Q);})
		 stereoRectify(K1::Mat, D1::Mat, K2::Mat, D2::Mat, imageSize::Size, R::Mat, tvec::Mat, flags::int, R1::Mat, R2::Mat, P1::Mat, P2::Mat, Q::Mat, newImageSize::Size, balance::double, fov_scale::double) -> ( R1::Mat, R2::Mat, P1::Mat, P2::Mat, Q::Mat ) 
	 stereoRectify
	 .method("jlopencv_cv_fisheye_stereoRectify",  [](UMat &K1, UMat &D1, UMat &K2, UMat &D2, Size &imageSize, UMat &R, UMat &tvec, int &flags, UMat &R1, UMat &R2, UMat &P1, UMat &P2, UMat &Q, Size &newImageSize, double &balance, double &fov_scale) { cv::fisheye::stereoRectify(K1, D1, K2, D2, imageSize, R, tvec, R1, R2, P1, P2, Q, flags, newImageSize, balance, fov_scale); return make_tuple<UMat,UMat,UMat,UMat,UMat>(R1,R2,P1,P2,Q);})
		 stereoRectify(K1::UMat, D1::UMat, K2::UMat, D2::UMat, imageSize::Size, R::UMat, tvec::UMat, flags::int, R1::UMat, R2::UMat, P1::UMat, P2::UMat, Q::UMat, newImageSize::Size, balance::double, fov_scale::double) -> ( R1::UMat, R2::UMat, P1::UMat, P2::UMat, Q::UMat ) 
	 stereoCalibrate
	 .method("jlopencv_cv_fisheye_stereoCalibrate",  [](vector<Mat> &objectPoints, vector<Mat> &imagePoints1, vector<Mat> &imagePoints2, Mat &K1, Mat &D1, Mat &K2, Mat &D2, Size &imageSize, Mat &R, Mat &T, int &flags, TermCriteria &criteria) { auto retval = cv::fisheye::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, K1, D1, K2, D2, imageSize, R, T, flags, criteria); return make_tuple<double,Mat,Mat,Mat,Mat,Mat,Mat>(retval,K1,D1,K2,D2,R,T);})
		 stereoCalibrate(objectPoints::vector<Mat>, imagePoints1::vector<Mat>, imagePoints2::vector<Mat>, K1::Mat, D1::Mat, K2::Mat, D2::Mat, imageSize::Size, R::Mat, T::Mat, flags::int, criteria::TermCriteria) -> ( retval::double, K1::Mat, D1::Mat, K2::Mat, D2::Mat, R::Mat, T::Mat ) 
	 stereoCalibrate
	 .method("jlopencv_cv_fisheye_stereoCalibrate",  [](vector<UMat> &objectPoints, vector<UMat> &imagePoints1, vector<UMat> &imagePoints2, UMat &K1, UMat &D1, UMat &K2, UMat &D2, Size &imageSize, UMat &R, UMat &T, int &flags, TermCriteria &criteria) { auto retval = cv::fisheye::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, K1, D1, K2, D2, imageSize, R, T, flags, criteria); return make_tuple<double,UMat,UMat,UMat,UMat,UMat,UMat>(retval,K1,D1,K2,D2,R,T);})
		 stereoCalibrate(objectPoints::vector<UMat>, imagePoints1::vector<UMat>, imagePoints2::vector<UMat>, K1::UMat, D1::UMat, K2::UMat, D2::UMat, imageSize::Size, R::UMat, T::UMat, flags::int, criteria::TermCriteria) -> ( retval::double, K1::UMat, D1::UMat, K2::UMat, D2::UMat, R::UMat, T::UMat ) 


	 CALIB_USE_INTRINSIC_GUESS 	 cv::fisheye::CALIB_USE_INTRINSIC_GUESS
	 CALIB_RECOMPUTE_EXTRINSIC 	 cv::fisheye::CALIB_RECOMPUTE_EXTRINSIC
	 CALIB_CHECK_COND 	 cv::fisheye::CALIB_CHECK_COND
	 CALIB_FIX_SKEW 	 cv::fisheye::CALIB_FIX_SKEW
	 CALIB_FIX_K1 	 cv::fisheye::CALIB_FIX_K1
	 CALIB_FIX_K2 	 cv::fisheye::CALIB_FIX_K2
	 CALIB_FIX_K3 	 cv::fisheye::CALIB_FIX_K3
	 CALIB_FIX_K4 	 cv::fisheye::CALIB_FIX_K4
	 CALIB_FIX_INTRINSIC 	 cv::fisheye::CALIB_FIX_INTRINSIC
	 CALIB_FIX_PRINCIPAL_POINT 	 cv::fisheye::CALIB_FIX_PRINCIPAL_POINT


cv.internal






{'FastFeatureDetector_DetectorType', 'String', 'IndexParams', 'vector<Point2f>', 'Rect', 'FileNode', 'vector<vector<Point2f>>', 'vector<vector<Point>>', 'Scalar', 'HandEyeCalibrationMethod', 'char', 'UMat', 'vector<DMatch>', 'Mat', 'ORB_ScoreType', 'Rect*', 'Ptr<DescriptorExtractor>', 'vector<Vec4f>', 'Ptr<ParamGrid>', 'HOGDescriptor_HistogramNormType', 'vector<UMat>', 'vector<vector<KeyPoint>>', 'Point2f', 'Ptr<flann_SearchParams>', 'AgastFeatureDetector_DetectorType', 'SearchParams', 'DrawMatchesFlags', 'vector<uchar>', 'DescriptorMatcher_MatcherType', 'Moments', 'double', 'vector<Rect>', 'TermCriteria', 'Point2d', 'int', 'int*', 'vector<Point>', 'Point*', 'Ptr<float>', 'vector<String>', 'Ptr<FileStorage>', 'cvflann_flann_distance_t', 'vector<Vec6f>', 'RNG*', 'Size', 'SolvePnPMethod', 'Ptr<TrainData>', 'float*', 'vector<float>', 'vector<vector<char>>', 'Ptr<DescriptorMatcher>', 'bool', 'Point2f*', 'vector<string>', 'size_t', 'Ptr<flann_IndexParams>', 'double*', 'AKAZE_DescriptorType', 'Point', 'CirclesGridFinderParameters', 'vector<char>', 'vector<vector<DMatch>>', 'vector<Mat>', 'Ptr<FeatureDetector>', 'RotatedRect', 'vector<KeyPoint>', 'vector<int>', 'float', 'SimpleBlobDetector_Params', 'KAZE_DiffusivityType', 'vector<double>'}
